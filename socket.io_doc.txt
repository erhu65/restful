## doc_docs_v4_.txt

- []
- Documentation
- Introduction

Version: 4.x

On this page

Introduction

[]tip

If you are new to Socket.IO, we recommend checking out our tutorial.

What Socket.IO is​

Socket.IO is a library that enables low-latency, bidirectional and
event-based communication between a client and a server.

[Diagram of a communication between a server and a client][Diagram of a
communication between a server and a client]

The Socket.IO connection can be established with different low-level
transports:

- HTTP long-polling
- WebSocket
- WebTransport

Socket.IO will automatically pick the best available option, depending
on:

- the capabilities of the browser (see here and here)
- the network (some networks block WebSocket and/or WebTransport
  connections)

You can find more detail about that in the "How it works" section.

Server implementations​

  ----------------------------------------------------------------------------------------
  Language                            Website
  ----------------------------------- ----------------------------------------------------
  JavaScript (Node.js)                - Installation steps
                                      - API
                                      - Source code

  JavaScript (Deno)                   https://github.com/socketio/socket.io-deno

  Java                                https://github.com/mrniko/netty-socketio

  Java                                https://github.com/trinopoty/socket.io-server-java

  Python                              https://github.com/miguelgrinberg/python-socketio

  Golang                              https://github.com/googollee/go-socket.io

  Rust                                https://github.com/Totodore/socketioxide
  ----------------------------------------------------------------------------------------

Client implementations​

  -----------------------------------------------------------------------------------------
  Language                            Website
  ----------------------------------- -----------------------------------------------------
  JavaScript (browser, Node.js or     - Installation steps
  React Native)                       - API
                                      - Source code

  JavaScript (for WeChat              https://github.com/weapp-socketio/weapp.socket.io
  Mini-Programs)                      

  Java                                https://github.com/socketio/socket.io-client-java

  C++                                 https://github.com/socketio/socket.io-client-cpp

  Swift                               https://github.com/socketio/socket.io-client-swift

  Dart                                https://github.com/rikulo/socket.io-client-dart

  Python                              https://github.com/miguelgrinberg/python-socketio

  .Net                                https://github.com/doghappy/socket.io-client-csharp

  Rust                                https://github.com/1c3t3a/rust-socketio

  Kotlin                              https://github.com/icerockdev/moko-socket-io

  PHP                                 https://github.com/ElephantIO/elephant.io

  Golang                              https://github.com/maldikhan/go.socket.io
  -----------------------------------------------------------------------------------------

What Socket.IO is not​

[]caution

Socket.IO is NOT a WebSocket implementation.

Although Socket.IO indeed uses WebSocket for transport when possible, it
adds additional metadata to each packet. That is why a WebSocket client
will not be able to successfully connect to a Socket.IO server, and a
Socket.IO client will not be able to connect to a plain WebSocket server
either.

    // WARNING: the client will NOT be able to connect!
    const socket = io("ws://echo.websocket.org");

[][]

If you are looking for a plain WebSocket server, please take a look at
ws or µWebSockets.js.

There are also discussions for including a WebSocket server in the
Node.js core.

On the client-side, you might be interested in the robust-websocket
package.

[]caution

Socket.IO is not meant to be used in a background service for mobile
applications.

The Socket.IO library keeps an open TCP connection to the server, which
may result in a high battery drain for your users. Please use a
dedicated messaging platform like FCM for this use case.

Features​

Here are the features provided by Socket.IO over plain WebSockets:

HTTP long-polling fallback​

The connection will fall back to HTTP long-polling in case the WebSocket
connection cannot be established.

This feature was the #1 reason people used Socket.IO when the project
was created more than ten years ago (!), as the browser support for
WebSockets was still in its infancy.

Even if most browsers now support WebSockets (more than 97%), it is
still a great feature as we still receive reports from users that cannot
establish a WebSocket connection because they are behind some
misconfigured proxy.

Automatic reconnection​

Under some particular conditions, the WebSocket connection between the
server and the client can be interrupted with both sides being unaware
of the broken state of the link.

That's why Socket.IO includes a heartbeat mechanism, which periodically
checks the status of the connection.

And when the client eventually gets disconnected, it automatically
reconnects with an exponential back-off delay, in order not to overwhelm
the server.

Packet buffering​

The packets are automatically buffered when the client is disconnected,
and will be sent upon reconnection.

More information here.

Acknowledgements​

Socket.IO provides a convenient way to send an event and receive a
response:

Sender

    socket.emit("hello", "world", (response) => {
      console.log(response); // "got it"
    });

[][]

Receiver

    socket.on("hello", (arg, callback) => {
      console.log(arg); // "world"
      callback("got it");
    });

[][]

You can also add a timeout:

    socket.timeout(5000).emit("hello", "world", (err, response) => {
      if (err) {
        // the other side did not acknowledge the event in the given delay
      } else {
        console.log(response); // "got it"
      }
    });

[][]

Broadcasting​

On the server-side, you can send an event to all connected clients or to
a subset of clients:

    // to all connected clients
    io.emit("hello");

    // to all connected clients in the "news" room
    io.to("news").emit("hello");

[][]

This also works when scaling to multiple nodes.

Multiplexing​

Namespaces allow you to split the logic of your application over a
single shared connection. This can be useful for example if you want to
create an "admin" channel that only authorized users can join.

    io.on("connection", (socket) => {
      // classic users
    });

    io.of("/admin").on("connection", (socket) => {
      // admin users
    });

[][]

More on that here.

Common questions​

Is Socket.IO still needed today?​

That's a fair question, since WebSockets are supported almost everywhere
now.

That being said, we believe that, if you use plain WebSockets for your
application, you will eventually need to implement most of the features
that are already included (and battle-tested) in Socket.IO, like
reconnection, acknowledgements or broadcasting.

What is the overhead of the Socket.IO protocol?​

socket.emit("hello", "world") will be sent as a single WebSocket frame
containing 42["hello","world"] with:

- 4 being Engine.IO "message" packet type
- 2 being Socket.IO "message" packet type
- ["hello","world"] being the JSON.stringify()-ed version of the
  arguments array

So, a few additional bytes for each message, which can be further
reduced by the usage of a custom parser.

[]info

The size of the browser bundle itself is 10.4 kB (minified and gzipped).

You can find the details of the Socket.IO protocol here.

Something does not work properly, please help?​

Please check our Troubleshooting guide.

Next steps​

- Get started example
- Server installation
- Client installation

[]Edit this page

Last updated on Mar 28, 2025

Next

How it works

- What Socket.IO is
  - Server implementations
  - Client implementations
- What Socket.IO is not
- Features
  - HTTP long-polling fallback
  - Automatic reconnection
  - Packet buffering
  - Acknowledgements
  - Broadcasting
  - Multiplexing
- Common questions
  - Is Socket.IO still needed today?
  - What is the overhead of the Socket.IO protocol?
  - Something does not work properly, please help?
- Next steps

=============

## doc_docs_v4_adapter_.txt

- []
- Adapters
- Introduction

Version: 4.x

On this page

Adapter

An Adapter is a server-side component which is responsible for
broadcasting events to all or a subset of clients.

When scaling to multiple Socket.IO servers, you will need to replace the
default in-memory adapter by another implementation, so the events are
properly routed to all clients.

Here is the list of adapters that are maintained by our team:

- the Redis adapter
- the Redis Streams adapter
- the MongoDB adapter
- the Postgres adapter
- the Cluster adapter
- the Google Cloud Pub/Sub adapter
- the AWS SQS adapter
- the Azure Service Bus adapter

There are also several other options which are maintained by the
(awesome!) community:

- AMQP (e.g. RabbitMQ)
- NATS
- NATS

Please note that enabling sticky sessions is still needed when using
multiple Socket.IO servers and HTTP long-polling. More information here.

API​

You can have access to the adapter instance with:

    // main namespace
    const mainAdapter = io.of("/").adapter; // WARNING! io.adapter() will not work
    // custom namespace
    const adminAdapter = io.of("/admin").adapter;

[][]

Starting with socket.io@3.1.0, each Adapter instance emits the following
events:

- create-room (argument: room)
- delete-room (argument: room)
- join-room (argument: room, id)
- leave-room (argument: room, id)

Example:

    io.of("/").adapter.on("create-room", (room) => {
      console.log(`room ${room} was created`);
    });

    io.of("/").adapter.on("join-room", (room, id) => {
      console.log(`socket ${id} has joined room ${room}`);
    });

[][]

Emitter​

Most adapter implementations come with their associated emitter package,
which allows communicating to the group of Socket.IO servers from
another Node.js process.

[Emitter diagram][Emitter diagram]

This may be useful for example in a microservice setup, where all
clients connect to the microservice M1, while the microservice M2 uses
the emitter to broadcast packets (uni-directional communication).

Emitter cheatsheet​

    // to all clients
    emitter.emit(/* ... */);

    // to all clients in "room1"
    emitter.to("room1").emit(/* ... */);

    // to all clients in "room1" except those in "room2"
    emitter.to("room1").except("room2").emit(/* ... */);

    const adminEmitter = emitter.of("/admin");

    // to all clients in the "admin" namespace
    adminEmitter.emit(/* ... */);

    // to all clients in the "admin" namespace and in the "room1" room
    adminEmitter.to("room1").emit(/* ... */);

[][]

The emitter also supports the utility methods that were added in
socket.io@4.0.0:

- socketsJoin()

    // make all Socket instances join the "room1" room
    emitter.socketsJoin("room1");

    // make all Socket instances of the "admin" namespace in the "room1" room join the "room2" room
    emitter.of("/admin").in("room1").socketsJoin("room2");

[][]

- socketsLeave()

    // make all Socket instances leave the "room1" room
    emitter.socketsLeave("room1");

    // make all Socket instances in the "room1" room leave the "room2" and "room3" rooms
    emitter.in("room1").socketsLeave(["room2", "room3"]);

    // make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" room
    emitter.of("/admin").in("room1").socketsLeave("room2");

[][]

- disconnectSockets()

    // make all Socket instances disconnect
    emitter.disconnectSockets();

    // make all Socket instances in the "room1" room disconnect (and discard the low-level connection)
    emitter.in("room1").disconnectSockets(true);

    // make all Socket instances in the "room1" room of the "admin" namespace disconnect
    emitter.of("/admin").in("room1").disconnectSockets();

    // this also works with a single socket ID
    emitter.of("/admin").in(theSocketId).disconnectSockets();

[][]

- serverSideEmit()

    // emit an event to all the Socket.IO servers of the cluster
    emitter.serverSideEmit("hello", "world");

    // Socket.IO server (server-side)
    io.on("hello", (arg) => {
      console.log(arg); // prints "world"
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Rooms

Next

Redis adapter

- API
- Emitter
- Emitter cheatsheet

=============

## doc_docs_v4_admin-ui_.txt

- []
- Advanced
- Admin UI

Version: 4.x

On this page

Admin UI

The Socket.IO admin UI can be used to have an overview of the state of
your Socket.IO deployment.

The source code can be found here:
https://github.com/socketio/socket.io-admin-ui/

Link to the hosted version: https://admin.socket.io/

Current features​

- overview of the servers and the clients that are currently connected

[Screenshot of the dashboard]

- details of each socket instance (active transport, handshake, rooms,
  ...)

[Screenshot of the page displaying the details of a socket]

- details of each room

[Screenshot of the page displaying the details of a room]

- details of every event emitted or received by the server

[Screenshot of the page displaying the list of events]

- administrative operations (join, leave, disconnect)

If you have any feedback / suggestions, do not hesitate!

Installation​

Server-side​

First, install the @socket.io/admin-ui package:

    npm i @socket.io/admin-ui

[][]

And then invoke the instrument method on your Socket.IO server:

    const { createServer } = require("http");
    const { Server } = require("socket.io");
    const { instrument } = require("@socket.io/admin-ui");

    const httpServer = createServer();

    const io = new Server(httpServer, {
      cors: {
        origin: ["https://admin.socket.io"],
        credentials: true
      }
    });

    instrument(io, {
      auth: false,
      mode: "development",
    });

    httpServer.listen(3000);

[][]

The module is compatible with:

- Socket.IO v4 server
- Socket.IO v3 server (>= 3.1.0), but without the operations on rooms
  (join, leave, disconnection)

Example with NestJS:

    import { instrument } from "@socket.io/admin-ui";

    @WebSocketGateway()
    export class MyGateway {
        // ...
        afterInit() {
            instrument(this.server, {
                auth: false,
                mode: "development",
            });
        }
    }

[][]

Client-side​

You can then head up to https://admin.socket.io, or host the files found
in the ui/dist folder here.

Important note: the website at https://admin.socket.io is totally static
(hosted on Vercel), we do not (and will never) store any information
about yourself or your browser (no tracking, no analytics, ...). That
being said, hosting the files yourself is totally fine.

You should see the following modal:

[login modal screenshot]

Please enter the URL of your server (for example, http://localhost:3000
or https://example.com) and the credentials, if applicable (see the auth
option below).

Available options​

auth​

Default value: -

This option is mandatory. You can either disable authentication (please
use with caution):

    instrument(io, {
      auth: false
    });

[][]

Or use basic authentication:

    instrument(io, {
      auth: {
        type: "basic",
        username: "admin",
        password: "$2b$10$heqvAkYMez.Va6Et2uXInOnkCT6/uQj1brkrbyG3LpopDklcq7ZOS" // "changeit" encrypted with bcrypt
      },
    });

[][]

[]caution

Please note that the bcrypt package does not currently support hashes
starting with the $2y$ prefix, which is used by some BCrypt
implementations (for example https://bcrypt-generator.com/ or
https://www.bcrypt.fr/). You can check the validity of the hash with:

    $ node
    > require("bcryptjs").compareSync("<the password>", "<the hash>")
    true

[][]

You can generate a valid hash with:

    $ node
    > require("bcryptjs").hashSync("changeit", 10)
    '$2b$10$LQUE...'

[][]

See also:

- https://github.com/kelektiv/node.bcrypt.js/issues/849
- https://stackoverflow.com/a/36225192/5138796

namespaceName​

Default value: /admin

The name of the namespace which will be created to handle the
administrative tasks.

    instrument(io, {
      namespaceName: "/custom"
    });

[][]

This namespace is a classic Socket.IO namespace, you can access it with:

    const adminNamespace = io.of("/admin");

[][]

More information here.

readonly​

Default value: false

Whether to put the admin UI in read-only mode (no join, leave or
disconnect allowed).

    instrument(io, {
      readonly: true
    });

[][]

serverId​

Default value: require("os").hostname()

The ID of the given server. If you have several Socket.IO servers on the
same machine, you'll need to give them a distinct ID:

    instrument(io, {
      serverId: `${require("os").hostname()}#${process.pid}`
    });

[][]

store​

Default value: new InMemoryStore()

The store is used to store the session IDs so the user do not have to
retype the credentials upon reconnection.

If you use basic authentication in a multi-server setup, you should
provide a custom store:

    const { instrument, RedisStore } = require("@socket.io/admin-ui");

    instrument(io, {
      store: new RedisStore(redisClient)
    });

[][]

mode​

Default value: development

In production mode, the server won't send all details about the socket
instances and the rooms, thus reducing the memory footprint of the
instrumentation.

    instrument(io, {
      mode: "production"
    });

[][]

The production mode can also be enabled with the NODE_ENV environment
variable:

    NODE_ENV=production node index.js

[][]

How it works​

The source code can be found here:
https://github.com/socketio/socket.io-admin-ui/

The instrument method simply:

- creates a namespace and adds an authentication middleware if
  applicable
- register listeners for the connection and disconnect events for each
  existing namespaces to track the socket instances
- register a timer which will periodically send stats from the server to
  the UI
- register handlers for the join, leave and _disconnect commands sent
  from the UI

Latest releases​

- 0.5.1 (Oct 2022): GitHub release / diff
- 0.5.0 (Sep 2022): GitHub release / diff
- 0.4.0 (Jun 2022): GitHub release / diff

[]Edit this page

Last updated on Mar 28, 2025

Previous

Custom parser

Next

Usage with PM2

- Current features
- Installation
  - Server-side
  - Client-side
  - Available options
- How it works
- Latest releases

=============

## doc_docs_v4_broadcasting-events_https:__socket.io_docs_v4_rooms_.txt

Redirecting...

=============

## doc_docs_v4_client-api_.txt

- []
- API

Version: 4.x

On this page

Client API

IO​

The io method is bound to the global scope in the standalone build:

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();
    </script>

[][]

An ESM bundle is also available since version 4.3.0:

    <script type="module">
      import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";

      const socket = io();
    </script>

[][]

With an import map:

    <script type="importmap">
      {
        "imports": {
          "socket.io-client": "https://cdn.socket.io/4.8.1/socket.io.esm.min.js"
        }
      }
    </script>

    <script type="module">
      import { io } from "socket.io-client";

      const socket = io();
    </script>

[][]

Else, in all other cases (with some build tools, in Node.js or React
Native), it can be imported from the socket.io-client package:

    // ES modules
    import { io } from "socket.io-client";

    // CommonJS
    const { io } = require("socket.io-client");

[][]

io.protocol​

- <number>

The protocol revision number (currently: 5).

The protocol defines the format of the packets exchanged between the
client and the server. Both the client and the server must use the same
revision in order to understand each other.

You can find more information here.

io([url][, options])​

- url <string> (defaults to window.location.host)
- options <Object>
  - forceNew <boolean> whether to create a new connection
- Returns <Socket>

Creates a new Manager for the given URL, and attempts to reuse an
existing Manager for subsequent calls, unless the multiplex option is
passed with false. Passing this option is the equivalent of passing
"force new connection": true or forceNew: true.

A new Socket instance is returned for the namespace specified by the
pathname in the URL, defaulting to /. For example, if the url is
http://localhost/users, a transport connection will be established to
http://localhost and a Socket.IO connection will be established to
/users.

Query parameters can also be provided, either with the query option or
directly in the url (example: http://localhost/users?token=abc).

To understand what happens under the hood, the following example:

    import { io } from "socket.io-client";

    const socket = io("ws://example.com/my-namespace", {
      reconnectionDelayMax: 10000,
      auth: {
        token: "123"
      },
      query: {
        "my-key": "my-value"
      }
    });

[][]

is the short version of:

    import { Manager } from "socket.io-client";

    const manager = new Manager("ws://example.com", {
      reconnectionDelayMax: 10000,
      query: {
        "my-key": "my-value"
      }
    });

    const socket = manager.socket("/my-namespace", {
      auth: {
        token: "123"
      }
    });

[][]

The complete list of available options can be found here.

Manager​

[Manager in the class diagram for the client][Manager in the class
diagram for the client]

The Manager manages the Engine.IO client instance, which is the
low-level engine that establishes the connection to the server (by using
transports like WebSocket or HTTP long-polling).

The Manager handles the reconnection logic.

A single Manager can be used by several Sockets. You can find more
information about this multiplexing feature here.

Please note that, in most cases, you won't use the Manager directly but
use the Socket instance instead.

Constructor​

new Manager(url[, options])​

- url <string>
- options <Object>
- Returns <Manager>

The complete list of available options can be found here.

    import { Manager } from "socket.io-client";

    const manager = new Manager("https://example.com");

    const socket = manager.socket("/"); // main namespace
    const adminSocket = manager.socket("/admin"); // admin namespace

[][]

Events​

Event: 'error'​

- error <Error> error object

Fired upon a connection error.

    socket.io.on("error", (error) => {
      // ...
    });

[][]

Event: 'ping'​

Fired when a ping packet is received from the server.

    socket.io.on("ping", () => {
      // ...
    });

[][]

Event: 'reconnect'​

- attempt <number> reconnection attempt number

Fired upon a successful reconnection.

    socket.io.on("reconnect", (attempt) => {
      // ...
    });

[][]

Event: 'reconnect_attempt'​

- attempt <number> reconnection attempt number

Fired upon an attempt to reconnect.

    socket.io.on("reconnect_attempt", (attempt) => {
      // ...
    });

[][]

Event: 'reconnect_error'​

- error <Error> error object

Fired upon a reconnection attempt error.

    socket.io.on("reconnect_error", (error) => {
      // ...
    });

[][]

Event: 'reconnect_failed'​

Fired when couldn't reconnect within reconnectionAttempts.

    socket.io.on("reconnect_failed", () => {
      // ...
    });

[][]

Methods​

manager.connect([callback])​

Synonym of manager.open([callback]).

manager.open([callback])​

- callback <Function>
- Returns <Manager>

If the manager was initiated with autoConnect to false, launch a new
connection attempt.

The callback argument is optional and will be called once the attempt
fails/succeeds.

    import { Manager } from "socket.io-client";

    const manager = new Manager("https://example.com", {
      autoConnect: false
    });

    const socket = manager.socket("/");

    manager.open((err) => {
      if (err) {
        // an error has occurred
      } else {
        // the connection was successfully established
      }
    });

[][]

manager.reconnection([value])​

- value <boolean>
- Returns <Manager> | <boolean>

Sets the reconnection option, or returns it if no parameters are passed.

manager.reconnectionAttempts([value])​

- value <number>
- Returns <Manager> | <number>

Sets the reconnectionAttempts option, or returns it if no parameters are
passed.

manager.reconnectionDelay([value])​

- value <number>
- Returns <Manager> | <number>

Sets the reconnectionDelay option, or returns it if no parameters are
passed.

manager.reconnectionDelayMax([value])​

- value <number>
- Returns <Manager> | <number>

Sets the reconnectionDelayMax option, or returns it if no parameters are
passed.

manager.socket(nsp, options)​

- nsp <string>
- options <Object>
- Returns <Socket>

Creates a new Socket for the given namespace. Only auth
({ auth: {key: "value"} }) is read from the options object. Other keys
will be ignored and should be passed when instancing a
new Manager(nsp, options).

manager.timeout([value])​

- value <number>
- Returns <Manager> | <number>

Sets the timeout option, or returns it if no parameters are passed.

Socket​

[Socket in the class diagram for the client][Socket in the class diagram
for the client]

A Socket is the fundamental class for interacting with the server. A
Socket belongs to a certain Namespace (by default /) and uses an
underlying Manager to communicate.

A Socket is basically an EventEmitter which sends events to — and
receive events from — the server over the network.

    socket.emit("hello", { a: "b", c: [] });

    socket.on("hey", (...args) => {
      // ...
    });

[][]

More information can be found here.

Events​

Event: 'connect'​

This event is fired by the Socket instance upon connection and
reconnection.

    socket.on("connect", () => {
      // ...
    });

[][]

[]caution

Event handlers shouldn't be registered in the connect handler itself, as
a new handler will be registered every time the socket instance
reconnects:

BAD ⚠️

    socket.on("connect", () => {
      socket.on("data", () => { /* ... */ });
    });

[][]

GOOD 👍

    socket.on("connect", () => {
      // ...
    });

    socket.on("data", () => { /* ... */ });

[][]

Event: 'connect_error'​

- error <Error>

This event is fired upon connection failure.

  Reason                                                               Automatic reconnection?
  -------------------------------------------------------------------- -------------------------
  The low-level connection cannot be established (temporary failure)   ✅ YES
  The connection was denied by the server in a middleware function     ❌ NO

The socket.active attribute indicates whether the socket will
automatically try to reconnect after a small randomized delay:

    socket.on("connect_error", (error) => {
      if (socket.active) {
        // temporary failure, the socket will automatically try to reconnect
      } else {
        // the connection was denied by the server
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(error.message);
      }
    });

[][]

Event: 'disconnect'​

- reason <string>
- details <DisconnectDetails>

This event is fired upon disconnection.

    socket.on("disconnect", (reason, details) => {
      // ...
    });

[][]

Here is the list of possible reasons:

  Reason                 Description                                                                                                     Automatic reconnection?
  ---------------------- --------------------------------------------------------------------------------------------------------------- -------------------------
  io server disconnect   The server has forcefully disconnected the socket with socket.disconnect()                                      ❌ NO
  io client disconnect   The socket was manually disconnected using socket.disconnect()                                                  ❌ NO
  ping timeout           The server did not send a PING within the pingInterval + pingTimeout range                                      ✅ YES
  transport close        The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)   ✅ YES
  transport error        The connection has encountered an error (example: the server was killed during a HTTP long-polling cycle)       ✅ YES

The socket.active attribute indicates whether the socket will
automatically try to reconnect after a small randomized delay:

    socket.on("disconnect", (reason) => {
      if (socket.active) {
        // temporary disconnection, the socket will automatically try to reconnect
      } else {
        // the connection was forcefully closed by the server or the client itself
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(reason);
      }
    });

[][]

Attributes​

socket.active​

- <boolean>

Whether the socket will automatically try to reconnect.

This attribute can be used after a connection failure:

    socket.on("connect_error", (error) => {
      if (socket.active) {
        // temporary failure, the socket will automatically try to reconnect
      } else {
        // the connection was denied by the server
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(error.message);
      }
    });

[][]

Or after a disconnection:

    socket.on("disconnect", (reason) => {
      if (socket.active) {
        // temporary disconnection, the socket will automatically try to reconnect
      } else {
        // the connection was forcefully closed by the server or the client itself
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(reason);
      }
    });

[][]

socket.connected​

- <boolean>

Whether the socket is currently connected to the server.

    const socket = io();

    console.log(socket.connected); // false

    socket.on("connect", () => {
      console.log(socket.connected); // true
    });

[][]

socket.disconnected​

- <boolean>

Whether the socket is currently disconnected from the server.

    const socket = io();

    console.log(socket.disconnected); // true

    socket.on("connect", () => {
      console.log(socket.disconnected); // false
    });

[][]

socket.id​

- <string>

A unique identifier for the socket session. Set after the connect event
is triggered, and updated after the reconnect event.

    const socket = io();

    console.log(socket.id); // undefined

    socket.on("connect", () => {
      console.log(socket.id); // "G5p5..."
    });

[][]

[]caution

The id attribute is an ephemeral ID that is not meant to be used in your
application (or only for debugging purposes) because:

- this ID is regenerated after each reconnection (for example when the
  WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if
  the client is disconnected, the messages sent from the server to this
  ID are lost)

Please use a regular session ID instead (either sent in a cookie, or
stored in the localStorage and sent in the auth payload).

See also:

- Part II of our private message guide
- How to deal with cookies

socket.io​

- <Manager>

A reference to the underlying Manager.

    socket.on("connect", () => {
      const engine = socket.io.engine;
      console.log(engine.transport.name); // in most cases, prints "polling"

      engine.once("upgrade", () => {
        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)
        console.log(engine.transport.name); // in most cases, prints "websocket"
      });

      engine.on("packet", ({ type, data }) => {
        // called for each packet received
      });

      engine.on("packetCreate", ({ type, data }) => {
        // called for each packet sent
      });

      engine.on("drain", () => {
        // called when the write buffer is drained
      });

      engine.on("close", (reason) => {
        // called when the underlying connection is closed
      });
    });

[][]

socket.recovered​

Added in v4.6.0

- <boolean>

Whether the connection state was successfully recovered during the last
reconnection.

    socket.on("connect", () => {
      if (socket.recovered) {
        // any event missed during the disconnection period will be received now
      } else {
        // new or unrecoverable session
      }
    });

[][]

More information about this feature here.

Methods​

socket.close()​

Added in v1.0.0

Synonym of socket.disconnect().

socket.compress(value)​

- value <boolean>
- Returns <Socket>

Sets a modifier for a subsequent event emission that the event data will
only be compressed if the value is true. Defaults to true when you don't
call the method.

    socket.compress(false).emit("an event", { some: "data" });

[][]

socket.connect()​

Added in v1.0.0

- Returns Socket

Manually connects the socket.

    const socket = io({
      autoConnect: false
    });

    // ...
    socket.connect();

[][]

It can also be used to manually reconnect:

    socket.on("disconnect", () => {
      socket.connect();
    });

[][]

socket.disconnect()​

Added in v1.0.0

- Returns <Socket>

Manually disconnects the socket. In that case, the socket will not try
to reconnect.

Associated disconnection reason:

- client-side: "io client disconnect"
- server-side: "client namespace disconnect"

If this is the last active Socket instance of the Manager, the low-level
connection will be closed.

socket.emit(eventName[, ...args][, ack])​

- eventName <string> | <symbol>
- args <any[]>
- ack <Function>
- Returns true

Emits an event to the socket identified by the string name. Any other
parameters can be included. All serializable data structures are
supported, including Buffer.

    socket.emit("hello", "world");
    socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });

[][]

The ack argument is optional and will be called with the server answer.

Client

    socket.emit("hello", "world", (response) => {
      console.log(response); // "got it"
    });

[][]

Server

    io.on("connection", (socket) => {
      socket.on("hello", (arg, callback) => {
        console.log(arg); // "world"
        callback("got it");
      });
    });

[][]

socket.emitWithAck(eventName[, ...args])​

Added in v4.6.0

- eventName <string> | <symbol>
- args any[]
- Returns Promise<any>

Promised-based version of emitting and expecting an acknowledgement from
the server:

    // without timeout
    const response = await socket.emitWithAck("hello", "world");

    // with a specific timeout
    try {
      const response = await socket.timeout(10000).emitWithAck("hello", "world");
    } catch (err) {
      // the server did not acknowledge the event in the given delay
    }

[][]

The example above is equivalent to:

    // without timeout
    socket.emit("hello", "world", (val) => {
      // ...
    });

    // with a specific timeout
    socket.timeout(10000).emit("hello", "world", (err, val) => {
      // ...
    });

[][]

And on the receiving side:

    io.on("connection", (socket) => {
      socket.on("hello", (arg1, callback) => {
        callback("got it"); // only one argument is expected
      });
    });

[][]

[]caution

Environments that do not support Promises will need to add a polyfill in
order to use this feature.

socket.listeners(eventName)​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- Returns <Function[]>

Returns the array of listeners for the event named eventName.

    socket.on("my-event", () => {
      // ...
    });

    console.log(socket.listeners("my-event")); // prints [ [Function] ]

[][]

socket.listenersAny()​

Added in v3.0.0

- Returns <Function[]>

Returns the list of registered catch-all listeners.

    const listeners = socket.listenersAny();

[][]

socket.listenersAnyOutgoing()​

Added in v4.5.0

- Returns <Function[]>

Returns the list of registered catch-all listeners for outgoing packets.

    const listeners = socket.listenersAnyOutgoing();

[][]

socket.off([eventName][, listener])​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>

Removes the specified listener from the listener array for the event
named eventName.

    const myListener = () => {
      // ...
    }

    socket.on("my-event", myListener);

    // then later
    socket.off("my-event", myListener);

[][]

The listener argument can also be omitted:

    // remove all listeners for that event
    socket.off("my-event");

    // remove all listeners for all events
    socket.off();

[][]

socket.offAny([listener])​

Added in v3.0.0

- listener <Function>

Removes the previously registered listener. If no listener is provided,
all catch-all listeners are removed.

    const myListener = () => { /* ... */ };

    socket.onAny(myListener);

    // then, later
    socket.offAny(myListener);

    socket.offAny();

[][]

socket.offAnyOutgoing([listener])​

Added in v4.5.0

- listener <Function>

Removes the previously registered listener. If no listener is provided,
all catch-all listeners are removed.

    const myListener = () => { /* ... */ };

    socket.onAnyOutgoing(myListener);

    // remove a single listener
    socket.offAnyOutgoing(myListener);

    // remove all listeners
    socket.offAnyOutgoing();

[][]

socket.on(eventName, callback)​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>

Register a new handler for the given event.

    socket.on("news", (data) => {
      console.log(data);
    });

    // with multiple arguments
    socket.on("news", (arg1, arg2, arg3, arg4) => {
      // ...
    });
    // with callback
    socket.on("news", (cb) => {
      cb(0);
    });

[][]

socket.onAny(callback)​

Added in v3.0.0

- callback <Function>

Register a new catch-all listener.

    socket.onAny((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.emit("foo", (value) => {
      // ...
    });

    socket.onAnyOutgoing(() => {
      // triggered when the event is sent
    });

    socket.onAny(() => {
      // not triggered when the acknowledgement is received
    });

[][]

socket.onAnyOutgoing(callback)​

Added in v4.5.0

- callback <Function>

Register a new catch-all listener for outgoing packets.

    socket.onAnyOutgoing((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.on("foo", (value, callback) => {
      callback("OK");
    });

    socket.onAny(() => {
      // triggered when the event is received
    });

    socket.onAnyOutgoing(() => {
      // not triggered when the acknowledgement is sent
    });

[][]

socket.once(eventName, callback)​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>

Adds a one-time listener function for the event named eventName. The
next time eventName is triggered, this listener is removed and then
invoked.

    socket.once("my-event", () => {
      // ...
    });

[][]

socket.open()​

Added in v1.0.0

Synonym of socket.connect().

socket.prependAny(callback)​

Added in v3.0.0

- callback <Function>

Register a new catch-all listener. The listener is added to the
beginning of the listeners array.

    socket.prependAny((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

socket.prependAnyOutgoing(callback)​

Added in v4.5.0

- callback <Function>

Register a new catch-all listener for outgoing packets. The listener is
added to the beginning of the listeners array.

    socket.prependAnyOutgoing((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

socket.send([...args][, ack])​

- args <any[]>
- ack <Function>
- Returns <Socket>

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

socket.timeout(value)​

Added in v4.4.0

- value <number>
- Returns <Socket>

Sets a modifier for a subsequent event emission that the callback will
be called with an error when the given number of milliseconds have
elapsed without an acknowledgement from the server:

    socket.timeout(5000).emit("my-event", (err) => {
      if (err) {
        // the server did not acknowledge the event in the given delay
      }
    });

[][]

Flags​

Flag: 'volatile'​

Added in v3.0.0

Sets a modifier for the subsequent event emission indicating that the
packet may be dropped if:

- the socket is not connected
- the low-level transport is not writable (for example, when a POST
  request is already running in HTTP long-polling mode)

    socket.volatile.emit(/* ... */); // the server may or may not receive it

[][]

[]Edit this page

Last updated on Mar 28, 2025

Next

Options

- IO
  - io.protocol
  - io(url)
- Manager
  - Constructor
    - new Manager(url, options)
  - Events
    - Event: 'error'
    - Event: 'ping'
    - Event: 'reconnect'
    - Event: 'reconnect_attempt'
    - Event: 'reconnect_error'
    - Event: 'reconnect_failed'
  - Methods
    - manager.connect(callback)
    - manager.open(callback)
    - manager.reconnection(value)
    - manager.reconnectionAttempts(value)
    - manager.reconnectionDelay(value)
    - manager.reconnectionDelayMax(value)
    - manager.socket(nsp, options)
    - manager.timeout(value)
- Socket
  - Events
    - Event: 'connect'
    - Event: 'connect_error'
    - Event: 'disconnect'
  - Attributes
    - socket.active
    - socket.connected
    - socket.disconnected
    - socket.id
    - socket.io
    - socket.recovered
  - Methods
    - socket.close()
    - socket.compress(value)
    - socket.connect()
    - socket.disconnect()
    - socket.emit(eventName, ...args)
    - socket.emitWithAck(eventName, ...args)
    - socket.listeners(eventName)
    - socket.listenersAny()
    - socket.listenersAnyOutgoing()
    - socket.off(eventName)
    - socket.offAny(listener)
    - socket.offAnyOutgoing(listener)
    - socket.on(eventName, callback)
    - socket.onAny(callback)
    - socket.onAnyOutgoing(callback)
    - socket.once(eventName, callback)
    - socket.open()
    - socket.prependAny(callback)
    - socket.prependAnyOutgoing(callback)
    - socket.send(...args)
    - socket.timeout(value)
  - Flags
    - Flag: 'volatile'

=============

## doc_docs_v4_client-initialization_.txt

- []
- Client
- Initialization

Version: 4.x

On this page

Client Initialization

Once you have installed the Socket.IO client library, you can now init
the client. The complete list of options can be found here.

[]tip

For TypeScript users, it is possible to provide type hints for the
events. Please check this.

In the examples below, the io object comes either from:

- the <script> import

    <script src="/socket.io/socket.io.js"></script>

[][]

- an ESM import

    <script type="module">
      import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";
    </script>

[][]

- NPM

- CommonJS
- ES modules
- TypeScript

    const { io } = require("socket.io-client");

[][]

    import { io } from "socket.io-client";

[][]

    import { io } from "socket.io-client";

[][]

From the same domain​

If your front is served on the same domain as your server, you can
simply use:

    const socket = io();

[][]

The server URL will be deduced from the window.location object.

From a different domain​

In case your front is not served from the same domain as your server,
you have to pass the URL of your server.

    const socket = io("https://server-domain.com");

[][]

In that case, please make sure to enable Cross-Origin Resource Sharing
(CORS) on the server.

[]info

You can use either https or wss (respectively, http or ws).

    // the following forms are similar
    const socket = io("https://server-domain.com");
    const socket = io("wss://server-domain.com");
    const socket = io("server-domain.com"); // only in the browser when the page is served over https (will not work in Node.js)

[][]

Custom namespace​

In the examples above, the client will connect to the main namespace.
Using only the main namespace should be sufficient for most use cases,
but you can specify the namespace with:

    // same origin version
    const socket = io("/admin");
    // cross origin version
    const socket = io("https://server-domain.com/admin");

[][]

You can find more details about namespaces here.

Options​

The complete list of available options can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Installation

Next

The Socket instance

- From the same domain
- From a different domain
- Custom namespace
- Options

=============

## doc_docs_v4_client-installation_.txt

- []
- Client
- Installation

Version: 4.x

On this page

Client Installation

[]info

The latest release is currently 4.8.1, released in October 2024.

You can find the release notes here.

Version compatibility​

Here is the compatibility table between the server and the JS client:

   JS Client version   Socket.IO server version               
  ------------------- -------------------------- ----- ------ ------
          1.x                    2.x              3.x   4.x   
          1.x                    YES              NO     NO   NO
          2.x                     NO              YES   YES¹  YES¹
          3.x                     NO              NO    YES   YES
          4.x                     NO              NO    YES   YES

[1] Yes, with allowEIO3: true

Please check the associated migration guides:

- v2 to v3
- v3 to v4

Browser support​

Socket.IO does support IE9 and above. IE 6/7/8 are not supported
anymore.

Browser compatibility is tested thanks to the awesome Sauce Labs
platform:

[Browser support]

Installation​

Standalone build​

By default, the Socket.IO server exposes a client bundle at
/socket.io/socket.io.js.

io will be registered as a global variable:

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();
    </script>

[][]

If you don't need this (see other options below), you can disable the
functionality on the server side:

    const { Server } = require("socket.io");

    const io = new Server({
      serveClient: false
    });

[][]

From a CDN​

You can also include the client bundle from a CDN:

    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>

[][]

Socket.IO is also available from other CDN:

- cdnjs:
  https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js
- jsDelivr:
  https://cdn.jsdelivr.net/npm/socket.io-client@4.8.1/dist/socket.io.min.js
- unpkg: https://unpkg.com/socket.io-client@4.8.1/dist/socket.io.min.js

There are several bundles available:

  Name                       Size               Description
  -------------------------- ------------------ ---------------------------------------------------------------
  socket.io.js               34.7 kB gzip       Unminified version, with debug
  socket.io.min.js           14.7 kB min+gzip   Production version, without debug
  socket.io.msgpack.min.js   15.3 kB min+gzip   Production version, without debug and with the msgpack parser

The debug package allows to print debug information to the console. You
can find more information here.

During development, we recommend using the socket.io.js bundle. By
setting localStorage.debug = 'socket.io-client:socket', any event
received by the client will be printed to the console.

For production, please use the socket.io.min.js bundle, which is an
optimized build excluding the debug package.

From NPM​

The Socket.IO client is compatible with bundlers like webpack or
browserify.

- NPM
- Yarn
- pnpm
- Bun

    npm install socket.io-client

[][]

    yarn add socket.io-client

[][]

    pnpm add socket.io-client

[][]

    bun add socket.io-client

[][]

The client can also be run from Node.js.

Note: for the reasons cited above, you may want to exclude debug from
your browser bundle. With webpack, you can use webpack-remove-debug.

Note for TypeScript users: the types are now included in the
socket.io-client package and thus the types from @types/socket.io-client
are not needed anymore and may in fact cause errors:

    Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'

[][]

Miscellaneous​

Dependency tree​

A basic installation of the client includes 9 packages, of which 5 are
maintained by our team:

    └─┬ socket.io-client@4.8.1
      ├── @socket.io/component-emitter@3.1.2
      ├─┬ debug@4.3.7
      │ └── ms@2.1.3
      ├─┬ engine.io-client@6.6.3
      │ ├── @socket.io/component-emitter@3.1.2 deduped
      │ ├── debug@4.3.7 deduped
      │ ├── engine.io-parser@5.2.3
      │ ├─┬ ws@8.17.1
      │ │ ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1
      │ │ └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2
      │ └── xmlhttprequest-ssl@2.1.2
      └─┬ socket.io-parser@4.2.4
        ├── @socket.io/component-emitter@3.1.2 deduped
        └── debug@4.3.7 deduped

[][]

Transitive versions​

The engine.io-client package brings the engine that is responsible for
managing the low-level connections (HTTP long-polling or WebSocket). See
also: How it works

  socket.io-client version   engine.io-client version   ws version¹
  -------------------------- -------------------------- -------------
  4.8.x                      6.6.x                      8.17.x
  4.7.x                      6.5.x                      8.17.x
  4.6.x                      6.4.x                      8.11.x
  4.5.x                      6.2.x                      8.2.x
  4.4.x                      6.1.x                      8.2.x
  4.3.x                      6.0.x                      8.2.x
  4.2.x                      5.2.x                      7.4.x
  4.1.x                      5.1.x                      7.4.x
  4.0.x                      5.0.x                      7.4.x
  3.1.x                      4.1.x                      7.4.x
  3.0.x                      4.0.x                      7.4.x
  2.5.x                      3.5.x                      7.5.x
  2.4.x                      3.5.x                      7.5.x

[1] for Node.js users only. In the browser, the native WebSocket API is
used.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Usage with bundlers

Next

Initialization

- Version compatibility
- Browser support
- Installation
  - Standalone build
  - From a CDN
  - From NPM
- Miscellaneous
  - Dependency tree
  - Transitive versions

=============

## doc_docs_v4_client-offline-behavior_.txt

- []
- Client
- Offline behavior

Version: 4.x

On this page

Offline behavior

Buffered events​

By default, any event emitted while the Socket is not connected will be
buffered until reconnection.

While useful in most cases (when the reconnection delay is short), it
could result in a huge spike of events when the connection is restored.

There are several solutions to prevent this behavior, depending on your
use case:

- use the connected attribute of the Socket instance

    if (socket.connected) {
      socket.emit( /* ... */ );
    } else {
      // ...
    }

[][]

- use volatile events

    socket.volatile.emit( /* ... */ );

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

The Socket instance

Next

Usage with bundlers

- Buffered events

=============

## doc_docs_v4_client-options_.txt

- []
- Options

Version: 4.x

On this page

Client options

IO factory options​

forceNew​

Default value: false

Whether to create a new Manager instance.

A Manager instance is in charge of the low-level connection to the
server (established with HTTP long-polling or WebSocket). It handles the
reconnection logic.

A Socket instance is the interface which is used to sends events to —
and receive events from — the server. It belongs to a given namespace.

A single Manager can be attached to several Socket instances.

The following example will reuse the same Manager instance for the 3
Socket instances (one single WebSocket connection):

    const socket = io("https://example.com"); // the main namespace
    const productSocket = io("https://example.com/product"); // the "product" namespace
    const orderSocket = io("https://example.com/order"); // the "order" namespace

[][]

The following example will create 3 different Manager instances (and
thus 3 distinct WebSocket connections):

    const socket = io("https://example.com"); // the main namespace
    const productSocket = io("https://example.com/product", { forceNew: true }); // the "product" namespace
    const orderSocket = io("https://example.com/order", { forceNew: true }); // the "order" namespace

[][]

Reusing an existing namespace will also create a new Manager each time:

    const socket1 = io(); // 1st manager
    const socket2 = io(); // 2nd manager
    const socket3 = io("/admin"); // reuse the 1st manager
    const socket4 = io("/admin"); // 3rd manager

[][]

multiplex​

Default value: true

The opposite of forceNew: whether to reuse an existing Manager instance.

    const socket = io(); // 1st manager
    const adminSocket = io("/admin", { multiplex: false }); // 2nd manager

[][]

Low-level engine options​

[]info

These settings will be shared by all Socket instances attached to the
same Manager.

addTrailingSlash​

Added in v4.6.0

The trailing slash which was added by default can now be disabled:

    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      addTrailingSlash: false
    });

[][]

In the example above, the request URL will be
https://example.com/socket.io instead of https://example.com/socket.io/.

autoUnref​

Added in v4.0.0

Default value: false

With autoUnref set to true, the Socket.IO client will allow the program
to exit if there is no other active timer/TCP socket in the event system
(even if the client is connected):

    import { io } from "socket.io-client";

    const socket = io({
      autoUnref: true
    });

[][]

See also: https://nodejs.org/api/timers.html#timeoutunref

closeOnBeforeunload​

History

  Version   Changes
  --------- -----------------------------------
  v4.7.1    The option now defaults to false.
  v4.1.0    First implementation.

Default value: false

Whether to (silently) close the connection when the beforeunload event
is emitted in the browser.

When this option is set to false (the default value), the Socket
instance will emit a disconnect event when the user reloads the page on
Firefox:

[Example with Firefox when closeOnBeforeunload is set to false]

[]note

This behavior is specific to Firefox, on other browsers the Socket
instance will not emit any disconnect event when the user reloads the
page.

When this option is set to true, all browsers will have the same
behavior (no disconnect event when reloading the page):

[Example with Firefox when closeOnBeforeunload is set to true]

[]caution

If you use the beforeunload event in your application ("are you sure
that you want to leave this page?"), it is recommended to leave this
option to false.

Please check this issue for more information.

extraHeaders​

Default value: -

Additional headers (then found in socket.handshake.headers object on the
server-side).

Example:

Client

    import { io } from "socket.io-client";

    const socket = io({
      extraHeaders: {
        "my-custom-header": "1234"
      }
    });

[][]

Server

    io.on("connection", (socket) => {
      console.log(socket.handshake.headers); // an object containing "my-custom-header": "1234"
    });

[][]

[]caution

In a browser environment, the extraHeaders option will be ignored if you
only enable the WebSocket transport, since the WebSocket API in the
browser does not allow providing custom headers.

    import { io } from "socket.io-client";

    const socket = io({
      transports: ["websocket"],
      extraHeaders: {
        "my-custom-header": "1234" // ignored
      }
    });

[][]

This will work in Node.js or in React-Native though.

Documentation: WebSocket API

forceBase64​

Default value: false

Whether to force base64 encoding for binary content sent over WebSocket
(always enabled for HTTP long-polling).

path​

Default value: /socket.io/

It is the name of the path that is captured on the server side.

[]caution

The server and the client values must match (unless you are using a
path-rewriting proxy in between).

Client

    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      path: "/my-custom-path/"
    });

[][]

Server

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      path: "/my-custom-path/"
    });

[][]

Please note that this is different from the path in the URI, which
represents the Namespace.

Example:

    import { io } from "socket.io-client";

    const socket = io("https://example.com/order", {
      path: "/my-custom-path/"
    });

[][]

- the Socket instance is attached to the "order" Namespace
- the HTTP requests will look like:
  GET https://example.com/my-custom-path/?EIO=4&transport=polling&t=ML4jUwU

protocols​

Added in v2.0.0

Default value: -

Either a single protocol string or an array of protocol strings. These
strings are used to indicate sub-protocols, so that a single server can
implement multiple WebSocket sub-protocols (for example, you might want
one server to be able to handle different types of interactions
depending on the specified protocol).

    import { io } from "socket.io-client";

    const socket = io({
      transports: ["websocket"],
      protocols: ["my-protocol-v1"]
    });

[][]

Server:

    io.on("connection", (socket) => {
      const transport = socket.conn.transport;
      console.log(transport.socket.protocol); // prints "my-protocol-v1"
    });

[][]

References:

- https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
- https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket

query​

Default value: -

Additional query parameters (then found in socket.handshake.query object
on the server-side).

Example:

Client

    import { io } from "socket.io-client";

    const socket = io({
      query: {
        x: 42
      }
    });

[][]

Server

    io.on("connection", (socket) => {
      console.log(socket.handshake.query); // prints { x: "42", EIO: "4", transport: "polling" }
    });

[][]

The query parameters cannot be updated for the duration of the session,
so changing the query on the client-side will only be effective when the
current session gets closed and a new one is created:

    socket.io.on("reconnect_attempt", () => {
      socket.io.opts.query.x++;
    });

[][]

Note: the following query parameters are reserved and can't be used in
your application:

- EIO: the version of the protocol (currently, "4")
- transport: the transport name ("polling" or "websocket")
- sid: the session ID
- j: if the transport is polling but a JSONP response is required
- t: a hashed-timestamp used for cache-busting

rememberUpgrade​

Default value: false

If true and if the previous WebSocket connection to the server
succeeded, the connection attempt will bypass the normal upgrade process
and will initially try WebSocket. A connection attempt following a
transport error will use the normal upgrade process. It is recommended
you turn this on only when using SSL/TLS connections, or if you know
that your network does not block websockets.

timestampParam​

Default value: "t"

The name of the query parameter to use as our timestamp key.

timestampRequests​

Default value: true

Whether to add the timestamp query param to each request (for cache
busting).

transportOptions​

Added in v2.0.0

Default value: {}

Transport-specific options.

Example:

    import { io } from "socket.io-client";

    const socket = io({
      path: "/path-for-http-long-polling/",
      transportOptions: {
        websocket: {
          path: "/path-for-websocket/"
        }
      }
    });

[][]

transports​

History

  Version   Changes
  --------- ---------------------------------------------------------
  v4.8.0    You can now pass an array of transport implementations.
  v4.7.0    webtransport is added.
  v1.0.0    First implementation.

Default value: ["polling", "websocket", "webtransport"]

The low-level connection to the Socket.IO server can either be
established with:

- HTTP long-polling: successive HTTP requests (POST for writing, GET for
  reading)
- WebSocket
- WebTransport

The following example disables the HTTP long-polling transport:

    const socket = io("https://example.com", { transports: ["websocket"] });

[][]

Note: in that case, sticky sessions are not required on the server side
(more information here).

By default, the HTTP long-polling connection is established first, and
then an upgrade to WebSocket is attempted (explanation here). You can
use WebSocket first with:

    const socket = io("https://example.com", {
      transports: ["websocket", "polling"] // use WebSocket first, if available
    });

    socket.on("connect_error", () => {
      // revert to classic upgrade
      socket.io.opts.transports = ["polling", "websocket"];
    });

[][]

One possible downside is that the validity of your CORS configuration
will only be checked if the WebSocket connection fails to be
established.

You can also pass an array of transport implementations:

    import { io } from "socket.io-client";
    import { Fetch, WebSocket } from "engine.io-client";

    const socket = io({
      transports: [Fetch, WebSocket]
    });

[][]

Here is the list of provided implementations:

  Transport       Description
  --------------- --------------------------------------------------------------------------------------------------
  Fetch           HTTP long-polling based on the built-in fetch() method.
  NodeXHR         HTTP long-polling based on the XMLHttpRequest object provided by the xmlhttprequest-ssl package.
  XHR             HTTP long-polling based on the built-in XMLHttpRequest object.
  NodeWebSocket   WebSocket transport based on the WebSocket object provided by the ws package.
  WebSocket       WebSocket transport based on the built-in WebSocket object.
  WebTransport    WebTransport transport based on the built-in WebTransport object.

Usage:

  Transport       browser   Node.js   Deno   Bun
  --------------- --------- --------- ------ -----
  Fetch           ✅        ✅ (1)    ✅     ✅
  NodeXHR                   ✅        ✅     ✅
  XHR             ✅                         
  NodeWebSocket             ✅        ✅     ✅
  WebSocket       ✅        ✅ (2)    ✅     ✅
  WebTransport    ✅        ✅               

(1) since v18.0.0 (2) since v21.0.0

tryAllTransports​

Added in v4.8.0

Default value: false

When setting the tryAllTransports option to true, if the first transport
(usually, HTTP long-polling) fails, then the other transports will be
tested too:

    import { io } from "socket.io-client";

    const socket = io({
      tryAllTransports: true
    });

[][]

This feature is useful in two cases:

- when HTTP long-polling is disabled on the server, or if CORS fails
- when WebSocket is tested first (with
  transports: ["websocket", "polling"])

The only potential downside is that the connection attempt could take
more time in case of failure, as there have been reports of WebSocket
connection errors taking several seconds before being detected (that's
one reason for using HTTP long-polling first). That's why the option
defaults to false for now.

upgrade​

Default value: true

Whether the client should try to upgrade the transport from HTTP
long-polling to something better.

withCredentials​

History

  Version   Changes
  --------- ------------------------------------------------------------
  v4.7.0    The Node.js client now honors the withCredentials setting.
  v3.0.0    withCredentials now defaults to false.
  v1.0.0    First implementation.

Default value: false

Whether the cross-site requests should be sent including credentials
such as cookies, authorization headers or TLS client certificates.
Setting withCredentials has no effect on same-site requests.

    import { io } from "socket.io-client";

    const socket = io("https://my-backend.com", {
      withCredentials: true
    });

[][]

The server needs to send the right Access-Control-Allow-*  headers to
allow the connection:

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      cors: {
        origin: "https://my-frontend.com",
        credentials: true
      }
    });

[][]

[]caution

You cannot use origin: * when setting withCredentials to true. This will
trigger the following error:

  Cross-Origin Request Blocked: The Same Origin Policy disallows reading
  the remote resource at
  ‘.../socket.io/?EIO=4&transport=polling&t=NvQfU77’. (Reason:
  Credential is not supported if the CORS header
  ‘Access-Control-Allow-Origin’ is ‘*’)

Documentation:

- XMLHttpRequest.withCredentials
- Handling CORS

[]info

Starting with version 4.7.0, when setting the withCredentials option to
true, the Node.js client will now include the cookies in the HTTP
requests, making it easier to use it with cookie-based sticky sessions.

Node.js-specific options​

The following options are supported:

- agent
- pfx
- key
- passphrase
- cert
- ca
- ciphers
- rejectUnauthorized

Please refer to the Node.js documentation:

- tls.connect(options[, callback])
- tls.createSecureContext([options])

Example with a self-signed certificate:

Client

    import { readFileSync } from "fs";
    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      ca: readFileSync("./cert.pem")
    });

[][]

Server

    import { readFileSync } from "fs";
    import { createServer } from "https";
    import { Server } from "socket.io";

    const httpServer = createServer({
      cert: readFileSync("./cert.pem"),
      key: readFileSync("./key.pem")
    });
    const io = new Server(httpServer);

[][]

Example with client-certificate authentication:

Client

    import { readFileSync } from "fs";
    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      ca: readFileSync("./server-cert.pem"),
      cert: readFileSync("./client-cert.pem"),
      key: readFileSync("./client-key.pem"),
    });

[][]

Server

    import { readFileSync } from "fs";
    import { createServer } from "https";
    import { Server } from "socket.io";

    const httpServer = createServer({
      cert: readFileSync("./server-cert.pem"),
      key: readFileSync("./server-key.pem"),
      requestCert: true,
      ca: [
        readFileSync("client-cert.pem")
      ]
    });
    const io = new Server(httpServer);

[][]

[]caution

rejectUnauthorized is a Node.js-only option, it will not bypass the
security check in the browser:

[Security warning in the browser]

Manager options​

[]info

These settings will be shared by all Socket instances attached to the
same Manager.

autoConnect​

Default value: true

Whether to automatically connect upon creation. If set to false, you
need to manually connect:

    import { io } from "socket.io-client";

    const socket = io({
      autoConnect: false
    });

    socket.connect();
    // or
    socket.io.open();

[][]

parser​

Added in v2.2.0

Default value: require("socket.io-parser")

The parser used to marshall/unmarshall packets. Please see here for more
information.

randomizationFactor​

Default value: 0.5

The randomization factor used when reconnecting (so that the clients do
not reconnect at the exact same time after a server crash, for example).

Example with the default values:

- 1st reconnection attempt happens between 500 and 1500 ms
  (1000 * 2^0 * (<something between -0.5 and 1.5>))
- 2nd reconnection attempt happens between 1000 and 3000 ms
  (1000 * 2^1 * (<something between -0.5 and 1.5>))
- 3rd reconnection attempt happens between 2000 and 5000 ms
  (1000 * 2^2 * (<something between -0.5 and 1.5>))
- next reconnection attempts happen after 5000 ms

reconnection​

Default value: true

Whether reconnection is enabled or not. If set to false, you need to
manually reconnect:

    import { io } from "socket.io-client";

    const socket = io({
      reconnection: false
    });

    const tryReconnect = () => {
      setTimeout(() => {
        socket.io.open((err) => {
          if (err) {
            tryReconnect();
          }
        });
      }, 2000);
    }

    socket.io.on("close", tryReconnect);

[][]

reconnectionAttempts​

Default value: Infinity

The number of reconnection attempts before giving up.

reconnectionDelay​

Default value: 1000

The initial delay before reconnection in milliseconds (affected by the
randomizationFactor value).

reconnectionDelayMax​

Default value: 5000

The maximum delay between two reconnection attempts. Each attempt
increases the reconnection delay by 2x.

timeout​

Default value: 20000

The timeout in milliseconds for each connection attempt.

Socket options​

[]info

These settings are specific to the given Socket instance.

ackTimeout​

Added in v4.6.0

Default value: -

The default timeout in milliseconds used when waiting for an
acknowledgement (not to be mixed up with the already existing timeout
option, which is used by the Manager during the connection).

Must be used in conjunction with retries.

auth​

Added in v3.0.0

Default value: -

Credentials that are sent when accessing a namespace (see also here).

Example:

Client

    import { io } from "socket.io-client";

    const socket = io({
      auth: {
        token: "abcd"
      }
    });

    // or with a function
    const socket = io({
      auth: (cb) => {
        cb({ token: localStorage.token })
      }
    });

[][]

Server

    io.on("connection", (socket) => {
      console.log(socket.handshake.auth); // prints { token: "abcd" }
    });

[][]

You can update the auth map when the access to the Namespace is denied:

    socket.on("connect_error", (err) => {
      if (err.message === "invalid credentials") {
        socket.auth.token = "efgh";
        socket.connect();
      }
    });

[][]

Or manually force the Socket instance to reconnect:

    socket.auth.token = "efgh";
    socket.disconnect().connect();

[][]

retries​

Added in v4.6.0

Default value: -

The maximum number of retries. Above the limit, the packet will be
discarded.

    const socket = io({
      retries: 3,
      ackTimeout: 10000
    });

    // implicit ack
    socket.emit("my-event");

    // explicit ack
    socket.emit("my-event", (err, val) => { /* ... */ });

    // custom timeout (in that case the ackTimeout is optional)
    socket.timeout(5000).emit("my-event", (err, val) => { /* ... */ });

[][]

[]caution

The event must be acknowledged by the server (even with implicit ack):

    io.on("connection", (socket) => {
      socket.on("my-event", (cb) => {
        cb("got it");
      });
    });

[][]

Else, the client will keep trying to send the event (up to retries + 1
times).

[]Edit this page

Last updated on Mar 28, 2025

Previous

API

- IO factory options
  - forceNew
  - multiplex
- Low-level engine options
  - addTrailingSlash
  - autoUnref
  - closeOnBeforeunload
  - extraHeaders
  - forceBase64
  - path
  - protocols
  - query
  - rememberUpgrade
  - timestampParam
  - timestampRequests
  - transportOptions
  - transports
  - tryAllTransports
  - upgrade
  - withCredentials
  - Node.js-specific options
- Manager options
  - autoConnect
  - parser
  - randomizationFactor
  - reconnection
  - reconnectionAttempts
  - reconnectionDelay
  - reconnectionDelayMax
  - timeout
- Socket options
  - ackTimeout
  - auth
  - retries

=============

## doc_docs_v4_client-socket-instance_.txt

- []
- Client
- The Socket instance

Version: 4.x

On this page

The Socket instance (client-side)

A Socket is the fundamental class for interacting with the server. It
inherits most of the methods of the Node.js EventEmitter, like emit, on,
once or off.

[Bidirectional communication between server and client][Bidirectional
communication between server and client]

Besides emitting and listening to events, the Socket instance has a few
attributes that may be of use in your application:

Socket#id​

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the server-side.

    // server-side
    io.on("connection", (socket) => {
      console.log(socket.id); // x8WIv7-mJelg7on_ALbx
    });

    // client-side
    socket.on("connect", () => {
      console.log(socket.id); // x8WIv7-mJelg7on_ALbx
    });

    socket.on("disconnect", () => {
      console.log(socket.id); // undefined
    });

[][]

[]caution

Please note that, unless connection state recovery is enabled, the id
attribute is an ephemeral ID that is not meant to be used in your
application (or only for debugging purposes) because:

- this ID is regenerated after each reconnection (for example when the
  WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if
  the client is disconnected, the messages sent from the server to this
  ID are lost)

Please use a regular session ID instead (either sent in a cookie, or
stored in the localStorage and sent in the auth payload).

See also:

- Part II of our private message guide
- How to deal with cookies

Socket#connected​

This attribute describes whether the socket is currently connected to
the server.

    socket.on("connect", () => {
      console.log(socket.connected); // true
    });

    socket.on("disconnect", () => {
      console.log(socket.connected); // false
    });

[][]

Socket#io​

A reference to the underlying Manager.

    socket.on("connect", () => {
      const engine = socket.io.engine;
      console.log(engine.transport.name); // in most cases, prints "polling"

      engine.once("upgrade", () => {
        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)
        console.log(engine.transport.name); // in most cases, prints "websocket"
      });

      engine.on("packet", ({ type, data }) => {
        // called for each packet received
      });

      engine.on("packetCreate", ({ type, data }) => {
        // called for each packet sent
      });

      engine.on("drain", () => {
        // called when the write buffer is drained
      });

      engine.on("close", (reason) => {
        // called when the underlying connection is closed
      });
    });

[][]

Lifecycle​

[Lifecycle diagram][Lifecycle diagram]

Events​

The Socket instance emits three special events:

- connect
- connect_error
- disconnect

[]tip

Since Socket.IO v3, the Socket instance does not emit any event related
to the reconnection logic anymore. You can listen to the events on the
Manager instance directly:

    socket.io.on("reconnect_attempt", () => {
      // ...
    });

    socket.io.on("reconnect", () => {
      // ...
    });

[][]

More information can be found in the migration guide.

connect​

This event is fired by the Socket instance upon connection and
reconnection.

    socket.on("connect", () => {
      // ...
    });

[][]

[]caution

Event handlers shouldn't be registered in the connect handler itself, as
a new handler will be registered every time the socket instance
reconnects:

BAD ⚠️

    socket.on("connect", () => {
      socket.on("data", () => { /* ... */ });
    });

[][]

GOOD 👍

    socket.on("connect", () => {
      // ...
    });

    socket.on("data", () => { /* ... */ });

[][]

connect_error​

- error <Error>

This event is fired upon connection failure.

  Reason                                                               Automatic reconnection?
  -------------------------------------------------------------------- -------------------------
  The low-level connection cannot be established (temporary failure)   ✅ YES
  The connection was denied by the server in a middleware function     ❌ NO

The socket.active attribute indicates whether the socket will
automatically try to reconnect after a small randomized delay:

    socket.on("connect_error", (error) => {
      if (socket.active) {
        // temporary failure, the socket will automatically try to reconnect
      } else {
        // the connection was denied by the server
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(error.message);
      }
    });

[][]

disconnect​

- reason <string>
- details <DisconnectDetails>

This event is fired upon disconnection.

    socket.on("disconnect", (reason, details) => {
      // ...
    });

[][]

Here is the list of possible reasons:

  Reason                 Description                                                                                                     Automatic reconnection?
  ---------------------- --------------------------------------------------------------------------------------------------------------- -------------------------
  io server disconnect   The server has forcefully disconnected the socket with socket.disconnect()                                      ❌ NO
  io client disconnect   The socket was manually disconnected using socket.disconnect()                                                  ❌ NO
  ping timeout           The server did not send a PING within the pingInterval + pingTimeout range                                      ✅ YES
  transport close        The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G)   ✅ YES
  transport error        The connection has encountered an error (example: the server was killed during a HTTP long-polling cycle)       ✅ YES

The socket.active attribute indicates whether the socket will
automatically try to reconnect after a small randomized delay:

    socket.on("disconnect", (reason) => {
      if (socket.active) {
        // temporary disconnection, the socket will automatically try to reconnect
      } else {
        // the connection was forcefully closed by the server or the client itself
        // in that case, `socket.connect()` must be manually called in order to reconnect
        console.log(reason);
      }
    });

[][]

[]caution

The following event names are reserved and must not be used in your
application:

- connect
- connect_error
- disconnect
- disconnecting
- newListener
- removeListener

    // BAD, will throw an error
    socket.emit("disconnect");

[][]

Complete API​

The complete API exposed by the Socket instance can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Initialization

Next

Offline behavior

- Socket#id
- Socket#connected
- Socket#io
- Lifecycle
- Events
  - connect
  - connect_error
  - disconnect
- Complete API

=============

## doc_docs_v4_client-with-bundlers_.txt

- []
- Client
- Usage with bundlers

Version: 4.x

On this page

Client usage with bundlers

You will find below the configuration for bundling the client library
with different bundlers:

- Webpack 5
  - Browser
  - Node.js
- Rollup.js
  - Browser
  - Node.js

Webpack 5​

Documentation: https://webpack.js.org/concepts/

Browser​

Installation:

    npm i -D socket.io-client webpack webpack-cli babel-loader @babel/core @babel/preset-env \
        @babel/plugin-transform-object-assign webpack-remove-debug

[][]

webpack.config.js

    module.exports = {
      entry: "./index.js",
      output: {
        filename: "bundle.js",
      },
      mode: "production",
      node: false,
      module: {
        rules: [
          {
            test: /\.m?js$/,
            use: {
              loader: "babel-loader",
              options: {
                presets: ["@babel/preset-env"], // ensure compatibility with older browsers
                plugins: ["@babel/plugin-transform-object-assign"], // ensure compatibility with IE 11
              },
            },
          },
          {
            test: /\.js$/,
            loader: "webpack-remove-debug", // remove "debug" package
          },
        ],
      },
    };

[][]

For reference, here is the output of the webpack-bundle-analyzer
package:

[Output of the webpack-bundle-analyzer package]

Node.js​

To use the client in a Node.js environment (server to server
connection), here is the configuration:

Installation:

    npm i -D socket.io-client webpack webpack-cli

[][]

webpack.config.js

    module.exports = {
      entry: "./index.js",
      output: {
        filename: "bundle.js",
      },
      mode: "production",
      target: "node",
      externals: {
        bufferutil: "bufferutil",
        "utf-8-validate": "utf-8-validate",
      },
    };

[][]

Note: without setting target: "node", you will likely encounter the
following error:

    ReferenceError: document is not defined

[][]

Rollup.js​

Documentation: https://rollupjs.org/guide/en/

Browser​

Installation:

    npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-commonjs \
      @rollup/plugin-babel rollup-plugin-uglify babel @babel/core @babel/preset-env

[][]

rollup.config.js

    import resolve from "@rollup/plugin-node-resolve";
    import commonjs from "@rollup/plugin-commonjs";
    import babel from "@rollup/plugin-babel";
    import { uglify } from "rollup-plugin-uglify";

    export default {
      input: "index.js",
      output: {
        file: "bundle.js",
        format: "cjs",
      },
      plugins: [
        resolve({
          browser: true,
        }),
        commonjs(),
        babel({
          include: ["**.js", "node_modules/**"],
          babelHelpers: "bundled",
          presets: ["@babel/preset-env"],
        }),
        uglify(),
      ],
    };

[][]

Node.js​

Installation:

    npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs rollup-plugin-uglify

[][]

rollup.config.js

    import resolve from "@rollup/plugin-node-resolve";
    import commonjs from "@rollup/plugin-commonjs";
    import { uglify } from "rollup-plugin-uglify";

    export default {
      input: "index.js",
      output: {
        file: "bundle.js",
        format: "cjs",
      },
      plugins: [
        resolve({
          preferBuiltins: true,
        }),
        commonjs(),
        uglify(),
      ],
    };

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Offline behavior

Next

Emitting events

- Webpack 5
  - Browser
  - Node.js
- Rollup.js
  - Browser
  - Node.js

=============

## doc_docs_v4_connection-state-recovery.txt

- []
- Documentation
- Connection state recovery

Version: 4.x

On this page

Connection state recovery

Connection state recovery is a feature which allows restoring a client's
state after a temporary disconnection, including any missed packets.

[]info

This feature was added in version 4.6.0, released in February 2023.

The release notes can be found here.

Disclaimer​

Under real conditions, a Socket.IO client will inevitably experience
temporary disconnections, regardless of the quality of the connection.

This feature will help you cope with such disconnections, but unless you
want to store the packets and the sessions forever (by setting
maxDisconnectionDuration to Infinity), you can't be assured that the
recovery will always be successful.

That's why you will still need to handle the case where the states of
the client and the server must be synchronized.

Usage​

Connection state recovery must be enabled by the server:

    const io = new Server(httpServer, {
      connectionStateRecovery: {
        // the backup duration of the sessions and the packets
        maxDisconnectionDuration: 2 * 60 * 1000,
        // whether to skip middlewares upon successful recovery
        skipMiddlewares: true,
      }
    });

[][]

Upon an unexpected disconnection (i.e. no manual disconnection with
socket.disconnect()), the server will store the id, the rooms and the
data attribute of the socket.

Then upon reconnection, the server will try to restore the state of the
client. The recovered attribute indicates whether this recovery was
successful:

Server

    io.on("connection", (socket) => {
      if (socket.recovered) {
        // recovery was successful: socket.id, socket.rooms and socket.data were restored
      } else {
        // new or unrecoverable session
      }
    });

[][]

Client

    socket.on("connect", () => {
      if (socket.recovered) {
        // any event missed during the disconnection period will be received now
      } else {
        // new or unrecoverable session
      }
    });

[][]

You can check that the recovery is working by forcefully closing the
underlying engine:

    import { io } from "socket.io-client";

    const socket = io({
      reconnectionDelay: 10000, // defaults to 1000
      reconnectionDelayMax: 10000 // defaults to 5000
    });

    socket.on("connect", () => {
      console.log("recovered?", socket.recovered);

      setTimeout(() => {
        if (socket.io.engine) {
          // close the low-level connection and trigger a reconnection
          socket.io.engine.close();
        }
      }, 10000);
    });

[][]

[]tip

You can also run this example directly in your browser on:

- CodeSandbox
- StackBlitz

Compatibility with existing adapters​

  Adapter                                   Support?
  ------------------------------ ------------------------------
  Built-in adapter (in memory)               YES ✅
  Redis adapter                               NO¹
  Redis Streams adapter                      YES ✅
  MongoDB adapter                 YES ✅ (since version 0.3.0)
  Postgres adapter                            WIP
  Cluster adapter                             WIP

[1] Persisting the packets is not compatible with the Redis PUB/SUB
mechanism.

How it works under the hood​

- the server sends a session ID during the handshake (which is different
  from the current id attribute, which is public and can be freely
  shared)

Example:

    40{"sid":"GNpWD7LbGCBNCr8GAAAB","pid":"YHcX2sdAF1z452-HAAAW"}

    where

    4         => the Engine.IO message type
    0         => the Socket.IO CONNECT type
    GN...AB   => the public id of the session
    YH...AW   => the private id of the session

[][]

- the server also includes an offset in each packet (added at the end of
  the data array, for backward compatibility)

Example:

    42["foo","MzUPkW0"]

    where

    4         => the Engine.IO message type
    2         => the Socket.IO EVENT type
    foo       => the event name (socket.emit("foo"))
    MzUPkW0   => the offset

[][]

[]note

For the recovery to succeed, the server must send at least one event, in
order to initialize the offset on the client side.

- upon temporary disconnection, the server stores the client state for a
  given delay (implemented at the adapter level)

- upon reconnection, the client sends both the session ID and the last
  offset it has processed, and the server tries to restore the state

Example:

    40{"pid":"YHcX2sdAF1z452-HAAAW","offset":"MzUPkW0"}

    where

    4         => the Engine.IO message type
    0         => the Socket.IO CONNECT type
    YH...AW   => the private id of the session
    MzUPkW0   => the last processed offset

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Delivery guarantees

Next

Logging and debugging

- Disclaimer
- Usage
- Compatibility with existing adapters
- How it works under the hood

=============

## doc_docs_v4_custom-parser_.txt

- []
- Advanced
- Custom parser

Version: 4.x

On this page

Custom parser

Since Socket.IO v2.0.0, it is now possible to provide your own parser,
in order to control the marshalling / unmarshalling of packets.

Server

    import { Server } from "socket.io";

    const io = new Server({
      parser: myParser
    });

[][]

Client

    import { io } from "socket.io-client";

    const socket = io({
      parser: myParser
    });

[][]

Available parsers​

Besides the default parser, here is the list of available parsers:

  Package                                Description
  -------------------------------------- ---------------------------------------------------------------------------------
  socket.io-circular-parser              Similar to the default parser, but handles circular references.
  socket.io-msgpack-parser               Uses MessagePack to encode the packets (based on the notepack.io package).
  @skgdev/socket.io-msgpack-javascript   Uses MessagePack to encode the packets (based on the @msgpack/msgpack package).
  socket.io-json-parser                  Uses JSON.stringify() and JSON.parse() to encode the packets.
  socket.io-cbor-x-parser                Uses cbor-x to encode the packets.
  @socket.io/devalue-parser              Uses devalue to encode the packets.

Implementing your own parser​

Here is a basic example with a parser that uses the JSON.stringify() and
JSON.parse() methods:

    import { Emitter } from "@socket.io/component-emitter"; // polyfill of Node.js EventEmitter in the browser

    class Encoder {
      /**
       * Encode a packet into a list of strings/buffers
       */
      encode(packet) {
        return [JSON.stringify(packet)];
      }
    }

    function isObject(value) {
      return Object.prototype.toString.call(value) === "[object Object]";
    }

    class Decoder extends Emitter {
      /**
       * Receive a chunk (string or buffer) and optionally emit a "decoded" event with the reconstructed packet
       */
      add(chunk) {
        const packet = JSON.parse(chunk);
        if (this.isPacketValid(packet)) {
          this.emit("decoded", packet);
        } else {
          throw new Error("invalid format");
        }
      }
      isPacketValid({ type, data, nsp, id }) {
        const isNamespaceValid = typeof nsp === "string";
        const isAckIdValid = id === undefined || Number.isInteger(id);
        if (!isNamespaceValid || !isAckIdValid) {
          return false;
        }
        switch (type) {
          case 0: // CONNECT
            return data === undefined || isObject(data);
          case 1: // DISCONNECT
            return data === undefined;
          case 2: // EVENT
            return Array.isArray(data) && typeof data[0] === "string";
          case 3: // ACK
            return Array.isArray(data);
          case 4: // CONNECT_ERROR
            return isObject(data);
          default:
            return false;
        }
      }
      /**
       * Clean up internal buffers
       */
      destroy() {}
    }

    export const parser = { Encoder, Decoder };

[][]

The default parser​

The source code of the default parser (the socket.io-parser package) can
be found here: https://github.com/socketio/socket.io-parser

Example of output:

- basic emit

    socket.emit("test", 42);

[][]

will be encoded as:

    2["test",42]
    ||
    |└─ JSON-encoded payload
    └─ packet type (2 => EVENT)

[][]

- emit with binary, acknowledgement and custom namespace

    socket.emit("test", Uint8Array.from([42]), () => {
      console.log("ack received");
    });

[][]

will be encoded as:

    51-/admin,13["test",{"_placeholder":true,"num":0}]
    ||||     || └─ JSON-encoded payload with placeholders for binary attachments
    ||||     |└─ acknowledgement id
    ||||     └─ separator
    |||└─ namespace (not included when it's the main namespace)
    ||└─ separator
    |└─ number of binary attachments
    └─ packet type (5 => BINARY EVENT)

    and an additional attachment (the extracted Uint8Array)

[][]

Pros:

- the binary attachments is then base64-encoded, so this parser is
  compatible with browsers that do not support Arraybuffers, like IE9

Cons:

- packets with binary content are sent as two distinct WebSocket frames
  (if the WebSocket connection is established)

The msgpack parser​

This parser uses the MessagePack serialization format.

The source code of this parser can be found here:
https://github.com/socketio/socket.io-msgpack-parser

Sample usage:

Server

    import { Server } from "socket.io";
    import customParser from "socket.io-msgpack-parser";

    const io = new Server({
      parser: customParser
    });

[][]

Client (Node.js)

    import { io } from "socket.io-client";
    import customParser from "socket.io-msgpack-parser";

    const socket = io("https://example.com", {
      parser: customParser
    });

[][]

In the browser, there is now an official bundle which includes this
parser:

- https://cdn.socket.io/4.8.1/socket.io.msgpack.min.js
- cdnjs:
  https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.msgpack.min.js
- jsDelivr:
  https://cdn.jsdelivr.net/npm/socket.io-client@4.8.1/dist/socket.io.msgpack.min.js
- unpkg:
  https://unpkg.com/socket.io-client@4.8.1/dist/socket.io.msgpack.min.js

In that case, you don't need to specify the parser option.

Pros:

- packets with binary content are sent as one single WebSocket frame (if
  the WebSocket connection is established)
- may result in smaller payloads (especially when using a lot of
  numbers)

Cons:

- incompatible with browsers that do not support Arraybuffers, like IE9
- harder to debug in the Network tab of the browser

[]info

Please note that socket.io-msgpack-parser relies on the notepack.io
MessagePack implementation. This implementation mainly focuses on
performance and minimal bundle size, and thus does not support features
like extension types. For a parser based on the official JavaScript
implementation, please check this package.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Namespaces

Next

Admin UI

- Available parsers
- Implementing your own parser
- The default parser
- The msgpack parser

=============

## doc_docs_v4_delivery-guarantees.txt

- []
- Documentation
- Delivery guarantees

Version: 4.x

On this page

Delivery guarantees

Message ordering​

Socket.IO does guarantee message ordering, no matter which low-level
transport is used (even during an upgrade from HTTP long-polling to
WebSocket).

This is achieved thanks to:

- the guarantees provided by the underlying TCP connection
- the careful design of the upgrade mechanism

Example:

    socket.emit("event1");
    socket.emit("event2");
    socket.emit("event3");

[][]

In the example above, the events will always be received in the same
order by the other side (provided that they actually arrive, see below).

Message arrival​

At most once​

By default, Socket.IO provides an at most once guarantee of delivery:

- if the connection is broken while an event is being sent, then there
  is no guarantee that the other side has received it and there will be
  no retry upon reconnection
- a disconnected client will buffer events until reconnection (though
  the previous point still applies)
- there is no such buffer on the server, which means that any event that
  was missed by a disconnected client will not be transmitted to that
  client upon reconnection

[]info

As of now, additional delivery guarantees must be implemented in your
application.

At least once​

From client to server​

From the client side, you can achieve an at least once guarantee with
the retries option:

    const socket = io({
      retries: 3,
      ackTimeout: 10000
    });

[][]

The client will try to send the event (up to retries + 1 times), until
it gets an acknowledgement from the server.

[]caution

Even in that case, any pending event will be lost if the user refreshes
its tab.

From server to client​

For events sent by the server, additional delivery guarantees can be
implemented by:

- assigning a unique ID to each event
- persisting the events in a database
- storing the offset of the last received event on the client side, and
  send it upon reconnection

Example:

Client

    const socket = io({
      auth: {
        offset: undefined
      }
    });

    socket.on("my-event", ({ id, data }) => {
      // do something with the data, and then update the offset
      socket.auth.offset = id;
    });

[][]

Server

    io.on("connection", async (socket) => {
      const offset = socket.handshake.auth.offset;
      if (offset) {
        // this is a reconnection
        for (const event of await fetchMissedEventsFromDatabase(offset)) {
          socket.emit("my-event", event);
        }
      } else {
        // this is a first connection
      }
    });

    setInterval(async () => {
      const event = {
        id: generateUniqueId(),
        data: new Date().toISOString()
      }

      await persistEventToDatabase(event);
      io.emit("my-event", event);
    }, 1000);

[][]

Implementing the missing methods (fetchMissedEventsFromDatabase(),
generateUniqueId() and persistEventToDatabase()) is database-specific
and is left as an exercise for the reader.

References:

- socket.auth (client)
- socket.handshake (server)

[]Edit this page

Last updated on Mar 28, 2025

Previous

How it works

Next

Connection state recovery

- Message ordering
- Message arrival
  - At most once
  - At least once
    - From client to server
    - From server to client

=============

## doc_docs_v4_emitting-events_.txt

- []
- Events
- Emitting events

Version: 4.x

On this page

Emitting events

There are several ways to send events between the server and the client.

[]tip

For TypeScript users, it is possible to provide type hints for the
events. Please check this.

Basic emit​

The Socket.IO API is inspired from the Node.js EventEmitter, which means
you can emit events on one side and register listeners on the other:

Server

    io.on("connection", (socket) => {
      socket.emit("hello", "world");
    });

[][]

Client

    socket.on("hello", (arg) => {
      console.log(arg); // world
    });

[][]

This also works in the other direction:

Server

    io.on("connection", (socket) => {
      socket.on("hello", (arg) => {
        console.log(arg); // world
      });
    });

[][]

Client

    socket.emit("hello", "world");

[][]

You can send any number of arguments, and all serializable data
structures are supported, including binary objects like Buffer or
TypedArray.

Server

    io.on("connection", (socket) => {
      socket.emit("hello", 1, "2", { 3: '4', 5: Buffer.from([6]) });
    });

[][]

Client

    // client-side
    socket.on("hello", (arg1, arg2, arg3) => {
      console.log(arg1); // 1
      console.log(arg2); // "2"
      console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }
    });

[][]

There is no need to run JSON.stringify() on objects as it will be done
for you.

    // BAD
    socket.emit("hello", JSON.stringify({ name: "John" }));

    // GOOD
    socket.emit("hello", { name: "John" });

[][]

Notes:

- Date objects will be converted to (and received as) their string
  representation, e.g. 1970-01-01T00:00:00.000Z

- Map and Set must be manually serialized:

    const serializedMap = [...myMap.entries()];
    const serializedSet = [...mySet.keys()];

[][]

- you can use the toJSON() method to customize the serialization of an
  object

Example with a class:

    class Hero {
      #hp;

      constructor() {
        this.#hp = 42;
      }

      toJSON() {
        return { hp: this.#hp };
      }
    }

    socket.emit("here's a hero", new Hero());

[][]

Acknowledgements​

Events are great, but in some cases you may want a more classic
request-response API. In Socket.IO, this feature is named
acknowledgements.

You can add a callback as the last argument of the emit(), and this
callback will be called once the other side acknowledges the event:

Server

    io.on("connection", (socket) => {
      socket.on("update item", (arg1, arg2, callback) => {
        console.log(arg1); // 1
        console.log(arg2); // { name: "updated" }
        callback({
          status: "ok"
        });
      });
    });

[][]

Client

    socket.emit("update item", "1", { name: "updated" }, (response) => {
      console.log(response.status); // ok
    });

[][]

With timeout​

Starting with Socket.IO v4.4.0, you can now assign a timeout to each
emit:

    socket.timeout(5000).emit("my-event", (err) => {
      if (err) {
        // the other side did not acknowledge the event in the given delay
      }
    });

[][]

You can also use both a timeout and an acknowledgement:

    socket.timeout(5000).emit("my-event", (err, response) => {
      if (err) {
        // the other side did not acknowledge the event in the given delay
      } else {
        console.log(response);
      }
    });

[][]

Volatile events​

Volatile events are events that will not be sent if the underlying
connection is not ready (a bit like UDP, in terms of reliability).

This can be interesting for example if you need to send the position of
the characters in an online game (as only the latest values are useful).

    socket.volatile.emit("hello", "might or might not be received");

[][]

Another use case is to discard events when the client is not connected
(by default, the events are buffered until reconnection).

Example:

Server

    io.on("connection", (socket) => {
      console.log("connect");

      socket.on("ping", (count) => {
        console.log(count);
      });
    });

[][]

Client

    let count = 0;
    setInterval(() => {
      socket.volatile.emit("ping", ++count);
    }, 1000);

[][]

If you restart the server, you will see in the console:

    connect
    1
    2
    3
    4
    # the server is restarted, the client automatically reconnects
    connect
    9
    10
    11

[][]

Without the volatile flag, you would see:

    connect
    1
    2
    3
    4
    # the server is restarted, the client automatically reconnects and sends its buffered events
    connect
    5
    6
    7
    8
    9
    10
    11

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Usage with bundlers

Next

Listening to events

- Basic emit
- Acknowledgements
- With timeout
- Volatile events

=============

## doc_docs_v4_engine-io-protocol_.txt

- []
- Miscellaneous
- The Engine.IO protocol

Version: 4.x

On this page

The Engine.IO protocol

This document describes the 4th version of the Engine.IO protocol.

The source of this document can be found here.

Table of content

- Introduction
- Transports
  - HTTP long-polling
    - Request path
    - Query parameters
    - Headers
    - Sending and receiving data
      - Sending data
      - Receiving data
  - WebSocket
- Protocol
  - Handshake
  - Heartbeat
  - Upgrade
  - Message
- Packet encoding
  - HTTP long-polling
  - WebSocket
- History
  - From v2 to v3
  - From v3 to v4
- Test suite

Introduction​

The Engine.IO protocol enables full-duplex and low-overhead
communication between a client and a server.

It is based on the WebSocket protocol and uses HTTP long-polling as
fallback if the WebSocket connection can't be established.

The reference implementation is written in TypeScript:

- server: https://github.com/socketio/engine.io
- client: https://github.com/socketio/engine.io-client

The Socket.IO protocol is built on top of these foundations, bringing
additional features over the communication channel provided by the
Engine.IO protocol.

Transports​

The connection between an Engine.IO client and an Engine.IO server can
be established with:

- HTTP long-polling
- WebSocket

HTTP long-polling​

The HTTP long-polling transport (also simply referred as "polling")
consists of successive HTTP requests:

- long-running GET requests, for receiving data from the server
- short-running POST requests, for sending data to the server

Request path​

The path of the HTTP requests is /engine.io/ by default.

It might be updated by libraries built on top of the protocol (for
example, the Socket.IO protocol uses /socket.io/).

Query parameters​

The following query parameters are used:

  Name        Value     Description
  ----------- --------- --------------------------------------------------------------------
  EIO         4         Mandatory, the version of the protocol.
  transport   polling   Mandatory, the name of the transport.
  sid         <sid>     Mandatory once the session is established, the session identifier.

If a mandatory query parameter is missing, then the server MUST respond
with an HTTP 400 error status.

Headers​

When sending binary data, the sender (client or server) MUST include a
Content-Type: application/octet-stream header.

Without an explicit Content-Type header, the receiver SHOULD infer that
the data is plaintext.

Reference:
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type

Sending and receiving data​

Sending data​

To send some packets, a client MUST create an HTTP POST request with the
packets encoded in the request body:

    CLIENT                                                 SERVER

      │                                                      │
      │   POST /engine.io/?EIO=4&transport=polling&sid=...   │
      │ ───────────────────────────────────────────────────► │
      │ ◄──────────────────────────────────────────────────┘ │
      │                        HTTP 200                      │
      │                                                      │

[][]

The server MUST return an HTTP 400 response if the session ID (from the
sid query parameter) is not known.

To indicate success, the server MUST return an HTTP 200 response, with
the string ok in the response body.

To ensure packet ordering, a client MUST NOT have more than one active
POST request. Should it happen, the server MUST return an HTTP 400 error
status and close the session.

Receiving data​

To receive some packets, a client MUST create an HTTP GET request:

    CLIENT                                                SERVER

      │   GET /engine.io/?EIO=4&transport=polling&sid=...   │
      │ ──────────────────────────────────────────────────► │
      │                                                   . │
      │                                                   . │
      │                                                   . │
      │                                                   . │
      │ ◄─────────────────────────────────────────────────┘ │
      │                       HTTP 200                      │

[][]

The server MUST return an HTTP 400 response if the session ID (from the
sid query parameter) is not known.

The server MAY not respond right away if there are no packets buffered
for the given session. Once there are some packets to be sent, the
server SHOULD encode them (see Packet encoding) and send them in the
response body of the HTTP request.

To ensure packet ordering, a client MUST NOT have more than one active
GET request. Should it happen, the server MUST return an HTTP 400 error
status and close the session.

WebSocket​

The WebSocket transport consists of a WebSocket connection, which
provides a bidirectional and low-latency communication channel between
the server and the client.

The following query parameters are used:

  Name        Value       Description
  ----------- ----------- -------------------------------------------------------------------------------
  EIO         4           Mandatory, the version of the protocol.
  transport   websocket   Mandatory, the name of the transport.
  sid         <sid>       Optional, depending on whether it's an upgrade from HTTP long-polling or not.

If a mandatory query parameter is missing, then the server MUST close
the WebSocket connection.

Each packet (read or write) is sent its own WebSocket frame.

A client MUST NOT open more than one WebSocket connection per session.
Should it happen, the server MUST close the WebSocket connection.

Protocol​

An Engine.IO packet consists of:

- a packet type
- an optional packet payload

Here is the list of available packet types:

  Type      ID   Usage
  --------- ---- --------------------------------------------------
  open      0    Used during the handshake.
  close     1    Used to indicate that a transport can be closed.
  ping      2    Used in the heartbeat mechanism.
  pong      3    Used in the heartbeat mechanism.
  message   4    Used to send a payload to the other side.
  upgrade   5    Used during the upgrade process.
  noop      6    Used during the upgrade process.

Handshake​

To establish a connection, the client MUST send an HTTP GET request to
the server:

- HTTP long-polling first (by default)

    CLIENT                                                    SERVER

      │                                                          │
      │        GET /engine.io/?EIO=4&transport=polling           │
      │ ───────────────────────────────────────────────────────► │
      │ ◄──────────────────────────────────────────────────────┘ │
      │                        HTTP 200                          │
      │                                                          │

[][]

- WebSocket-only session

    CLIENT                                                    SERVER

      │                                                          │
      │        GET /engine.io/?EIO=4&transport=websocket         │
      │ ───────────────────────────────────────────────────────► │
      │ ◄──────────────────────────────────────────────────────┘ │
      │                        HTTP 101                          │
      │                                                          │

[][]

If the server accepts the connection, then it MUST respond with an open
packet with the following JSON-encoded payload:

  Key            Type       Description
  -------------- ---------- -----------------------------------------------------------------------------------------------
  sid            string     The session ID.
  upgrades       string[]   The list of available transport upgrades.
  pingInterval   number     The ping interval, used in the heartbeat mechanism (in milliseconds).
  pingTimeout    number     The ping timeout, used in the heartbeat mechanism (in milliseconds).
  maxPayload     number     The maximum number of bytes per chunk, used by the client to aggregate packets into payloads.

Example:

    {
      "sid": "lv_VI97HAXpY6yYWAAAC",
      "upgrades": ["websocket"],
      "pingInterval": 25000,
      "pingTimeout": 20000,
      "maxPayload": 1000000
    }

[][]

The client MUST send the sid value in the query parameters of all
subsequent requests.

Heartbeat​

Once the handshake is completed, a heartbeat mechanism is started to
check the liveness of the connection:

    CLIENT                                                 SERVER

      │                   *** Handshake ***                  │
      │                                                      │
      │  ◄─────────────────────────────────────────────────  │
      │                           2                          │  (ping packet)
      │  ─────────────────────────────────────────────────►  │
      │                           3                          │  (pong packet)

[][]

At a given interval (the pingInterval value sent in the handshake) the
server sends a ping packet and the client has a few seconds (the
pingTimeout value) to send a pong packet back.

If the server does not receive a pong packet back, then it SHOULD
consider that the connection is closed.

Conversely, if the client does not receive a ping packet within
pingInterval + pingTimeout, then it SHOULD consider that the connection
is closed.

Upgrade​

By default, the client SHOULD create an HTTP long-polling connection,
and then upgrade to better transports if available.

To upgrade to WebSocket, the client MUST:

- pause the HTTP long-polling transport (no more HTTP request gets
  sent), to ensure that no packet gets lost
- open a WebSocket connection with the same session ID
- send a ping packet with the string probe in the payload

The server MUST:

- send a noop packet to any pending GET request (if applicable) to
  cleanly close HTTP long-polling transport
- respond with a pong packet with the string probe in the payload

Finally, the client MUST send a upgrade packet to complete the upgrade:

    CLIENT                                                 SERVER

      │                                                      │
      │   GET /engine.io/?EIO=4&transport=websocket&sid=...  │
      │ ───────────────────────────────────────────────────► │
      │  ◄─────────────────────────────────────────────────┘ │
      │            HTTP 101 (WebSocket handshake)            │
      │                                                      │
      │            -----  WebSocket frames -----             │
      │  ─────────────────────────────────────────────────►  │
      │                         2probe                       │ (ping packet)
      │  ◄─────────────────────────────────────────────────  │
      │                         3probe                       │ (pong packet)
      │  ─────────────────────────────────────────────────►  │
      │                         5                            │ (upgrade packet)
      │                                                      │

[][]

Message​

Once the handshake is completed, the client and the server can exchange
data by including it in a message packet.

Packet encoding​

The serialization of an Engine.IO packet depends on the type of the
payload (plaintext or binary) and on the transport.

HTTP long-polling​

Due to the nature of the HTTP long-polling transport, multiple packets
might be concatenated in a single payload in order to increase
throughput.

Format:

    <packet type>[<data>]<separator><packet type>[<data>]<separator><packet type>[<data>][...]

[][]

Example:

    4hello\x1e2\x1e4world

    with:

    4      => message packet type
    hello  => message payload
    \x1e   => separator
    2      => ping packet type
    \x1e   => separator
    4      => message packet type
    world  => message payload

[][]

The packets are separated by the record separator character: \x1e

Binary payloads MUST be base64-encoded and prefixed with a b character:

Example:

    4hello\x1ebAQIDBA==

    with:

    4         => message packet type
    hello     => message payload
    \x1e      => separator
    b         => binary prefix
    AQIDBA==  => buffer <01 02 03 04> encoded as base64

[][]

The client SHOULD use the maxPayload value sent during the handshake to
decide how many packets should be concatenated.

WebSocket​

Each Engine.IO packet is sent in its own WebSocket frame.

Format:

    <packet type>[<data>]

[][]

Example:

    4hello

    with:

    4      => message packet type
    hello  => message payload (UTF-8 encoded)

[][]

Binary payloads are sent as is, without modification.

History​

From v2 to v3​

- add support for binary data

The 2nd version of the protocol is used in Socket.IO v0.9 and below.

The 3rd version of the protocol is used in Socket.IO v1 and v2.

From v3 to v4​

- reverse ping/pong mechanism

The ping packets are now sent by the server, because the timers set in
the browsers are not reliable enough. We suspect that a lot of timeout
problems came from timers being delayed on the client-side.

- always use base64 when encoding a payload with binary data

This change allows to treat all payloads (with or without binary) the
same way, without having to take in account whether the client or the
current transport supports binary data or not.

Please note that this only applies to HTTP long-polling. Binary data is
sent in WebSocket frames with no additional transformation.

- use a record separator (\x1e) instead of counting of characters

Counting characters prevented (or at least makes harder) to implement
the protocol in other languages, which may not use the UTF-16 encoding.

For example, € was encoded to 2:4€, though Buffer.byteLength('€') === 3.

Note: this assumes the record separator is not used in the data.

The 4th version (current) is included in Socket.IO v3 and above.

Test suite​

The test suite in the test-suite/ directory lets you check the
compliance of a server implementation.

Usage:

- in Node.js: npm ci && npm test
- in a browser: simply open the index.html file in your browser

For reference, here is expected configuration for the JavaScript server
to pass all tests:

    import { listen } from "engine.io";

    const server = listen(3000, {
      pingInterval: 300,
      pingTimeout: 200,
      maxPayload: 1e6,
      cors: {
        origin: "*"
      }
    });

    server.on("connection", socket => {
      socket.on("data", (...args) => {
        socket.send(...args);
      });
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Glossary

Next

The Socket.IO protocol

- Introduction
- Transports
  - HTTP long-polling
  - WebSocket
- Protocol
  - Handshake
  - Heartbeat
  - Upgrade
  - Message
- Packet encoding
  - HTTP long-polling
  - WebSocket
- History
  - From v2 to v3
  - From v3 to v4
- Test suite

=============

## doc_docs_v4_faq_#what-are-the-features-provided-by-socketio-over-plain-websocket.txt

- []
- Miscellaneous
- FAQ

Version: 4.x

On this page

FAQ

Here is a list of common questions about Socket.IO:

- Something does not work properly, please help?
- How does it work under the hood?
- What are the features provided by Socket.IO over plain WebSocket?
- What is WebTransport?
- Does Socket.IO store the messages?
- What are the delivery guarantees of Socket.IO?
- How to identify a given user?
- Where can I find the changelog?

Something does not work properly, please help?​

Please check the Troubleshooting guide.

How does it work under the hood?​

The Socket.IO connection can be established with different low-level
transports:

- HTTP long-polling
- WebSocket
- WebTransport

Socket.IO will automatically pick the best available option, depending
on:

- the capabilities of the browser (see here and here)
- the network (some networks block WebSocket and/or WebTransport
  connections)

You can find more detail about that in the "How it works" section.

What are the features provided by Socket.IO over plain WebSocket?​

WebSockets are awesome! No, really. They provide an efficient way for
transferring data between a client and a server. Among the advantages:

- you don't need to rely on periodic polling to fetch data from the
  server
- you don't need to repeatedly send all the HTTP headers when sending
  data to the server

Which make them perfect for low-latency and data-intensive applications
like games, chats, collaborative solutions...

That being said, WebSockets are also pretty low-level and developing a
realtime applications with WebSockets often requires an additional layer
over them:

- fallback to HTTP long-polling, in case the WebSocket connection can't
  be established
- automatic reconnection, in case the WebSocket connection gets closed
- acknowledgements, to send some data and expect a response from the
  other side
- broadcast to all or to a subset of connected clients
- scale up to multiple instances of the server
- connection recovery, for short periods of disconnection

As you might have guessed, this additional layer is implemented by the
Socket.IO library.

What is WebTransport?​

In short, WebTransport is an alternative to WebSocket which fixes
several performance issues that plague WebSockets like head-of-line
blocking.

If you want more information about this new web API (which was included
in Chrome in January 2022 and in Firefox in June 2023), please check
those links:

- https://w3c.github.io/webtransport/
- https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
- https://developer.chrome.com/articles/webtransport/

[]note

Support for WebTransport is not enabled by default in Socket.IO, as it
requires a secure context (HTTPS). Please check the dedicated tutorial
if you want to play with WebTransport.

Does Socket.IO store the messages?​

The Socket.IO server does not store any message.

It is the duty of your application to persist those messages somewhere
for the clients that are not currently connected.

[]tip

That being said, Socket.IO will store the messages for a brief period of
time if you enable the Connection state recovery feature.

What are the delivery guarantees of Socket.IO?​

Socket.IO does guarantee message ordering, no matter which low-level
transport is used (even when switching between two transports).

Moreover, by default Socket.IO provides an at most once guarantee of
delivery (also known as "fire and forget"), which means that under
certain circumstances a message might get lost and no retry will be
attempted.

More information about this here.

How to identify a given user?​

There is no concept of user in Socket.IO.

It is the duty of your application to link a given Socket.IO connection
to a user account.

For Node.js applications, you can for example:

- reuse the user context provided by Passport (check this tutorial)
- or use the auth option on the client side to send the user credentials
  and validate them in a middleware

Where can I find the changelog?​

Please see here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Migrating from 3.x to 4.0

Next

Glossary

- Something does not work properly, please help?
- How does it work under the hood?
- What are the features provided by Socket.IO over plain WebSocket?
- What is WebTransport?
- Does Socket.IO store the messages?
- What are the delivery guarantees of Socket.IO?
- How to identify a given user?
- Where can I find the changelog?

=============

## doc_docs_v4_glossary_.txt

- []
- Miscellaneous
- Glossary

Version: 4.x

On this page

Glossary

We will list here the terms that are related to the Socket.IO ecosystem:

- Adapter
- Engine.IO
- Namespace
- Room
- Transport

Adapter​

An Adapter is a server-side component which is responsible for:

- storing the relationships between the Socket instances and the rooms
- broadcasting events to all (or a subset of) clients

Besides the in-memory adapter which is included by default with the
Socket.IO server, there are currently 5 official adapters:

- the Redis adapter
- the Redis Streams adapter
- the MongoDB adapter
- the Postgres adapter
- the Cluster adapter

The in-memory adapter can be extended to add support for other messaging
systems, like RabbitMQ or Google Pub/Sub for example.

Please see the documentation here.

Engine.IO​

Engine.IO is an internal component of Socket.IO, which is responsible
for establishing the low-level connection between the server and the
client.

You will find more information here.

Namespace​

A Namespace is a concept that allows splitting the application logic on
the server-side.

Please see the documentation here.

Room​

A Room is a server-side concept that allows broadcasting data to a
subset of clients.

Please see the documentation here.

Transport​

A Transport represents the low-level way of establishing a connection
between the server and the client.

There are currently two implemented transports:

- HTTP long-polling
- WebSocket
- WebTransport

Please see the documentation here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

FAQ

Next

The Engine.IO protocol

- Adapter
- Engine.IO
- Namespace
- Room
- Transport

=============

## doc_docs_v4_handling-cors_.txt

- []
- Server
- Handling CORS

Version: 4.x

On this page

Handling CORS

Configuration​

Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource
Sharing (CORS).

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      cors: {
        origin: "https://example.com"
      }
    });

[][]

All options will be forwarded to the cors package. The complete list of
options can be found here.

Example with cookies (withCredentials) and additional headers:

    // server-side
    const io = new Server(httpServer, {
      cors: {
        origin: "https://example.com",
        allowedHeaders: ["my-custom-header"],
        credentials: true
      }
    });

    // client-side
    import { io } from "socket.io-client";
    const socket = io("https://api.example.com", {
      withCredentials: true,
      extraHeaders: {
        "my-custom-header": "abcd"
      }
    });

[][]

Note: this also applies to localhost if your web application and your
server are not served from the same port

    const io = new Server(httpServer, {
      cors: {
        origin: "http://localhost:8080"
      }
    });

    httpServer.listen(3000);

[][]

You can disallow all cross-origin requests with the allowRequest option:

    const io = new Server(httpServer, {
      allowRequest: (req, callback) => {
        const noOriginHeader = req.headers.origin === undefined;
        callback(null, noOriginHeader); // only allow requests without 'origin' header
      }
    });

[][]

Troubleshooting​

CORS header ‘Access-Control-Allow-Origin’ missing​

Full error message:

  Cross-Origin Request Blocked: The Same Origin Policy disallows reading
  the remote resource at
  .../socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header
  ‘Access-Control-Allow-Origin’ missing).

If you have properly configured your server (see above), this could mean
that your browser wasn't able to reach the Socket.IO server.

The following command:

    curl "https://api.example.com/socket.io/?EIO=4&transport=polling"

[][]

should return something like:

    0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}

[][]

If that's not the case, please check that your server is listening and
is actually reachable on the given port.

Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’​

Full error message:

  Cross-Origin Request Blocked: The Same Origin Policy disallows reading
  the remote resource at
  ‘.../socket.io/?EIO=4&transport=polling&t=NvQfU77’. (Reason:
  Credential is not supported if the CORS header
  ‘Access-Control-Allow-Origin’ is ‘*’)

You can't set withCredentials to true with origin: *, you need to use a
specific origin:

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      cors: {
        origin: "https://my-frontend.com",
        // or with an array of origins
        // origin: ["https://my-frontend.com", "https://my-other-frontend.com", "http://localhost:3000"],
        credentials: true
      }
    });

[][]

Expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’​

Full error message:

  Cross-Origin Request Blocked: The Same Origin Policy disallows reading
  the remote resource at
  .../socket.io/?EIO=4&transport=polling&t=NvQny19. (Reason: expected
  ‘true’ in CORS header ‘Access-Control-Allow-Credentials’)

In that case, withCredentials is set to true on the client, but the
server is missing the credentials attribute in the cors option. See the
example above.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Using multiple nodes

Next

Application structure

- Configuration
- Troubleshooting
  - CORS header ‘Access-Control-Allow-Origin’ missing
  - Credential is not supported if the CORS header
    ‘Access-Control-Allow-Origin’ is ‘*’
  - Expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’

=============

## doc_docs_v4_how-it-works_.txt

- []
- Documentation
- How it works

Version: 4.x

On this page

How it works

The bidirectional channel between the Socket.IO server (Node.js) and the
Socket.IO client (browser, Node.js, or another programming language) is
established with a WebSocket connection whenever possible, and will use
HTTP long-polling as fallback.

The Socket.IO codebase is split into two distinct layers:

- the low-level plumbing: what we call Engine.IO, the engine inside
  Socket.IO
- the high-level API: Socket.IO itself

Engine.IO​

Engine.IO is responsible for establishing the low-level connection
between the server and the client. It handles:

- the various transports and the upgrade mechanism
- the disconnection detection

A detailed version of the Engine.IO protocol can be found here.

The source code of the reference implementation (written in TypeScript)
can be found here:

- server: https://github.com/socketio/engine.io
- client: https://github.com/socketio/engine.io-client
- parser: https://github.com/socketio/engine.io-parser

Transports​

There are currently two implemented transports:

- HTTP long-polling
- WebSocket

HTTP long-polling​

The HTTP long-polling transport (also simply referred as "polling")
consists of successive HTTP requests:

- long-running GET requests, for receiving data from the server
- short-running POST requests, for sending data to the server

Due to the nature of the transport, successive emits may be concatenated
and sent within the same HTTP request.

WebSocket​

The WebSocket transport consists, well, of a WebSocket connection, which
provides a bidirectional and low-latency communication channel between
the server and the client.

Due to the nature of the transport, each emit is sent in its own
WebSocket frame (some emits may even result in two distinct WebSocket
frames, more information here).

Handshake​

At the beginning of the Engine.IO connection, the server sends some
information:

    {
      "sid": "FSDjX-WRwSA4zTZMALqx",
      "upgrades": ["websocket"],
      "pingInterval": 25000,
      "pingTimeout": 20000
    }

[][]

- the sid is the ID of the session, it must be included in the sid query
  parameter in all subsequent HTTP requests
- the upgrades array contains the list of all "better" transports that
  are supported by the server
- the pingInterval and pingTimeout values are used in the heartbeat
  mechanism

Upgrade mechanism​

By default, the client establishes the connection with the HTTP
long-polling transport.

But, why?

While WebSocket is clearly the best way to establish a bidirectional
communication, experience has shown that it is not always possible to
establish a WebSocket connection, due to corporate proxies, personal
firewall, antivirus software...

From the user perspective, an unsuccessful WebSocket connection can
translate in up to 10 seconds of waiting for the realtime application to
begin exchanging data. This perceptively hurts user experience.

To summarize, Engine.IO focuses on reliability and user experience
first, marginal potential UX improvements and increased server
performance second.

To upgrade, the client will:

- ensure its outgoing buffer is empty
- put the current transport in read-only mode
- try to establish a connection with the other transport
- if successful, close the first transport

You can check in the Network Monitor of your browser:

[Successful upgrade]

1.  handshake (contains the session ID — here, zBjrh...AAAK — that is
    used in subsequent requests)
2.  send data (HTTP long-polling)
3.  receive data (HTTP long-polling)
4.  upgrade (WebSocket)
5.  receive data (HTTP long-polling, closed once the WebSocket
    connection in 4. is successfully established)

Disconnection detection​

The Engine.IO connection is considered as closed when:

- one HTTP request (either GET or POST) fails (for example, when the
  server is shutdown)
- the WebSocket connection is closed (for example, when the user closes
  the tab in its browser)
- socket.disconnect() is called on the server-side or on the client-side

There is also a heartbeat mechanism which checks that the connection
between the server and the client is still up and running:

At a given interval (the pingInterval value sent in the handshake) the
server sends a PING packet and the client has a few seconds (the
pingTimeout value) to send a PONG packet back. If the server does not
receive a PONG packet back, it will consider that the connection is
closed. Conversely, if the client does not receive a PING packet within
pingInterval + pingTimeout, it will consider that the connection is
closed.

The disconnection reasons are listed here (server-side) and here
(client-side).

Socket.IO​

Socket.IO provides some additional features over the Engine.IO
connection:

- automatic reconnection
- packet buffering
- acknowledgments
- broadcasting to all clients or to a subset of clients (what we call
  "Room")
- multiplexing (what we call "Namespace")

A detailed version of the Socket.IO protocol can be found here.

The source code of the reference implementation (written in TypeScript)
can be found here:

- server: https://github.com/socketio/socket.io
- client: https://github.com/socketio/socket.io-client
- parser: https://github.com/socketio/socket.io-parser

[]Edit this page

Last updated on Mar 28, 2025

Previous

Introduction

Next

Delivery guarantees

- Engine.IO
  - Transports
  - Handshake
  - Upgrade mechanism
  - Disconnection detection
- Socket.IO

=============

## doc_docs_v4_listening-to-events_.txt

- []
- Events
- Listening to events

Version: 4.x

On this page

Listening to events

There are several ways to handle events that are transmitted between the
server and the client.

EventEmitter methods​

On the server-side, the Socket instance extends the Node.js EventEmitter
class.

On the client-side, the Socket instance uses the event emitter provided
by the component-emitter library, which exposes a subset of the
EventEmitter methods.

socket.on(eventName, listener)​

Adds the listener function to the end of the listeners array for the
event named eventName.

    socket.on("details", (...args) => {
      // ...
    });

[][]

socket.once(eventName, listener)​

Adds a one-time listener function for the event named eventName

    socket.once("details", (...args) => {
      // ...
    });

[][]

socket.off(eventName, listener)​

Removes the specified listener from the listener array for the event
named eventName.

    const listener = (...args) => {
      console.log(args);
    }

    socket.on("details", listener);

    // and then later...
    socket.off("details", listener);

[][]

socket.removeAllListeners([eventName])​

Removes all listeners, or those of the specified eventName.

    // for a specific event
    socket.removeAllListeners("details");
    // for all events
    socket.removeAllListeners();

[][]

Catch-all listeners​

Since Socket.IO v3, a new API inspired from the EventEmitter2 library
allows to declare catch-all listeners.

This feature is available on both the client and the server.

socket.onAny(listener)​

Adds a listener that will be fired when any event is emitted.

    socket.onAny((eventName, ...args) => {
      // ...
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.emit("foo", (value) => {
      // ...
    });

    socket.onAnyOutgoing(() => {
      // triggered when the event is sent
    });

    socket.onAny(() => {
      // not triggered when the acknowledgement is received
    });

[][]

socket.prependAny(listener)​

Adds a listener that will be fired when any event is emitted. The
listener is added to the beginning of the listeners array.

    socket.prependAny((eventName, ...args) => {
      // ...
    });

[][]

socket.offAny([listener])​

Removes all catch-all listeners, or the given listener.

    const listener = (eventName, ...args) => {
      console.log(eventName, args);
    }

    socket.onAny(listener);

    // and then later...
    socket.offAny(listener);

    // or all listeners
    socket.offAny();

[][]

socket.onAnyOutgoing(listener)​

Register a new catch-all listener for outgoing packets.

    socket.onAnyOutgoing((event, ...args) => {
      // ...
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.on("foo", (value, callback) => {
      callback("OK");
    });

    socket.onAny(() => {
      // triggered when the event is received
    });

    socket.onAnyOutgoing(() => {
      // not triggered when the acknowledgement is sent
    });

[][]

socket.prependAnyOutgoing(listener)​

Register a new catch-all listener for outgoing packets. The listener is
added to the beginning of the listeners array.

    socket.prependAnyOutgoing((event, ...args) => {
      // ...
    });

[][]

socket.offAnyOutgoing([listener])​

Removes the previously registered listener. If no listener is provided,
all catch-all listeners are removed.

    const listener = (eventName, ...args) => {
      console.log(eventName, args);
    }

    socket.onAnyOutgoing(listener);

    // remove a single listener
    socket.offAnyOutgoing(listener);

    // remove all listeners
    socket.offAnyOutgoing();

[][]

Validation​

The validation of the event arguments is out of the scope of the
Socket.IO library.

There are many packages in the JS ecosystem which cover this use case,
among them:

- zod
- joi
- ajv
- validatorjs

Example with joi and acknowledgements:

    const Joi = require("joi");

    const userSchema = Joi.object({
      username: Joi.string().max(30).required(),
      email: Joi.string().email().required()
    });

    io.on("connection", (socket) => {
      socket.on("create user", (payload, callback) => {
        if (typeof callback !== "function") {
          // not an acknowledgement
          return socket.disconnect();
        }
        const { error, value } = userSchema.validate(payload);
        if (error) {
          return callback({
            status: "Bad Request",
            error
          });
        }
        // do something with the value, and then
        callback({
          status: "OK"
        });
      });

    });

[][]

Error handling​

There is currently no built-in error handling in the Socket.IO library,
which means you must catch any error that could be thrown in a listener.

    io.on("connection", (socket) => {
      socket.on("list items", async (callback) => {
        try {
          const items = await findItems();
          callback({
            status: "OK",
            items
          });
        } catch (e) {
          callback({
            status: "NOK"
          });
        }
      });
    });

[][]

This can be refactored into:

    const errorHandler = (handler) => {
      const handleError = (err) => {
        console.error("please handle me", err);
      };

      return (...args) => {
        try {
          const ret = handler.apply(this, args);
          if (ret && typeof ret.catch === "function") {
            // async handler
            ret.catch(handleError);
          }
        } catch (e) {
          // sync handler
          handleError(e);
        }
      };
    };

    // server or client side
    socket.on("hello", errorHandler(() => {
      throw new Error("let's panic");
    }));

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Emitting events

Next

Broadcasting events

- EventEmitter methods
  - socket.on(eventName, listener)
  - socket.once(eventName, listener)
  - socket.off(eventName, listener)
  - socket.removeAllListeners(eventName)
- Catch-all listeners
  - socket.onAny(listener)
  - socket.prependAny(listener)
  - socket.offAny(listener)
  - socket.onAnyOutgoing(listener)
  - socket.prependAnyOutgoing(listener)
  - socket.offAnyOutgoing(listener)
- Validation
- Error handling

=============

## doc_docs_v4_load-testing_.txt

- []
- Advanced
- Load testing

Version: 4.x

On this page

Load testing

Since Socket.IO has its own protocol, including handshake, heartbeats
and custom packet encoding, the easiest way to load test your Socket.IO
server is to use the Socket.IO client library and create a lot of
clients.

There are two classic solutions to do this:

- using Artillery
- or manually manage the clients

Artillery​

Artillery is a great tool for load testing your application. It allows
creating connections, sending events and checking acknowledgments.

The documentation can be found here.

Important note: the default installation comes with a v2 client, which
is not compatible with a v3/v4 server. You need to install a custom
engine for this: https://github.com/ptejada/artillery-engine-socketio-v3

Installation:

    $ npm install artillery artillery-engine-socketio-v3

[][]

Sample scenario:

    # my-scenario.yml
    config:
      target: "http://localhost:3000"
      phases:
        - duration: 60
          arrivalRate: 10
      engines:
       socketio-v3: {}

    scenarios:
      - name: My sample scenario
        engine: socketio-v3
        flow:
          # wait for the WebSocket upgrade (optional)
          - think: 1

          # basic emit
          - emit:
              channel: "hello"
              data: "world"

          # emit an object
          - emit:
              channel: "hello"
              data:
                id: 42
                status: "in progress"
                tags:
                  - "tag1"
                  - "tag2"

          # emit in a custom namespace
          - namespace: "/my-namespace"
            emit:
              channel: "hello"
              data: "world"

          # emit with acknowledgement
          - emit:
              channel: "ping"
            acknowledge:
              match:
                value: "pong"

          # do nothing for 30 seconds then disconnect
          - think: 30

[][]

To run this scenario:

    $ npx artillery run my-scenario.yml

[][]

Artillery also comes with a lot of awesome features, like the ability to
publish the metrics to various endpoints or run the tests from AWS.

Its only limitation is that you cannot easily test server-to-client
events, as the Artillery DSL is more suited for classic client-to-server
communication. Which brings us to our next section.

Manual client creation​

Here's a basic script to create a thousand Socket.IO clients and monitor
the number of packets received per second:

    const { io } = require("socket.io-client");

    const URL = process.env.URL || "http://localhost:3000";
    const MAX_CLIENTS = 1000;
    const POLLING_PERCENTAGE = 0.05;
    const CLIENT_CREATION_INTERVAL_IN_MS = 10;
    const EMIT_INTERVAL_IN_MS = 1000;

    let clientCount = 0;
    let lastReport = new Date().getTime();
    let packetsSinceLastReport = 0;

    const createClient = () => {
      // for demonstration purposes, some clients stay stuck in HTTP long-polling
      const transports =
        Math.random() < POLLING_PERCENTAGE ? ["polling"] : ["polling", "websocket"];

      const socket = io(URL, {
        transports,
      });

      setInterval(() => {
        socket.emit("client to server event");
      }, EMIT_INTERVAL_IN_MS);

      socket.on("server to client event", () => {
        packetsSinceLastReport++;
      });

      socket.on("disconnect", (reason) => {
        console.log(`disconnect due to ${reason}`);
      });

      if (++clientCount < MAX_CLIENTS) {
        setTimeout(createClient, CLIENT_CREATION_INTERVAL_IN_MS);
      }
    };

    createClient();

    const printReport = () => {
      const now = new Date().getTime();
      const durationSinceLastReport = (now - lastReport) / 1000;
      const packetsPerSeconds = (
        packetsSinceLastReport / durationSinceLastReport
      ).toFixed(2);

      console.log(
        `client count: ${clientCount} ; average packets received per second: ${packetsPerSeconds}`
      );

      packetsSinceLastReport = 0;
      lastReport = now;
    };

    setInterval(printReport, 5000);

[][]

You can use it as a starting point for load testing your own
application.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Usage with PM2

Next

Performance tuning

- Artillery
- Manual client creation

=============

## doc_docs_v4_logging-and-debugging_.txt

- []
- Documentation
- Logging and debugging

Version: 4.x

On this page

Logging and debugging

Socket.IO is now completely instrumented by a minimalistic yet
tremendously powerful utility called debug by TJ Holowaychuk.

Before 1.0, the Socket.IO server would default to logging everything out
to the console. This turned out to be annoyingly verbose for many users
(although extremely useful for others), so now we default to being
completely silent by default.

The basic idea is that each module used by Socket.IO provides different
debugging scopes that give you insight into the internals. By default,
all output is suppressed, and you can opt into seeing messages by
supplying the DEBUG env variable (Node.JS) or the localStorage.debug
property (Browsers).

You can see it in action for example on our homepage:

Available debugging scopes​

The best way to see what information is available is to use the *:

    DEBUG=* node yourfile.js

[][]

or in the browser:

    localStorage.debug = '*';

[][]

And then filter by the scopes you’re interested in. You can prefix the *
with scopes, separated by comma if there is more than one. For example,
to only see debug statements from the socket.io client on Node.js try
this:

    DEBUG=socket.io:client* node yourfile.js

[][]

To see all debug messages from the engine and socket.io:

    DEBUG=engine,socket.io* node yourfile.js

[][]

Removing debug from your browser bundle​

While useful during development, the debug package adds an extra weight
to the final bundle (about 4KB minified and gzipped), that's why it is
excluded from the slim bundle (more details about the various browser
bundles can be found here).

If you are using webpack, you can remove it with webpack-remove-debug:

    {
      module: {
        rules: [
          {
            test: /\.js$/,
            loader: 'webpack-remove-debug'
          }
        ]
      }
    }

[][]

Error logs in the browser console​

Please note that error logs such as:

- net::ERR_INTERNET_DISCONNECTED
- net::ERR_CONNECTION_REFUSED
- WebSocket is already in CLOSING or CLOSED state
- Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
- The connection to xxx was interrupted while the page was loading

are not emitted by the Socket.IO library but by the browser itself, and
are therefore out of our control.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Connection state recovery

Next

Testing

- Available debugging scopes
  - Removing debug from your browser bundle
- Error logs in the browser console

=============

## doc_docs_v4_memory-usage_.txt

- []
- Documentation
- Memory usage

Version: 4.x

On this page

Memory usage

The resources consumed by your Socket.IO server will mainly depend on:

- the number of connected clients
- the number of messages (basic emit, emit with acknowledgement and
  broadcast) received and sent per second

[]info

The memory usage of the Socket.IO server should scale linearly with the
number of connected clients.

[]tip

By default, a reference to the first HTTP request of each session is
kept in memory. This reference is needed when working with
express-session for example (see here), but can be discarded to save
memory:

    io.engine.on("connection", (rawSocket) => {
      rawSocket.request = null;
    });

[][]

The source code to reproduce the results presented in this page can be
found there.

See also:

- Load testing
- Performance tuning

Memory usage per WebSocket server implementation​

The memory usage of the Socket.IO server heavily depends on the memory
usage of the underlying WebSocket server implementation.

The chart below displays the memory usage of the Socket.IO server, from
0 up to 10 000 connected clients, with:

- a Socket.IO server based on the ws package (used by default)
- a Socket.IO server based on the eiows package, a C++ WebSocket server
  implementation (see installation steps)
- a Socket.IO server based on the µWebSockets.js package, a C++
  alternative to the Node.js native HTTP server (see installation steps)
- a plain WebSocket server based on the ws package

[Chart of the memory usage per WebSocket server implementation]

Tested on Ubuntu 22.04 LTS with Node.js v20.3.0, with the following
package versions:

- socket.io@4.7.2
- eiows@6.7.2
- uWebSockets.js@20.33.0
- ws@8.11.0

Memory usage over time​

The chart below displays the memory usage of the Socket.IO server over
time, from 0 up to 10 000 connected clients.

[Chart of the memory usage over time]

[]note

For demonstration purposes, we manually call the garbage collector at
the end of each wave of clients:

    io.on("connection", (socket) => {
      socket.on("disconnect", () => {
        const lastToDisconnect = io.of("/").sockets.size === 0;
        if (lastToDisconnect) {
          gc();
        }
      });
    });

[][]

Which explains the clean drop in memory usage when the last client
disconnects. This is not needed in your application, the garbage
collection will be automatically triggered when necessary.

[]Edit this page

Last updated on Mar 28, 2025

Previous

TypeScript

Next

Installation

- Memory usage per WebSocket server implementation
- Memory usage over time

=============

## doc_docs_v4_middlewares_.txt

- []
- Server
- Middlewares

Version: 4.x

On this page

Middlewares

A middleware function is a function that gets executed for every
incoming connection.

Middleware functions can be useful for:

- logging
- authentication / authorization
- rate limiting

Note: this function will be executed only once per connection (even if
the connection consists in multiple HTTP requests).

[]info

If you are looking for Express middlewares, please check this section.

Registering a middleware​

A middleware function has access to the Socket instance and to the next
registered middleware function.

    io.use((socket, next) => {
      if (isValid(socket.request)) {
        next();
      } else {
        next(new Error("invalid"));
      }
    });

[][]

You can register several middleware functions, and they will be executed
sequentially:

    io.use((socket, next) => {
      next();
    });

    io.use((socket, next) => {
      next(new Error("thou shall not pass"));
    });

    io.use((socket, next) => {
      // not executed, since the previous middleware has returned an error
      next();
    });

[][]

Please make sure to call next() in any case. Otherwise, the connection
will be left hanging until it is closed after a given timeout.

Important note: the Socket instance is not actually connected when the
middleware gets executed, which means that no disconnect event will be
emitted if the connection eventually fails.

For example, if the client manually closes the connection:

    // server-side
    io.use((socket, next) => {
      setTimeout(() => {
        // next is called after the client disconnection
        next();
      }, 1000);

      socket.on("disconnect", () => {
        // not triggered
      });
    });

    io.on("connection", (socket) => {
      // not triggered
    });

    // client-side
    const socket = io();
    setTimeout(() => {
      socket.disconnect();
    }, 500);

[][]

Sending credentials​

The client can send credentials with the auth option:

    // plain object
    const socket = io({
      auth: {
        token: "abc"
      }
    });

    // or with a function
    const socket = io({
      auth: (cb) => {
        cb({
          token: "abc"
        });
      }
    });

[][]

Those credentials can be accessed in the handshake object on the
server-side:

    io.use((socket, next) => {
      const token = socket.handshake.auth.token;
      // ...
    });

[][]

Handling middleware error​

If the next method is called with an Error object, the connection will
be refused and the client will receive an connect_error event.

    // client-side
    socket.on("connect_error", (err) => {
      console.log(err.message); // prints the message associated with the error
    });

[][]

You can attach additional details to the Error object:

    // server-side
    io.use((socket, next) => {
      const err = new Error("not authorized");
      err.data = { content: "Please retry later" }; // additional details
      next(err);
    });

    // client-side
    socket.on("connect_error", (err) => {
      console.log(err instanceof Error); // true
      console.log(err.message); // not authorized
      console.log(err.data); // { content: "Please retry later" }
    });

[][]

Compatibility with Express middleware​

Since they are not bound to a usual HTTP request/response cycle,
Socket.IO middlewares are not really compatible with Express
middlewares.

That being said, starting with version 4.6.0, Express middlewares are
now supported by the underlying engine:

    io.engine.use((req, res, next) => {
      // do something

      next();
    });

[][]

The middlewares will be called for each incoming HTTP requests,
including upgrade requests.

Example with express-session:

    import session from "express-session";

    io.engine.use(session({
      secret: "keyboard cat",
      resave: false,
      saveUninitialized: true,
      cookie: { secure: true }
    }));

[][]

Example with helmet:

    import helmet from "helmet";

    io.engine.use(helmet());

[][]

If the middleware must be only applied to the handshake request (and not
for each HTTP request), you can check for the existence of the sid query
parameter.

Example with passport-jwt:

    io.engine.use((req, res, next) => {
      const isHandshake = req._query.sid === undefined;
      if (isHandshake) {
        passport.authenticate("jwt", { session: false })(req, res, next);
      } else {
        next();
      }
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

The Socket instance

Next

Behind a reverse proxy

- Registering a middleware
- Sending credentials
- Handling middleware error
- Compatibility with Express middleware

=============

## doc_docs_v4_namespaces_.txt

- []
- Advanced
- Namespaces

Version: 4.x

On this page

Namespaces

A Namespace is a communication channel that allows you to split the
logic of your application over a single shared connection (also called
"multiplexing").

[Namespace diagram][Namespace diagram]

Introduction​

Each namespace has its own:

- event handlers

    io.of("/orders").on("connection", (socket) => {
      socket.on("order:list", () => {});
      socket.on("order:create", () => {});
    });

    io.of("/users").on("connection", (socket) => {
      socket.on("user:list", () => {});
    });

[][]

- rooms

    const orderNamespace = io.of("/orders");

    orderNamespace.on("connection", (socket) => {
      socket.join("room1");
      orderNamespace.to("room1").emit("hello");
    });

    const userNamespace = io.of("/users");

    userNamespace.on("connection", (socket) => {
      socket.join("room1"); // distinct from the room in the "orders" namespace
      userNamespace.to("room1").emit("holà");
    });

[][]

- middlewares

    const orderNamespace = io.of("/orders");

    orderNamespace.use((socket, next) => {
      // ensure the socket has access to the "orders" namespace, and then
      next();
    });

    const userNamespace = io.of("/users");

    userNamespace.use((socket, next) => {
      // ensure the socket has access to the "users" namespace, and then
      next();
    });

[][]

Possible use cases:

- you want to create a special namespace that only authorized users have
  access to, so the logic related to those users is separated from the
  rest of the application

    const adminNamespace = io.of("/admin");

    adminNamespace.use((socket, next) => {
      // ensure the user has sufficient rights
      next();
    });

    adminNamespace.on("connection", socket => {
      socket.on("delete user", () => {
        // ...
      });
    });

[][]

- your application has multiple tenants so you want to dynamically
  create one namespace per tenant

    const workspaces = io.of(/^\/\w+$/);

    workspaces.on("connection", socket => {
      const workspace = socket.nsp;

      workspace.emit("hello");
    });

[][]

Main namespace​

Until now, you interacted with the main namespace, called /. The io
instance inherits all of its methods:

    io.on("connection", (socket) => {});
    io.use((socket, next) => { next() });
    io.emit("hello");
    // are actually equivalent to
    io.of("/").on("connection", (socket) => {});
    io.of("/").use((socket, next) => { next() });
    io.of("/").emit("hello");

[][]

Some tutorials may also mention io.sockets, it's simply an alias for
io.of("/").

    io.sockets === io.of("/")

[][]

Custom namespaces​

To set up a custom namespace, you can call the of function on the
server-side:

    const nsp = io.of("/my-namespace");

    nsp.on("connection", socket => {
      console.log("someone connected");
    });

    nsp.emit("hi", "everyone!");

[][]

Client initialization​

Same-origin version:

    const socket = io(); // or io("/"), the main namespace
    const orderSocket = io("/orders"); // the "orders" namespace
    const userSocket = io("/users"); // the "users" namespace

[][]

Cross-origin/Node.js version:

    const socket = io("https://example.com"); // or io("https://example.com/"), the main namespace
    const orderSocket = io("https://example.com/orders"); // the "orders" namespace
    const userSocket = io("https://example.com/users"); // the "users" namespace

[][]

In the example above, only one WebSocket connection will be established,
and the packets will automatically be routed to the right namespace.

Please note that multiplexing will be disabled in the following cases:

- multiple creation for the same namespace

    const socket1 = io();
    const socket2 = io(); // no multiplexing, two distinct WebSocket connections

[][]

- different domains

    const socket1 = io("https://first.example.com");
    const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections

[][]

- usage of the forceNew option

    const socket1 = io();
    const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections

[][]

Dynamic namespaces​

It is also possible to dynamically create namespaces, either with a
regular expression:

    io.of(/^\/dynamic-\d+$/);

[][]

or with a function:

    io.of((name, auth, next) => {
      next(null, true); // or false, when the creation is denied
    });

[][]

You can have access to the new namespace in the connection event:

    io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
      const namespace = socket.nsp;
    });

[][]

The return value of the of() method is what we call the parent
namespace, from which you can:

- register middlewares

    const parentNamespace = io.of(/^\/dynamic-\d+$/);

    parentNamespace.use((socket, next) => { next() });

[][]

The middleware will automatically be registered on each child namespace.

- broadcast events

    const parentNamespace = io.of(/^\/dynamic-\d+$/);

    parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...

[][]

[]caution

Existing namespaces have priority over dynamic namespaces. For example:

    // register "dynamic-101" namespace
    io.of("/dynamic-101");

    io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
      // will not be called for a connection on the "dynamic-101" namespace
    });

[][]

Complete API​

The complete API exposed by the Namespace instance can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Azure Service Bus adapter

Next

Custom parser

- Introduction
- Main namespace
- Custom namespaces
- Client initialization
- Dynamic namespaces
- Complete API

=============

## doc_docs_v4_performance-tuning_.txt

- []
- Advanced
- Performance tuning

Version: 4.x

On this page

Performance tuning

Here are some tips to improve the performance of your Socket.IO server:

- at the Socket.IO level
- at the OS level

You might also be interested in scaling to multiple nodes.

At the Socket.IO level​

Since, in most cases, the Socket.IO connection will be established with
WebSocket, the performance of your Socket.IO server will be strongly
linked to the performance of the underlying WebSocket server (ws, by
default).

Install ws native add-ons​

ws comes with two optional binary add-ons which improve certain
operations. Prebuilt binaries are available for the most popular
platforms so you don't necessarily need to have a C++ compiler installed
on your machine.

- bufferutil: Allows to efficiently perform operations such as masking
  and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains
  valid UTF-8 as required by the spec.

To install those packages:

    $ npm install --save-optional bufferutil utf-8-validate

[][]

Please note that these packages are optional, the WebSocket server will
fallback to the Javascript implementation if they are not available.
More information can be found here.

Use another WebSocket server implementation​

For example, you can use the eiows package, which is a fork of the (now
deprecated) uws package:

    $ npm install eiows

[][]

And then use the wsEngine option:

    const { createServer } = require("http");
    const { Server } = require("socket.io");

    const httpServer = createServer();
    const io = new Server(httpServer, {
      wsEngine: require("eiows").Server
    });

[][]

Use a custom parser​

If you send binary data over the Socket.IO connection, using a custom
parser like the one based on msgpack might be interesting, as by default
each buffer will be sent in its own WebSocket frame.

Usage:

Server

    const { createServer } = require("http");
    const { Server } = require("socket.io");
    const parser = require("socket.io-msgpack-parser");

    const httpServer = createServer();
    const io = new Server(httpServer, {
      parser
    });

[][]

Client

    const { io } = require("socket.io-client");
    const parser = require("socket.io-msgpack-parser");

    const socket = io("https://example.com", {
      parser
    });

[][]

Discard the initial HTTP request​

By default, a reference to the first HTTP request of each session is
kept in memory. This reference is needed when working with
express-session for example (see here), but can be discarded to save
memory:

    io.engine.on("connection", (rawSocket) => {
      rawSocket.request = null;
    });

[][]

Before:

[Memory usage before]

After:

[Memory usage with request discarded]

At the OS level​

There are lots of good articles on how to tune your OS to accept a large
number of connections. Please see this one for example.

While load testing your Socket.IO server, you will likely reach the two
following limits:

- maximum number of open files

If you can't go over 1000 concurrent connections (new clients are not
able to connect), you have most certainly reached the maximum number of
open files:

    $ ulimit -n
    1024

[][]

To increase this number, create a new file
/etc/security/limits.d/custom.conf with the following content (requires
root privileges):

    * soft nofile 1048576
    * hard nofile 1048576

[][]

And then reload your session. Your new limit should now be updated:

    $ ulimit -n
    1048576

[][]

- maximum number of available local ports

If you can't go over 28000 concurrent connections, you have most
certainly reached the maximum number of available local ports:

    $ cat /proc/sys/net/ipv4/ip_local_port_range
    32768   60999

[][]

To increase this number, create a new file
/etc/sysctl.d/net.ipv4.ip_local_port_range.conf with the following
content (again, requires root privileges):

    net.ipv4.ip_local_port_range = 10000 65535

[][]

Note: we used 10000 as a lower bound so it does not include the ports
that are used by the services on the machine (like 5432 for a PostgreSQL
server), but you can totally use a lower value (down to 1024).

Once you reboot your machine, you will now be able to happily go to 55k
concurrent connections (per incoming IP).

See also:

- https://unix.stackexchange.com/a/130798

[]Edit this page

Last updated on Mar 28, 2025

Previous

Load testing

Next

Migrating from 2.x to 3.0

- At the Socket.IO level
  - Install ws native add-ons
  - Use another WebSocket server implementation
  - Use a custom parser
  - Discard the initial HTTP request
- At the OS level

=============

## doc_docs_v4_pm2_.txt

- []
- Advanced
- Usage with PM2

Version: 4.x

On this page

Usage with PM2

PM2 is a production process manager for Node.js applications with a
built-in load balancer. It allows you to keep applications alive
forever, to reload them without downtime and to facilitate common system
admin tasks.

You can find its documentation here:
https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/

To scale a Socket.IO server with PM2, there are three solutions:

- disable HTTP long-polling on the client-side

    const socket = io({
      transports: ["websocket"]
    });

[][]

Though in that case, there will be no fallback to HTTP long-polling if
the WebSocket connection cannot be established.

- use a distinct port for each worker, and a load-balancer like nginx in
  front of them

- use @socket.io/pm2

Installation​

    npm install -g @socket.io/pm2

[][]

If pm2 is already installed, you will have to remove it first:

    npm remove -g pm2

[][]

@socket.io/pm2 can be used as a drop-in replacement for pm2, and
supports all the commands of the class pm2 utility.

The only difference comes from this commit.

Usage​

worker.js

    const { createServer } = require("http");
    const { Server } = require("socket.io");
    const { createAdapter } = require("@socket.io/cluster-adapter");
    const { setupWorker } = require("@socket.io/sticky");

    const httpServer = createServer();
    const io = new Server(httpServer);

    io.adapter(createAdapter());

    setupWorker(io);

    io.on("connection", (socket) => {
      console.log(`connect ${socket.id}`);
    });

[][]

ecosystem.config.js

    module.exports = {
      apps : [{
        script    : "worker.js",
        instances : "max",
        exec_mode : "cluster"
      }]
    }

[][]

And then run pm2 start ecosystem.config.js (or
pm2 start worker.js -i 0). That's it! You can now reach the Socket.IO
cluster on port 8080.

How it works​

When scaling to multiple nodes, there are two things to do:

- enable sticky sessions, so that the HTTP requests of a Socket.IO
  session are routed to the same worker
- use a custom adapter, so that the packets are broadcast to all
  clients, even if they are connected to another worker

In order to achieve this, @socket.io/pm2 includes two additional
packages:

- @socket.io/sticky
- @socket.io/cluster-adapter

The only difference with pm2 comes from this commit:

- the God process now creates its own HTTP server and routes the HTTP
  requests to the right worker
- the God process also relays the packets between the workers, so that
  io.emit() correctly reaches all clients

Please note that if you have several hosts each running a PM2 cluster,
you will have to use another adapter, like the Redis adapter.

The source code of the fork can be found here. We will try to closely
follow the releases of the pm2 package.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Admin UI

Next

Load testing

- Installation
- Usage
- How it works

=============

## doc_docs_v4_redis-adapter_.txt

- []
- Adapters
- Redis adapter

Version: 4.x

On this page

Redis adapter

How it works​

The Redis adapter relies on the Redis Pub/Sub mechanism.

Every packet that is sent to multiple clients (e.g.
io.to("room1").emit() or socket.broadcast.emit()) is:

- sent to all matching clients connected to the current server
- published in a Redis channel, and received by the other Socket.IO
  servers of the cluster

[Diagram of how the Redis adapter works][Diagram of how the Redis
adapter works]

The source code of this adapter can be found here.

Supported features​

  Feature                           socket.io version   Support
  --------------------------------- ------------------- ------------------------------
  Socket management                 4.0.0               ✅ YES (since version 6.1.0)
  Inter-server communication        4.1.0               ✅ YES (since version 7.0.0)
  Broadcast with acknowledgements   4.5.0               ✅ YES (since version 7.2.0)
  Connection state recovery         4.6.0               ❌ NO

Installation​

    npm install @socket.io/redis-adapter

[][]

Compatibility table​

  Redis Adapter version   Socket.IO server version
  ----------------------- --------------------------
  4.x                     1.x
  5.x                     2.x
  6.0.x                   3.x
  6.1.x                   4.x
  7.x and above           4.3.1 and above

Usage​

[]tip

For new developments, we recommend using the sharded adapter, which
takes advantage of the sharded Pub/Sub feature introduced in Redis 7.0.

With the redis package​

[]caution

The redis package seems to have problems restoring the Redis
subscriptions after reconnection:

- https://github.com/redis/node-redis/issues/2155
- https://github.com/redis/node-redis/issues/1252

You may want to use the ioredis package instead.

    import { createClient } from "redis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";

    const pubClient = createClient({ url: "redis://localhost:6379" });
    const subClient = pubClient.duplicate();

    await Promise.all([
      pubClient.connect(),
      subClient.connect()
    ]);

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

With the redis package and a Redis cluster​

    import { createCluster } from "redis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";

    const pubClient = createCluster({
      rootNodes: [
        {
          url: "redis://localhost:7000",
        },
        {
          url: "redis://localhost:7001",
        },
        {
          url: "redis://localhost:7002",
        },
      ],
    });
    const subClient = pubClient.duplicate();

    await Promise.all([
      pubClient.connect(),
      subClient.connect()
    ]);

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

With the ioredis package​

    import { Redis } from "ioredis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";

    const pubClient = new Redis();
    const subClient = pubClient.duplicate();

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

With the ioredis package and a Redis cluster​

    import { Cluster } from "ioredis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";

    const pubClient = new Cluster([
      {
        host: "localhost",
        port: 7000,
      },
      {
        host: "localhost",
        port: 7001,
      },
      {
        host: "localhost",
        port: 7002,
      },
    ]);
    const subClient = pubClient.duplicate();

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

With Redis sharded Pub/Sub​

Sharded Pub/Sub was introduced in Redis 7.0 in order to help scaling the
usage of Pub/Sub in cluster mode.

Reference: https://redis.io/docs/interact/pubsub/#sharded-pubsub

A dedicated adapter can be created with the createShardedAdapter()
method:

    import { Server } from "socket.io";
    import { createClient } from "redis";
    import { createShardedAdapter } from "@socket.io/redis-adapter";

    const pubClient = createClient({ host: "localhost", port: 6379 });
    const subClient = pubClient.duplicate();

    await Promise.all([
      pubClient.connect(),
      subClient.connect()
    ]);

    const io = new Server({
      adapter: createShardedAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

Minimum requirements:

- Redis 7.0
- redis@4.6.0

[]caution

It is not currently possible to use the sharded adapter with the ioredis
package and a Redis cluster (reference).

Options​

Default adapter​

  Name                               Description                                                                     Default value
  ---------------------------------- ------------------------------------------------------------------------------- ---------------
  key                                The prefix for the Redis Pub/Sub channels.                                      socket.io
  requestsTimeout                    After this timeout the adapter will stop waiting from responses to request.     5_000
  publishOnSpecificResponseChannel   Whether to publish a response to the channel specific to the requesting node.   false
  parser                             The parser to use for encoding and decoding messages sent to Redis.             -

[]tip

Setting the publishOnSpecificResponseChannel option to true is more
efficient since the responses (for example when calling fetchSockets()
or serverSideEmit()) are only sent to the requesting server, and not to
all the servers.

However, it currently defaults to false for backward-compatibility.

Sharded adapter​

  Name               Description                                                                               Default value
  ------------------ ----------------------------------------------------------------------------------------- ---------------
  channelPrefix      The prefix for the Redis Pub/Sub channels.                                                socket.io
  subscriptionMode   The subscription mode impacts the number of Redis Pub/Sub channels used by the adapter.   dynamic

Available values for the subscriptionMode option:

  Value               # of Pub/Sub channels                   Description
  ------------------- --------------------------------------- -----------------------------------------------------------------------------------------------------------------------------------------------
  static              2 per namespace                         Useful when used with dynamic namespaces.
  dynamic (default)   (2 + 1 per public room) per namespace   Useful when some rooms have a low number of clients (so only a few Socket.IO servers are notified).
  dynamic-private     (2 + 1 per room) per namespace          Like dynamic but creates separate channels for private rooms as well. Useful when there is lots of 1:1 communication via socket.emit() calls.

Common questions​

Is there any data stored in Redis?​

No, the Redis adapter uses the Pub/Sub mechanism to forward the packets
between the Socket.IO servers, so there are no keys stored in Redis.

Do I still need to enable sticky sessions when using the Redis adapter?​

Yes. Failing to do so will result in HTTP 400 responses (you are
reaching a server that is not aware of the Socket.IO session).

More information can be found here.

What happens when the Redis server is down?​

In case the connection to the Redis server is severed, the packets will
only be sent to the clients that are connected to the current server.

Migrating from socket.io-redis​

The package was renamed from socket.io-redis to @socket.io/redis-adapter
in v7, in order to match the name of the Redis emitter
(@socket.io/redis-emitter).

To migrate to the new package, you'll need to make sure to provide your
own Redis clients, as the package will no longer create Redis clients on
behalf of the user.

Before:

    const redisAdapter = require("socket.io-redis");

    io.adapter(redisAdapter({ host: "localhost", port: 6379 }));

[][]

After:

    const { createClient } = require("redis");
    const { createAdapter } = require("@socket.io/redis-adapter");

    const pubClient = createClient({ url: "redis://localhost:6379" });
    const subClient = pubClient.duplicate();

    io.adapter(createAdapter(pubClient, subClient));

[][]

[]tip

The communication protocol between the Socket.IO servers has not been
updated, so you can have some servers with socket.io-redis and some
others with @socket.io/redis-adapter at the same time.

Latest releases​

  Version   Release date    Release notes   Diff
  --------- --------------- --------------- ---------------
  8.3.0     March 2024      link            8.2.1...8.3.0
  8.2.1     May 2023        link            8.2.0...8.2.1
  8.2.0     May 2023        link            8.1.0...8.2.0
  8.1.0     February 2023   link            8.0.0...8.1.0
  8.0.0     December 2022   link            7.2.0...8.0.0
  7.2.0     May 2022        link            7.1.0...7.2.0

Complete changelog

Emitter​

The Redis emitter allows sending packets to the connected clients from
another Node.js process:

[Diagram of how the Redis emitter works][Diagram of how the Redis
emitter works]

This emitter is also available in several languages:

- Javascript: https://github.com/socketio/socket.io-redis-emitter
- Java: https://github.com/sunsus/socket.io-java-emitter
- Python: https://pypi.org/project/socket.io-emitter/
- PHP: https://github.com/rase-/socket.io-php-emitter
- Golang: https://github.com/yosuke-furukawa/socket.io-go-emitter
- Perl: https://metacpan.org/pod/SocketIO::Emitter
- Rust: https://github.com/epli2/socketio-rust-emitter

Installation​

    npm install @socket.io/redis-emitter redis

[][]

Usage​

    import { Emitter } from "@socket.io/redis-emitter";
    import { createClient } from "redis";

    const redisClient = createClient({ url: "redis://localhost:6379" });

    redisClient.connect().then(() => {
      const emitter = new Emitter(redisClient);

      setInterval(() => {
        emitter.emit("time", new Date);
      }, 5000);
    });

[][]

Note: with redis@3, calling connect() on the Redis client is not needed:

    import { Emitter } from "@socket.io/redis-emitter";
    import { createClient } from "redis";

    const redisClient = createClient({ url: "redis://localhost:6379" });
    const emitter = new Emitter(redisClient);

    setInterval(() => {
      emitter.emit("time", new Date);
    }, 5000);

[][]

Please refer to the cheatsheet here.

Migrating from socket.io-emitter​

The package was renamed from socket.io-emitter to
@socket.io/redis-emitter in v4, in order to better reflect the
relationship with Redis.

To migrate to the new package, you'll need to make sure to provide your
own Redis clients, as the package will no longer create Redis clients on
behalf of the user.

Before:

    const io = require("socket.io-emitter")({ host: "127.0.0.1", port: 6379 });

[][]

After:

    const { Emitter } = require("@socket.io/redis-emitter");
    const { createClient } = require("redis");

    const redisClient = createClient();
    const io = new Emitter(redisClient);

[][]

Latest releases​

  Version   Release date     Release notes   Diff
  --------- ---------------- --------------- ---------------
  5.1.0     January 2023     link            5.0.0...5.1.0
  5.0.0     September 2022   link            4.1.1...5.0.0
  4.1.1     January 2022     link            4.1.0...4.1.1
  4.1.0     May 2021         link            4.0.0...4.1.0
  4.0.0     March 2021       link            3.2.0...4.0.0

Complete changelog

[]Edit this page

Last updated on Mar 28, 2025

Previous

Introduction

Next

Redis Streams adapter

- How it works
- Supported features
- Installation
- Compatibility table
- Usage
  - With the redis package
  - With the redis package and a Redis cluster
  - With the ioredis package
  - With the ioredis package and a Redis cluster
  - With Redis sharded Pub/Sub
- Options
  - Default adapter
  - Sharded adapter
- Common questions
  - Is there any data stored in Redis?
  - Do I still need to enable sticky sessions when using the Redis
    adapter?
  - What happens when the Redis server is down?
- Migrating from socket.io-redis
- Latest releases
- Emitter
  - Installation
  - Usage
  - Migrating from socket.io-emitter
  - Latest releases

=============

## doc_docs_v4_redis-streams-adapter_.txt

- []
- Adapters
- Redis Streams adapter

Version: 4.x

On this page

Redis Streams adapter

How it works​

The adapter will use a Redis stream to forward packets between the
Socket.IO servers.

The main difference with the existing Redis adapter (which use the Redis
Pub/Sub mechanism) is that this adapter will properly handle any
temporary disconnection to the Redis server and resume the stream
without losing any packets.

[]info

- a single stream is used for all namespaces
- the maxLen option allows to limit the size of the stream
- unlike the adapter based on Redis PUB/SUB mechanism, this adapter will
  properly handle any temporary disconnection to the Redis server and
  resume the stream
- if connection state recovery is enabled, the sessions will be stored
  in Redis as a classic key/value pair

[]tip

This adapter is also compatible with Valkey.

Source code: https://github.com/socketio/socket.io-redis-streams-adapter

Supported features​

  Feature                           socket.io version   Support
  --------------------------------- ------------------- ------------------------------
  Socket management                 4.0.0               ✅ YES (since version 0.1.0)
  Inter-server communication        4.1.0               ✅ YES (since version 0.1.0)
  Broadcast with acknowledgements   4.5.0               ✅ YES (since version 0.1.0)
  Connection state recovery         4.6.0               ✅ YES (since version 0.1.0)

Installation​

    npm install @socket.io/redis-streams-adapter redis

[][]

Usage​

With the redis package​

    import { createClient } from "redis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-streams-adapter";

    const redisClient = createClient({ url: "redis://localhost:6379" });

    await redisClient.connect();

    const io = new Server({
      adapter: createAdapter(redisClient)
    });

    io.listen(3000);

[][]

With the redis package and a Redis cluster​

    import { createCluster } from "redis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-streams-adapter";

    const redisClient = createCluster({
      rootNodes: [
        {
          url: "redis://localhost:7000",
        },
        {
          url: "redis://localhost:7001",
        },
        {
          url: "redis://localhost:7002",
        },
      ],
    });

    await redisClient.connect();

    const io = new Server({
      adapter: createAdapter(redisClient)
    });

    io.listen(3000);

[][]

With the ioredis package​

    import { Redis } from "ioredis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-streams-adapter";

    const redisClient = new Redis();

    const io = new Server({
      adapter: createAdapter(redisClient)
    });

    io.listen(3000);

[][]

With the ioredis package and a Redis cluster​

    import { Cluster } from "ioredis";
    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-streams-adapter";

    const redisClient = new Cluster([
      {
        host: "localhost",
        port: 7000,
      },
      {
        host: "localhost",
        port: 7001,
      },
      {
        host: "localhost",
        port: 7002,
      },
    ]);

    const io = new Server({
      adapter: createAdapter(redisClient)
    });

    io.listen(3000);

[][]

Options​

  Name                Description                                                                                                         Default value
  ------------------- ------------------------------------------------------------------------------------------------------------------- ---------------
  streamName          The name of the Redis stream.                                                                                       socket.io
  maxLen              The maximum size of the stream. Almost exact trimming (~) is used.                                                  10_000
  readCount           The number of elements to fetch per XREAD call.                                                                     100
  sessionKeyPrefix    The prefix of the key used to store the Socket.IO session, when the connection state recovery feature is enabled.   sio:session:
  heartbeatInterval   The number of ms between two heartbeats.                                                                            5_000
  heartbeatTimeout    The number of ms without heartbeat before we consider a node down.                                                  10_000

Common questions​

Do I still need to enable sticky sessions when using the Redis Streams adapter?​

Yes. Failing to do so will result in HTTP 400 responses (you are
reaching a server that is not aware of the Socket.IO session).

More information can be found here.

What happens when the Redis server is down?​

Unlike the classic Redis adapter, this adapter will properly handle any
temporary disconnection to the Redis server and resume the stream
without losing any packets.

Latest releases​

  Version   Release date    Release notes   Diff
  --------- --------------- --------------- ---------------
  0.2.2     May 2024        link            0.2.1...0.2.2
  0.2.1     March 2024      link            0.2.0...0.2.1
  0.2.0     February 2024   link            0.1.0...0.2.0
  0.1.0     April 2023      link            

Complete changelog

[]Edit this page

Last updated on Mar 28, 2025

Previous

Redis adapter

Next

MongoDB adapter

- How it works
- Supported features
- Installation
- Usage
  - With the redis package
  - With the redis package and a Redis cluster
  - With the ioredis package
  - With the ioredis package and a Redis cluster
- Options
- Common questions
  - Do I still need to enable sticky sessions when using the Redis
    Streams adapter?
  - What happens when the Redis server is down?
- Latest releases

=============

## doc_docs_v4_reverse-proxy_.txt

- []
- Server
- Behind a reverse proxy

Version: 4.x

On this page

Behind a reverse proxy

You will find below the configuration needed for deploying a Socket.IO
server behind a reverse-proxy solution, such as:

- nginx
- Apache HTTPD
- Node.js http-proxy
- Caddy 2

In a multi-server setup, please check the documentation here.

nginx​

Content of /etc/nginx/nginx.conf:

    http {
      server {
        listen 80;

        location / {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $host;

          proxy_pass http://localhost:3000;

          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
        }
      }
    }

[][]

Related:

- proxy_pass documentation
- configuration in a multi-server setup

[]caution

The value of nginx's proxy_read_timeout (60 seconds by default) must be
bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by
default), else nginx will forcefully close the connection if no data is
sent after the given delay and the client will get a "transport close"
error.

If you only want to forward the Socket.IO requests (for example when
nginx handles the static content):

    http {
      server {
        listen 80;
        root /var/www/html;

        location /socket.io/ {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $host;

          proxy_pass http://localhost:3000;

          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
        }
      }
    }

[][]

Or with a custom path:

    http {
      server {
        listen 80;
        root /var/www/html;

        location /my-custom-path/ {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $host;

          proxy_pass http://localhost:3000;

          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
        }
      }
    }

[][]

In that case, the server and the client must be configured accordingly:

Server

    import { Server } from "socket.io";

    const io = new Server({
      path: "/my-custom-path/"
    });

[][]

Client

    import { io } from "socket.io-client";

    const socket = io({
      path: "/my-custom-path/"
    });

[][]

Apache HTTPD​

Content of /usr/local/apache2/conf/httpd.conf:

    Listen 80

    ServerName example.com

    LoadModule mpm_event_module             modules/mod_mpm_event.so

    LoadModule authn_file_module            modules/mod_authn_file.so
    LoadModule authn_core_module            modules/mod_authn_core.so
    LoadModule authz_host_module            modules/mod_authz_host.so
    LoadModule authz_groupfile_module       modules/mod_authz_groupfile.so
    LoadModule authz_user_module            modules/mod_authz_user.so
    LoadModule authz_core_module            modules/mod_authz_core.so

    LoadModule headers_module               modules/mod_headers.so
    LoadModule lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.so
    LoadModule proxy_module                 modules/mod_proxy.so
    LoadModule proxy_balancer_module        modules/mod_proxy_balancer.so
    LoadModule proxy_http_module            modules/mod_proxy_http.so
    LoadModule proxy_wstunnel_module        modules/mod_proxy_wstunnel.so
    LoadModule rewrite_module               modules/mod_rewrite.so
    LoadModule slotmem_shm_module           modules/mod_slotmem_shm.so
    LoadModule unixd_module                 modules/mod_unixd.so

    User daemon
    Group daemon

    ProxyPass / http://localhost:3000/
    RewriteEngine on
    RewriteCond %{HTTP:Upgrade} websocket [NC]
    RewriteCond %{HTTP:Connection} upgrade [NC]
    RewriteRule ^/?(.*) "ws://localhost:3000/$1" [P,L]

    # must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)
    ProxyTimeout 60

[][]

Related:

- mod_proxy_wstunnel documentation
- configuration in a multi-server setup

Node.js http-proxy​

Installation: npm i http-proxy

    const httpProxy = require("http-proxy");

    httpProxy
      .createProxyServer({
        target: "http://localhost:3000",
        ws: true,
      })
      .listen(80);

[][]

Documentation

Caddy 2​

Content of Caddyfile for Caddy 2, if you only want to forward the
Socket.IO requests

    example.com {
        reverse_proxy /socket.io/* localhost:3000
    }

[][]

Or, if you want a custom path:

    example.com {
      rewrite /path /path/
      handle_path /path/* {
        rewrite * /socket.io{path}
        reverse_proxy localhost:3000
      }
    }

[][]

Related

- Solution forum post
- Caddyfile reverse proxy
- Caddyfile directives

[]Edit this page

Last updated on Mar 28, 2025

Previous

Middlewares

Next

Using multiple nodes

- nginx
- Apache HTTPD
- Node.js http-proxy
- Caddy 2

=============

## doc_docs_v4_server-api_.txt

- []
- API

Version: 4.x

On this page

Server API

Server​

[Server in the class diagram for the server][Server in the class diagram
for the server]

Related documentation pages:

- installation
- initialization
- details of the server instance

Constructor​

new Server(httpServer[, options])​

- httpServer <http.Server> | <https.Server>
- options <Object>

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      // options
    });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

The complete list of available options can be found here.

new Server(port[, options])​

- port <number>
- options <Object>

    import { Server } from "socket.io";

    const io = new Server(3000, {
      // options
    });

    io.on("connection", (socket) => {
      // ...
    });

[][]

The complete list of available options can be found here.

new Server(options)​

- options <Object>

    import { Server } from "socket.io";

    const io = new Server({
      // options
    });

    io.on("connection", (socket) => {
      // ...
    });

    io.listen(3000);

[][]

The complete list of available options can be found here.

Events​

Event: 'connect'​

Synonym of Event: "connection".

Event: 'connection'​

- socket (Socket) socket connection with client

Fired upon a connection from client.

    io.on("connection", (socket) => {
      // ...
    });

[][]

Event: 'new_namespace'​

- namespace Namespace

Fired when a new namespace is created:

    io.on("new_namespace", (namespace) => {
      // ...
    });

[][]

This can be useful for example:

- to attach a shared middleware to each namespace

    io.on("new_namespace", (namespace) => {
      namespace.use(myMiddleware);
    });

[][]

- to track the dynamically created namespaces

    io.of(/\/nsp-\w+/);

    io.on("new_namespace", (namespace) => {
      console.log(namespace.name);
    });

[][]

Attributes​

server.engine​

A reference to the underlying Engine.IO server. See here.

server.sockets​

- <Namespace>

An alias for the main namespace (/).

    io.sockets.emit("hi", "everyone");
    // is equivalent to
    io.of("/").emit("hi", "everyone");

[][]

Methods​

server.adapter([value])​

- value <Adapter>
- Returns <Server> | <Adapter>

Sets the adapter value. Defaults to an instance of the Adapter that
ships with socket.io which is memory based. See socket.io-adapter. If no
arguments are supplied this method returns the current value.

    import { Server } from "socket.io"; 
    import { createAdapter } from "@socket.io/redis-adapter";
    import { createClient } from "redis";

    const io = new Server();

    const pubClient = createClient({ host: "localhost", port: 6379 });
    const subClient = pubClient.duplicate();

    io.adapter(createAdapter(pubClient, subClient));

    // redis@3
    io.listen(3000);

    // redis@4
    Promise.all([pubClient.connect(), subClient.connect()]).then(() => {
      io.listen(3000);
    });

[][]

server.attach(httpServer[, options])​

- httpServer <http.Server> | <https.Server>
- options <Object>

Attaches the Server to an httpServer with the supplied options.

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server();

    io.attach(httpServer);

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

server.attach(port[, options])​

- port <number>
- options <Object>

Attaches the Server on the given port with the supplied options.

    import { Server } from "socket.io";

    const io = new Server();

    io.attach(3000);

    io.on("connection", (socket) => {
      // ...
    });

[][]

server.attachApp(app[, options])​

- app <uws.App>
- options <Object>

Attaches the Socket.IO server to an µWebSockets.js app:

    import { App } from "uWebSockets.js";
    import { Server } from "socket.io";

    const app = App();
    const io = new Server();

    io.attachApp(app);

    io.on("connection", (socket) => {
      // ...
    });

    app.listen(3000, (token) => {
      if (!token) {
        console.warn("port already in use");
      }
    });

[][]

server.bind(engine)​

- engine <engine.Server>
- Returns <Server>

Advanced use only. Binds the server to a specific engine.io Server (or
compatible API) instance.

    import { createServer } from "node:http";
    import { Server as Engine } from "engine.io";
    import { Server } from "socket.io";

    const httpServer = createServer((req, res) => {
      res.writeHead(404).end();
    });

    const engine = new Engine();

    engine.attach(httpServer, {
      path: "/socket.io/"
    });

    const io = new Server();

    io.bind(engine);

    httpServer.listen(3000);

[][]

server.close([callback])​

- callback <Function>

Closes the Socket.IO server and disconnect all clients. The callback
argument is optional and will be called when all connections are closed.

[]info

This also closes the underlying HTTP server.

    import { createServer } from "http";
    import { Server } from "socket.io";

    const PORT = 3030;
    const io = new Server(PORT);

    io.close();

    const httpServer = createServer();

    httpServer.listen(PORT); // PORT is free to use

    io.attach(httpServer);

[][]

[]note

Only closing the underlying HTTP server is not sufficient, as it will
only prevent the server from accepting new connections but clients
connected with WebSocket will not be disconnected right away.

Reference: https://nodejs.org/api/http.html#serverclosecallback

server.disconnectSockets([close])​

Added in v4.0.0

Alias for io.of("/").disconnectSockets(close).

    // make all Socket instances disconnect
    io.disconnectSockets();

    // make all Socket instances in the "room1" room disconnect (and close the low-level connection)
    io.in("room1").disconnectSockets(true);

[][]

[]tip

This method also works within a cluster of multiple Socket.IO servers,
with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the
given node, you need to use the local flag:

    // make all Socket instances that are currently connected on the given node disconnect
    io.local.disconnectSockets();

[][]

See here.

server.emit(eventName[, ...args])​

History

  Version   Changes
  --------- ------------------------------------------
  v4.5.0    io.emit() now supports acknowledgements.
  v1.0.0    Initial implementation.

- eventName <string> | <symbol>
- args any[]
- Returns true

Emits an event to all connected clients in the main namespace.

    io.emit("hello");

[][]

Any number of parameters can be included, and all serializable data
structures are supported:

    io.emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));

[][]

And on the receiving side:

    socket.on("hello", (arg1, arg2, arg3, arg4) => {
      console.log(arg1); // 1
      console.log(arg2); // "2"
      console.log(arg3); // { "3": 4 }
      console.log(arg4); // ArrayBuffer or Buffer, depending on the platform
    });

[][]

[]info

The arguments will automatically be serialized, so calling
JSON.stringify() is not needed.

You can use to() and except() to send the packet to specific clients:

    // the “hello” event will be broadcast to all connected clients that are either
    // in the "room1" room or in the "room2" room, excluding those in the "room3" room
    io.to("room1").to("room2").except("room3").emit("hello");

[][]

Starting with version 4.5.0, it is now possible to use acknowledgements
when broadcasting:

    io.timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

[]caution

Calling timeout() is mandatory in that case.

server.emitWithAck(eventName[, ...args])​

Added in v4.6.0

- eventName <string> | <symbol>
- args any[]
- Returns Promise<any[]>

Promised-based version of broadcasting and expecting an acknowledgement
from all targeted clients:

    try {
      const responses = await io.timeout(10000).emitWithAck("some-event");
      console.log(responses); // one response per client
    } catch (e) {
      // some clients did not acknowledge the event in the given delay
    }

[][]

The example above is equivalent to:

    io.timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

And on the receiving side:

    socket.on("some-event", (callback) => {
      callback("got it"); // only one argument is expected
    });

[][]

server.except(rooms)​

Added in v4.0.0

- rooms <string> | <string[]>
- Returns BroadcastOperator

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have not joined the given rooms.

    // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
    io.except("room-101").emit("foo", "bar");

    // with an array of rooms
    io.except(["room-101", "room-102"]).emit("foo", "bar");

    // with multiple chained calls
    io.except("room-101").except("room-102").emit("foo", "bar");

[][]

server.fetchSockets()​

Added in v4.0.0

Alias for io.of("/").fetchSocket().

    // return all Socket instances of the main namespace
    const sockets = await io.fetchSockets();

    // return all Socket instances in the "room1" room of the main namespace
    const sockets = await io.in("room1").fetchSockets();

[][]

Sample usage:

    io.on("connection", (socket) => {
      const userId = computeUserId(socket);

      socket.join(userId);

      socket.on("disconnect", async () => {
        const sockets = await io.in(userId).fetchSockets();
        if (sockets.length === 0) {
          // no more active connections for the given user
        }
      });
    });

[][]

[]tip

This method also works within a cluster of multiple Socket.IO servers,
with a compatible adapter like the Postgres adapter.

In that case, if you only want to return the socket instances on the
given node, you need to use the local flag:

    // return all Socket instances that are currently connected on the given node
    const sockets = await io.local.fetchSockets();

[][]

See here.

server.in(room)​

Added in v1.0.0

Synonym of server.to(room), but might feel clearer in some cases:

    // disconnect all clients in the "room-101" room
    io.in("room-101").disconnectSockets();

[][]

server.listen(httpServer[, options])​

Synonym of server.attach(httpServer[, options]).

server.listen(port[, options])​

Synonym of server.attach(port[, options]).

server.of(nsp)​

- nsp <string> | <RegExp> | <Function>
- Returns <Namespace>

Initializes and retrieves the given Namespace by its pathname identifier
nsp. If the namespace was already initialized it returns it immediately.

    const adminNamespace = io.of("/admin");

[][]

A regex or a function can also be provided, in order to create namespace
in a dynamic way:

    const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
      const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"

      // broadcast to all clients in the given sub-namespace
      newNamespace.emit("hello");
    });

    // client-side
    const socket = io("/dynamic-101");

    // broadcast to all clients in each sub-namespace
    dynamicNsp.emit("hello");

    // use a middleware for each sub-namespace
    dynamicNsp.use((socket, next) => { /* ... */ });

[][]

With a function:

    io.of((name, query, next) => {
      // the checkToken method must return a boolean, indicating whether the client is able to connect or not.
      next(null, checkToken(query.token));
    }).on("connection", (socket) => { /* ... */ });

[][]

server.on(eventName, listener)​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- listener <Function>
- Returns <Server>

Adds the listener function to the end of the listeners array for the
event named eventName.

Available events:

- connection
- new_namespace
- any custom event from the serverSideEmit method

    io.on("connection", (socket) => {
      // ...
    });

[][]

server.onconnection(socket)​

- socket <engine.Socket>
- Returns <Server>

Advanced use only. Creates a new socket.io client from the incoming
engine.io (or compatible API) Socket.

    import { Server } from "socket.io";
    import { Server as Engine } from "engine.io";

    const engine = new Engine();
    const io = new Server();

    engine.on("connection", (socket) => {
      io.onconnection(socket);
    });

    engine.listen(3000);

[][]

server.path([value])​

- value <string>
- Returns <Server> | <string>

Sets the path value under which engine.io and the static files will be
served. Defaults to /socket.io/. If no arguments are supplied this
method returns the current value.

    import { Server } from "socket.io";

    const io = new Server();

    io.path("/myownpath/");

[][]

[]danger

The path value must match the one on the client side:

    import { io } from "socket.io-client";

    const socket = io({
      path: "/myownpath/"
    });

[][]

server.serveClient([value])​

- value <boolean>
- Returns <Server> | <boolean>

If value is true the attached server will serve the client files.
Defaults to true. This method has no effect after listen is called. If
no arguments are supplied this method returns the current value.

    import { Server } from "socket.io";

    const io = new Server();

    io.serveClient(false);

    io.listen(3000);

[][]

server.serverSideEmit(eventName[, ...args][, ack])​

Added in v4.1.0

Alias for: io.of("/").serverSideEmit(/* ... */);

- eventName <string>
- args <any[]>
- ack <Function>
- Returns true

Sends a message to the other Socket.IO servers of the cluster.

Syntax:

    io.serverSideEmit("hello", "world");

[][]

And on the receiving side:

    io.on("hello", (arg1) => {
      console.log(arg1); // prints "world"
    });

[][]

Acknowledgements are supported too:

    // server A
    io.serverSideEmit("ping", (err, responses) => {
      console.log(responses[0]); // prints "pong"
    });

    // server B
    io.on("ping", (cb) => {
      cb("pong");
    });

[][]

Notes:

- the connection, connect and new_namespace strings are reserved and
  cannot be used in your application.

- you can send any number of arguments, but binary structures are
  currently not supported (the array of arguments will be
  JSON.stringify-ed)

Example:

    io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });

[][]

- the acknowledgement callback might be called with an error, if the
  other Socket.IO servers do not respond after a given delay

    io.serverSideEmit("ping", (err, responses) => {
      if (err) {
        // at least one Socket.IO server has not responded
        // the 'responses' array contains all the responses already received though
      } else {
        // success! the 'responses' array contains one object per other Socket.IO server in the cluster
      }
    });

[][]

server.serverSideEmitWithAck(eventName[, ...args])​

Added in v4.6.0

Alias for: io.of("/").serverSideEmitWithAck(/* ... */);

- eventName <string>
- args <any[]>
- ack <Function>
- Returns Promise<any[]>

Promised-based version of broadcasting and expecting an acknowledgement
from the other Socket.IO servers of the cluster.

    try {
      const responses = await io.serverSideEmitWithAck("some-event");
      console.log(responses); // one response per server (except itself)
    } catch (e) {
      // some servers did not acknowledge the event in the given delay
    }

[][]

The example above is equivalent to:

    io.serverSideEmit("some-event", (err, responses) => {
      if (err) {
        // some servers did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per server (except itself)
      }
    });

[][]

And on the receiving side:

    io.on("some-event", (callback) => {
      callback("got it"); // only one argument is expected
    });

[][]

server.socketsJoin(rooms)​

Added in v4.0.0

Alias for io.of("/").socketsJoin(rooms).

    // make all Socket instances join the "room1" room
    io.socketsJoin("room1");

    // make all Socket instances in the "room1" room join the "room2" and "room3" rooms
    io.in("room1").socketsJoin(["room2", "room3"]);

    // this also works with a single socket ID
    io.in(theSocketId).socketsJoin("room1");

[][]

[]tip

This method also works within a cluster of multiple Socket.IO servers,
with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the
given node, you need to use the local flag:

    // make all Socket instances that are currently connected on the given node join the "room1" room
    io.local.socketsJoin("room1");

[][]

See here.

server.socketsLeave(rooms)​

Added in v4.0.0

Alias for io.of("/").socketsLeave(rooms).

    // make all Socket instances leave the "room1" room
    io.socketsLeave("room1");

    // make all Socket instances in the "room1" room leave the "room2" and "room3" rooms
    io.in("room1").socketsLeave(["room2", "room3"]);

    // this also works with a single socket ID
    io.in(theSocketId).socketsLeave("room1");

[][]

[]tip

This method also works within a cluster of multiple Socket.IO servers,
with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the
given node, you need to use the local flag:

    // make all Socket instances that are currently connected on the given node leave the "room1" room
    io.local.socketsLeave("room1");

[][]

See here.

server.timeout(value)​

Added in v4.5.0

- value <number>
- Returns BroadcastOperator

Sets a modifier for a subsequent event emission that the callback will
be called with an error when the given number of milliseconds have
elapsed without an acknowledgement from all targeted clients:

    io.timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

server.to(room)​

History

  Version   Changes
  --------- ----------------------------------
  v4.0.0    Allow to pass an array of rooms.
  v1.0.0    Initial implementation.

- room <string> | <string[]>
- Returns BroadcastOperator for chaining

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

    // the “foo” event will be broadcast to all connected clients in the “room-101” room
    io.to("room-101").emit("foo", "bar");

    // with an array of rooms (a client will be notified at most once)
    io.to(["room-101", "room-102"]).emit("foo", "bar");

    // with multiple chained calls
    io.to("room-101").to("room-102").emit("foo", "bar");

[][]

server.use(fn)​

Added in v1.0.0

Alias for io.of("/").use(fn).

- fn <Function>

Registers a middleware for the main namespace, which is a function that
gets executed for every incoming Socket, and receives as parameters the
socket and a function to optionally defer execution to the next
registered middleware.

Errors passed to middleware callbacks are sent as special connect_error
packets to clients.

Server

    io.use((socket, next) => {
      const err = new Error("not authorized");
      err.data = { content: "Please retry later" }; // additional details
      next(err);
    });

[][]

Client

    socket.on("connect_error", err => {
      console.log(err instanceof Error); // true
      console.log(err.message); // not authorized
      console.log(err.data); // { content: "Please retry later" }
    });

[][]

More information can be found here.

[]info

If you are looking for Express middlewares, please check this section.

Namespace​

[Namespace in the class diagram for the server][Namespace in the class
diagram for the server]

Represents a pool of sockets connected under a given scope identified by
a pathname (eg: /chat).

More information can be found here.

Attributes​

namespace.adapter​

- <Adapter>

The "Adapter" used for the namespace.

Note: the adapter of the main namespace can be accessed with
io.of("/").adapter.

More information about it here.

    const adapter = io.of("/my-namespace").adapter;

[][]

namespace.name​

- <string>

The namespace identifier property.

namespace.sockets​

- Map<SocketId, Socket>

A map of Socket instances that are connected to this namespace.

    // number of sockets in this namespace (on this node)
    const socketCount = io.of("/admin").sockets.size;

[][]

Events​

Event: 'connect'​

Synonym of Event: "connection".

Event: 'connection'​

- socket <Socket>

Fired upon a connection from client.

    // main namespace
    io.on("connection", (socket) => {
      // ...
    });

    // custom namespace
    io.of("/admin").on("connection", (socket) => {
      // ...
    });

[][]

Methods​

namespace.allSockets()​

- Returns Promise<Set<SocketId>>

[]caution

This method will be removed in the next major release, please use
serverSideEmit() or fetchSockets() instead.

Gets a list of socket IDs connected to this namespace (across all nodes
if applicable).

    // all sockets in the main namespace
    const ids = await io.allSockets();

    // all sockets in the main namespace and in the "user:1234" room
    const ids = await io.in("user:1234").allSockets();

    // all sockets in the "chat" namespace
    const ids = await io.of("/chat").allSockets();

    // all sockets in the "chat" namespace and in the "general" room
    const ids = await io.of("/chat").in("general").allSockets();

[][]

namespace.disconnectSockets([close])​

Added in v4.0.0

- close <boolean> whether to close the underlying connection
- Returns void

Makes the matching Socket instances disconnect.

    // make all Socket instances disconnect
    io.disconnectSockets();

    // make all Socket instances in the "room1" room disconnect (and discard the low-level connection)
    io.in("room1").disconnectSockets(true);

    // make all Socket instances in the "room1" room of the "admin" namespace disconnect
    io.of("/admin").in("room1").disconnectSockets();

    // this also works with a single socket ID
    io.of("/admin").in(theSocketId).disconnectSockets();

[][]

namespace.emit(eventName[, ...args])​

History

  Version   Changes
  --------- ------------------------------------------
  v4.5.0    io.emit() now supports acknowledgements.
  v1.0.0    Initial implementation.

- eventName <string> | <symbol>
- args any[]
- Returns true

Emits an event to all connected clients in the given namespace.

    io.of("/chat").emit("hello");

[][]

Any number of parameters can be included, and all serializable data
structures are supported:

    io.of("/chat").emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));

[][]

And on the receiving side:

    socket.on("hello", (arg1, arg2, arg3, arg4) => {
      console.log(arg1); // 1
      console.log(arg2); // "2"
      console.log(arg3); // { "3": 4 }
      console.log(arg4); // ArrayBuffer or Buffer, depending on the platform
    });

[][]

[]info

The arguments will automatically be serialized, so calling
JSON.stringify() is not needed.

You can use to() and except() to send the packet to specific clients:

    // the “hello” event will be broadcast to all connected clients that are either
    // in the "room1" room or in the "room2" room, excluding those in the "room3" room
    io.of("/chat").to("room1").to("room2").except("room3").emit("hello");

[][]

Starting with version 4.5.0, it is now possible to use acknowledgements
when broadcasting:

    io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

[]caution

Calling timeout() is mandatory in that case.

namespace.emitWithAck(eventName[, ...args])​

Added in v4.6.0

- eventName <string> | <symbol>
- args any[]
- Returns Promise<any[]>

Promised-based version of broadcasting and expecting an acknowledgement
from all targeted clients in the given namespace:

    try {
      const responses = await io.of("/chat").timeout(10000).emitWithAck("some-event");
      console.log(responses); // one response per client
    } catch (e) {
      // some clients did not acknowledge the event in the given delay
    }

[][]

The example above is equivalent to:

    io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

And on the receiving side:

    socket.on("some-event", (callback) => {
      callback("got it"); // only one argument is expected
    });

[][]

namespace.except(rooms)​

Added in v4.0.0

- rooms <string> | <string[]>
- Returns BroadcastOperator

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have not joined the given rooms.

    const myNamespace = io.of("/my-namespace");

    // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
    myNamespace.except("room-101").emit("foo", "bar");

    // with an array of rooms
    myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");

    // with multiple chained calls
    myNamespace.except("room-101").except("room-102").emit("foo", "bar");

[][]

namespace.fetchSockets()​

Added in v4.0.0

- Returns Socket[] | RemoteSocket[]

Returns the matching Socket instances:

    // return all Socket instances in the main namespace
    const sockets = await io.fetchSockets();

    // return all Socket instances in the "room1" room of the main namespace
    const sockets = await io.in("room1").fetchSockets();

    // return all Socket instances in the "room1" room of the "admin" namespace
    const sockets = await io.of("/admin").in("room1").fetchSockets();

    // this also works with a single socket ID
    const sockets = await io.in(theSocketId).fetchSockets();

[][]

The sockets variable in the example above is an array of objects
exposing a subset of the usual Socket class:

    for (const socket of sockets) {
      console.log(socket.id);
      console.log(socket.handshake);
      console.log(socket.rooms);
      console.log(socket.data);
      socket.emit(/* ... */);
      socket.join(/* ... */);
      socket.leave(/* ... */);
      socket.disconnect(/* ... */);
    }

[][]

The data attribute is an arbitrary object that can be used to share
information between Socket.IO servers:

    // server A
    io.on("connection", (socket) => {
      socket.data.username = "alice";
    });

    // server B
    const sockets = await io.fetchSockets();
    console.log(sockets[0].data.username); // "alice"

[][]

Important note: this method (and socketsJoin, socketsLeave and
disconnectSockets too) is compatible with the Redis adapter (starting
with socket.io-redis@6.1.0), which means that they will work across
Socket.IO servers.

namespace.in(room)​

Added in v1.0.0

Synonym of namespace.to(room), but might feel clearer in some cases:

    const myNamespace = io.of("/my-namespace");

    // disconnect all clients in the "room-101" room
    myNamespace.in("room-101").disconnectSockets();

[][]

namespace.serverSideEmit(eventName[, ...args][, ack])​

Added in v4.1.0

- eventName <string>
- args <any[]>
- ack <Function>
- Returns true

Sends a message to the other Socket.IO servers of the cluster.

Syntax:

    io.of("/chat").serverSideEmit("hello", "world");

[][]

And on the receiving side:

    io.of("/chat").on("hello", (arg1) => {
      console.log(arg1); // prints "world"
    });

[][]

Acknowledgements are supported too:

    // server A
    io.of("/chat").serverSideEmit("ping", (err, responses) => {
      console.log(responses[0]); // prints "pong"
    });

    // server B
    io.of("/chat").on("ping", (cb) => {
      cb("pong");
    });

[][]

Notes:

- the connection, connect and new_namespace strings are reserved and
  cannot be used in your application.

- you can send any number of arguments, but binary structures are
  currently not supported (the array of arguments will be
  JSON.stringify-ed)

Example:

    io.of("/chat").serverSideEmit("hello", "world", 1, "2", { 3: "4" });

[][]

- the acknowledgement callback might be called with an error, if the
  other Socket.IO servers do not respond after a given delay

    io.of("/chat").serverSideEmit("ping", (err, responses) => {
      if (err) {
        // at least one Socket.IO server has not responded
        // the 'responses' array contains all the responses already received though
      } else {
        // success! the 'responses' array contains one object per other Socket.IO server in the cluster
      }
    });

[][]

namespace.serverSideEmitWithAck(eventName[, ...args])​

Added in v4.6.0

- eventName <string>
- args <any[]>
- ack <Function>
- Returns Promise<any[]>

Promised-based version of broadcasting and expecting an acknowledgement
from the other Socket.IO servers of the cluster.

    try {
      const responses = await io.of("/chat").serverSideEmitWithAck("some-event");
      console.log(responses); // one response per server (except itself)
    } catch (e) {
      // some servers did not acknowledge the event in the given delay
    }

[][]

The example above is equivalent to:

    io.of("/chat").serverSideEmit("some-event", (err, responses) => {
      if (err) {
        // some servers did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per server (except itself)
      }
    });

[][]

And on the receiving side:

    io.of("/chat").on("some-event", (callback) => {
      callback("got it"); // only one argument is expected
    });

[][]

namespace.socketsJoin(rooms)​

Added in v4.0.0

- rooms <string> | <string[]>
- Returns void

Makes the matching Socket instances join the specified rooms:

    // make all Socket instances join the "room1" room
    io.socketsJoin("room1");

    // make all Socket instances in the "room1" room join the "room2" and "room3" rooms
    io.in("room1").socketsJoin(["room2", "room3"]);

    // make all Socket instances in the "room1" room of the "admin" namespace join the "room2" room
    io.of("/admin").in("room1").socketsJoin("room2");

    // this also works with a single socket ID
    io.in(theSocketId).socketsJoin("room1");

[][]

More information can be found here.

namespace.socketsLeave(rooms)​

Added in v4.0.0

- rooms <string> | <string[]>
- Returns void

Makes the matching Socket instances leave the specified rooms:

    // make all Socket instances leave the "room1" room
    io.socketsLeave("room1");

    // make all Socket instances in the "room1" room leave the "room2" and "room3" rooms
    io.in("room1").socketsLeave(["room2", "room3"]);

    // make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" room
    io.of("/admin").in("room1").socketsLeave("room2");

    // this also works with a single socket ID
    io.in(theSocketId).socketsLeave("room1");

[][]

namespace.timeout(value)​

Added in v4.5.0

- value <number>
- Returns BroadcastOperator

Sets a modifier for a subsequent event emission that the callback will
be called with an error when the given number of milliseconds have
elapsed without an acknowledgement from the client:

    io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {
      if (err) {
        // some clients did not acknowledge the event in the given delay
      } else {
        console.log(responses); // one response per client
      }
    });

[][]

namespace.to(room)​

History

  Version   Changes
  --------- ----------------------------------
  v4.0.0    Allow to pass an array of rooms.
  v1.0.0    Initial implementation.

- room <string> | <string[]>
- Returns BroadcastOperator for chaining

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

    const myNamespace = io.of("/my-namespace");

    // the “foo” event will be broadcast to all connected clients in the “room-101” room
    myNamespace.to("room-101").emit("foo", "bar");

    // with an array of rooms (a client will be notified at most once)
    myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");

    // with multiple chained calls
    myNamespace.to("room-101").to("room-102").emit("foo", "bar");

[][]

namespace.use(fn)​

Added in v1.0.0

- fn <Function>

Registers a middleware for the given namespace, which is a function that
gets executed for every incoming Socket, and receives as parameters the
socket and a function to optionally defer execution to the next
registered middleware.

Errors passed to middleware callbacks are sent as special connect_error
packets to clients.

Server

    io.of("/chat").use((socket, next) => {
      const err = new Error("not authorized");
      err.data = { content: "Please retry later" }; // additional details
      next(err);
    });

[][]

Client

    socket.on("connect_error", err => {
      console.log(err instanceof Error); // true
      console.log(err.message); // not authorized
      console.log(err.data); // { content: "Please retry later" }
    });

[][]

More information can be found here.

[]info

If you are looking for Express middlewares, please check this section.

Flags​

Flag: 'local'​

Sets a modifier for a subsequent event emission that the event data will
only be broadcast to the current node (when scaling to multiple nodes).

    io.local.emit("an event", { some: "data" });

[][]

Flag: 'volatile'​

Sets a modifier for a subsequent event emission that the event data may
be lost if the clients are not ready to receive messages (because of
network slowness or other issues, or because they’re connected through
long polling and is in the middle of a request-response cycle).

    io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it

[][]

Socket​

[Socket in the class diagram for the server][Socket in the class diagram
for the server]

A Socket is the fundamental class for interacting with browser clients.
A Socket belongs to a certain Namespace (by default /) and uses an
underlying Client to communicate.

It should be noted the Socket doesn't relate directly to the actual
underlying TCP/IP socket and it is only the name of the class.

Within each Namespace, you can also define arbitrary channels (called
room) that the Socket can join and leave. That provides a convenient way
to broadcast to a group of Sockets (see Socket#to below).

The Socket class inherits from EventEmitter. The Socket class overrides
the emit method, and does not modify any other EventEmitter method. All
methods documented here which also appear as EventEmitter methods (apart
from emit) are implemented by EventEmitter, and documentation for
EventEmitter applies.

More information can be found here.

Events​

Event: 'disconnect'​

- reason <string> the reason of the disconnection (either client or
  server-side)

Fired upon disconnection.

    io.on("connection", (socket) => {
      socket.on("disconnect", (reason) => {
        // ...
      });
    });

[][]

Possible reasons:

  Reason                        Description
  ----------------------------- ----------------------------------------------------------------------------------------------------------------
  server namespace disconnect   The socket was forcefully disconnected with socket.disconnect().
  client namespace disconnect   The client has manually disconnected the socket using socket.disconnect().
  server shutting down          The server is, well, shutting down.
  ping timeout                  The client did not send a PONG packet in the pingTimeout delay.
  transport close               The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G).
  transport error               The connection has encountered an error.
  parse error                   The server has received an invalid packet from the client.
  forced close                  The server has received an invalid packet from the client.
  forced server close           The client did not join a namespace in time (see the connectTimeout option) and was forcefully closed.

Event: 'disconnecting'​

Added in v1.5.0

- reason <string> the reason of the disconnection (either client or
  server-side)

Fired when the client is going to be disconnected (but hasn't left its
rooms yet).

    io.on("connection", (socket) => {
      socket.on("disconnecting", (reason) => {
        console.log(socket.rooms); // Set { ... }
      });
    });

[][]

With an asynchronous handler, you will need to create a copy of the
rooms attribute:

    io.on("connection", (socket) => {
      socket.on("disconnecting", async (reason) => {
        const rooms = new Set(socket.rooms);

        await someLongRunningOperation();

        // socket.rooms will be empty there
        console.log(rooms);
      });
    });

[][]

[]caution

Those events, along with connect, connect_error, newListener and
removeListener, are special events that shouldn't be used in your
application:

    // BAD, will throw an error
    socket.emit("disconnect");

[][]

Attributes​

socket.client​

- <Client>

A reference to the underlying Client object.

socket.conn​

- <engine.Socket>

A reference to the underlying Client transport connection (engine.io
Socket object). This allows access to the IO transport layer, which
still (mostly) abstracts the actual TCP/IP socket.

    io.on("connection", (socket) => {
      console.log("initial transport", socket.conn.transport.name); // prints "polling"

      socket.conn.once("upgrade", () => {
        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)
        console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"
      });

      socket.conn.on("packet", ({ type, data }) => {
        // called for each packet received
      });

      socket.conn.on("packetCreate", ({ type, data }) => {
        // called for each packet sent
      });

      socket.conn.on("drain", () => {
        // called when the write buffer is drained
      });

      socket.conn.on("heartbeat", () => {
        // called after each round trip of the heartbeat mechanism
        console.log("heartbeat");
      });

      socket.conn.on("close", (reason) => {
        // called when the underlying connection is closed
      });
    });

[][]

socket.data​

Added in v4.0.0

An arbitrary object that can be used in conjunction with the
fetchSockets() utility method:

    io.on("connection", (socket) => {
      socket.data.username = "alice";
    });

    const sockets = await io.fetchSockets();
    console.log(sockets[0].data.username); // "alice"

[][]

[]tip

This also works within a Socket.IO cluster, with a compatible adapter
like the Postgres adapter.

socket.handshake​

- <Object>

The handshake details:

  Field     Type                                 Description
  --------- ------------------------------------ --------------------------------------------
  headers   IncomingHttpHeaders                  The headers sent as part of the handshake.
  time      <string>                             The date of creation (as string).
  address   <string>                             The ip address of the client.
  xdomain   <boolean>                            Whether the connection is cross-domain.
  secure    <boolean>                            Whether the connection is made over SSL.
  issued    <number>                             The date of creation (as unix timestamp).
  url       <string>                             The request URL string.
  query     Record<string, string or string[]>   The query parameters of the first request.
  auth      Record<string, any>                  The authentication payload. See also here.

Usage:

    io.use((socket, next) => {
      let handshake = socket.handshake;
      // ...
    });

    io.on("connection", (socket) => {
      let handshake = socket.handshake;
      // ...
    });

[][]

Example:

    const handshake = {
      headers: {
        "user-agent": "node-XMLHttpRequest",
        accept: "*/*",
        host: "localhost:3000",
        connection: "close"
      },
      time: "Wed Jan 01 2020 01:00:00 GMT+0100 (Central European Standard Time)",
      address: "::ffff:127.0.0.1",
      xdomain: false,
      secure: false,
      issued: 1577836800000,
      url: "/socket.io/?EIO=4&transport=polling&t=OPAfXv5&b64=1",
      query: {
        EIO: "4",
        transport: "polling",
        t: "OPAfXv5",
        b64: "1"
      },
      auth: {}
    }

[][]

Note: the headers attribute refers to the headers of the first HTTP
request of the session, and won't be updated by the subsequent HTTP
requests.

    io.on("connection", (socket) => {
      console.log(socket.handshake.headers === socket.request.headers); // prints "true"
    });

[][]

socket.id​

- <string>

A unique identifier for the session, that comes from the underlying
Client.

[]caution

The id attribute is an ephemeral ID that is not meant to be used in your
application (or only for debugging purposes) because:

- this ID is regenerated after each reconnection (for example when the
  WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if
  the client is disconnected, the messages sent from the server to this
  ID are lost)

Please use a regular session ID instead (either sent in a cookie, or
stored in the localStorage and sent in the auth payload).

See also:

- Part II of our private message guide
- How to deal with cookies

socket.recovered​

Added in v4.6.0

- <boolean>

Whether the connection state was successfully recovered during the last
reconnection.

    io.on("connection", (socket) => {
      if (socket.recovered) {
        // recovery was successful: socket.id, socket.rooms and socket.data were restored
      } else {
        // new or unrecoverable session
      }
    });

[][]

More information about this feature here.

socket.request​

- <http.IncomingMessage>

A getter proxy that returns the reference to the request that originated
the underlying engine.io Client. Useful for accessing request headers
such as Cookie or User-Agent.

    import { parse } from "cookie";

    io.on("connection", (socket) => {
      const cookies = parse(socket.request.headers.cookie || "");
    });

[][]

Note: socket.request refers to the first HTTP request of the session,
and won't be updated by the subsequent HTTP requests.

    io.on("connection", (socket) => {
      console.log(socket.request.headers === socket.handshake.headers); // prints "true"
    });

[][]

If you don't need this reference, you can discard it in order to reduce
the memory footprint:

    io.on("connection", (socket) => {
      delete socket.conn.request;
    });

[][]

socket.rooms​

- Set<string>

A Set of strings identifying the rooms this client is in.

    io.on("connection", (socket) => {

      console.log(socket.rooms); // Set { <socket.id> }

      socket.join("room1");

      console.log(socket.rooms); // Set { <socket.id>, "room1" }

    });

[][]

Methods​

socket.compress(value)​

- value <boolean> whether to following packet will be compressed
- Returns Socket for chaining

Sets a modifier for a subsequent event emission that the event data will
only be compressed if the value is true. Defaults to true when you don't
call the method.

    io.on("connection", (socket) => {
      socket.compress(false).emit("uncompressed", "that's rough");
    });

[][]

socket.disconnect([close])​

- close <boolean> whether to close the underlying connection
- Returns Socket

Disconnects this socket. If value of close is true, closes the
underlying connection. Otherwise, it just disconnects the namespace.

    io.on("connection", (socket) => {
      setTimeout(() => socket.disconnect(true), 5000);
    });

[][]

socket.emit(eventName[, ...args][, ack])​

(overrides EventEmitter.emit)

- eventName <string> | <symbol>
- args <any[]>
- ack <Function>
- Returns true

Emits an event to the socket identified by the string name. Any other
parameters can be included. All serializable data structures are
supported, including Buffer.

    io.on("connection", () => {
      socket.emit("hello", "world");
      socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });
    });

[][]

The ack argument is optional and will be called with the client's
answer.

Server

    io.on("connection", (socket) => {
      socket.emit("hello", "world", (response) => {
        console.log(response); // "got it"
      });
    });

[][]

Client

    socket.on("hello", (arg, callback) => {
      console.log(arg); // "world"
      callback("got it");
    });

[][]

socket.emitWithAck(eventName[, ...args])​

Added in v4.6.0

- eventName <string> | <symbol>
- args any[]
- Returns Promise<any>

Promised-based version of emitting and expecting an acknowledgement from
the given client:

    io.on("connection", async (socket) => {
      // without timeout
      const response = await socket.emitWithAck("hello", "world");

      // with a specific timeout
      try {
        const response = await socket.timeout(10000).emitWithAck("hello", "world");
      } catch (err) {
        // the client did not acknowledge the event in the given delay
      }
    });

[][]

The example above is equivalent to:

    io.on("connection", (socket) => {
      // without timeout
      socket.emit("hello", "world", (val) => {
        // ...
      });

      // with a specific timeout
      socket.timeout(10000).emit("hello", "world", (err, val) => {
        // ...
      });
    });

[][]

And on the receiving side:

    socket.on("hello", (arg1, callback) => {
      callback("got it"); // only one argument is expected
    });

[][]

socket.eventNames()​

Inherited from EventEmitter (along with other methods not mentioned
here). See the Node.js documentation for the events module.

socket.except(rooms)​

Added in v4.0.0

- rooms <string> | <string[]>
- Returns BroadcastOperator

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have not joined the given rooms (the socket
itself being excluded).

    // to all clients except the ones in "room1" and the sender
    socket.broadcast.except("room1").emit(/* ... */);

    // same as above
    socket.except("room1").emit(/* ... */);

    // to all clients in "room4" except the ones in "room5" and the sender
    socket.to("room4").except("room5").emit(/* ... */);

[][]

socket.in(room)​

Added in v1.0.0

Synonym of socket.to(room).

socket.join(room)​

- room <string> | <string[]>
- Returns void | Promise

Adds the socket to the given room or to the list of rooms.

    io.on("connection", (socket) => {
      socket.join("room 237");
      
      console.log(socket.rooms); // Set { <socket.id>, "room 237" }

      socket.join(["room 237", "room 238"]);

      io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room
    });

[][]

The mechanics of joining rooms are handled by the Adapter that has been
configured (see Server#adapter above), defaulting to socket.io-adapter.

For your convenience, each socket automatically joins a room identified
by its id (see Socket#id). This makes it easy to broadcast messages to
other sockets:

    io.on("connection", (socket) => {
      socket.on("say to someone", (id, msg) => {
        // send a private message to the socket with the given id
        socket.to(id).emit("my message", msg);
      });
    });

[][]

socket.leave(room)​

- room <string>
- Returns void | Promise

Removes the socket from the given room.

    io.on("connection", (socket) => {
      socket.leave("room 237");

      io.to("room 237").emit(`user ${socket.id} has left the room`);
    });

[][]

[]info

Rooms are left automatically upon disconnection.

socket.listenersAny()​

- Returns <Function[]>

Returns the list of registered catch-all listeners.

    const listeners = socket.listenersAny();

[][]

socket.listenersAnyOutgoing()​

Added in v4.5.0

- Returns <Function[]>

Returns the list of registered catch-all listeners for outgoing packets.

    const listeners = socket.listenersAnyOutgoing();

[][]

socket.offAny([listener])​

- listener <Function>

Removes the previously registered listener. If no listener is provided,
all catch-all listeners are removed.

    const myListener = () => { /* ... */ };

    socket.onAny(myListener);

    // then, later
    socket.offAny(myListener);

    socket.offAny();

[][]

socket.offAnyOutgoing([listener])​

Added in v4.5.0

- listener <Function>

Removes the previously registered listener. If no listener is provided,
all catch-all listeners are removed.

    const myListener = () => { /* ... */ };

    socket.onAnyOutgoing(myListener);

    // remove a single listener
    socket.offAnyOutgoing(myListener);

    // remove all listeners
    socket.offAnyOutgoing();

[][]

socket.on(eventName, callback)​

Inherited from the EventEmitter class.

- eventName <string> | <symbol>
- callback <Function>
- Returns <Socket>

Register a new handler for the given event.

    socket.on("news", (data) => {
      console.log(data);
    });
    // with several arguments
    socket.on("news", (arg1, arg2, arg3) => {
      // ...
    });
    // or with acknowledgement
    socket.on("news", (data, callback) => {
      callback(0);
    });

[][]

socket.onAny(callback)​

- callback <Function>

Register a new catch-all listener.

    socket.onAny((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.emit("foo", (value) => {
      // ...
    });

    socket.onAnyOutgoing(() => {
      // triggered when the event is sent
    });

    socket.onAny(() => {
      // not triggered when the acknowledgement is received
    });

[][]

socket.onAnyOutgoing(callback)​

Added in v4.5.0

- callback <Function>

Register a new catch-all listener for outgoing packets.

    socket.onAnyOutgoing((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

[]caution

Acknowledgements are not caught in the catch-all listener.

    socket.on("foo", (value, callback) => {
      callback("OK");
    });

    socket.onAny(() => {
      // triggered when the event is received
    });

    socket.onAnyOutgoing(() => {
      // not triggered when the acknowledgement is sent
    });

[][]

socket.once(eventName, listener)​

Inherited from EventEmitter (along with other methods not mentioned
here). See the Node.js documentation for the events module.

socket.prependAny(callback)​

- callback <Function>

Register a new catch-all listener. The listener is added to the
beginning of the listeners array.

    socket.prependAny((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

socket.prependAnyOutgoing(callback)​

Added in v4.5.0

- callback <Function>

Register a new catch-all listener for outgoing packets. The listener is
added to the beginning of the listeners array.

    socket.prependAnyOutgoing((event, ...args) => {
      console.log(`got ${event}`);
    });

[][]

socket.removeAllListeners([eventName])​

Inherited from EventEmitter (along with other methods not mentioned
here). See the Node.js documentation for the events module.

socket.removeListener(eventName, listener)​

Inherited from EventEmitter (along with other methods not mentioned
here). See the Node.js documentation for the events module.

socket.send([...args][, ack])​

- args <any[]>
- ack <Function>
- Returns Socket

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

socket.timeout(value)​

Added in v4.4.0

- value <number>
- Returns <Socket>

Sets a modifier for a subsequent event emission that the callback will
be called with an error when the given number of milliseconds have
elapsed without an acknowledgement from the client:

    socket.timeout(5000).emit("my-event", (err) => {
      if (err) {
        // the client did not acknowledge the event in the given delay
      }
    });

[][]

socket.to(room)​

History

  Version   Changes
  --------- ----------------------------------
  v4.0.0    Allow to pass an array of rooms.
  v1.0.0    Initial implementation.

- room <string> | <string[]>
- Returns Socket for chaining

Sets a modifier for a subsequent event emission that the event will only
be broadcast to clients that have joined the given room (the socket
itself being excluded).

To emit to multiple rooms, you can call to several times.

    io.on("connection", (socket) => {

      // to one room
      socket.to("others").emit("an event", { some: "data" });

      // to multiple rooms
      socket.to("room1").to("room2").emit("hello");

      // or with an array
      socket.to(["room1", "room2"]).emit("hello");

      // a private message to another socket
      socket.to(/* another socket id */).emit("hey");

      // WARNING: `socket.to(socket.id).emit()` will NOT work
      // Please use `io.to(socket.id).emit()` instead.
    });

[][]

socket.use(fn)​

History

  Version   Changes
  --------- -------------------------------------------------
  v3.0.5    Restoration of the first implementation.
  v3.0.0    Removal in favor of socket.onAny().
  v1.7.2    The error event is sent directly to the client.
  v1.6.0    First implementation.

- fn <Function>

Registers a middleware, which is a function that gets executed for every
incoming Packet and receives as parameter the packet and a function to
optionally defer execution to the next registered middleware.

Errors passed to the middleware callback are then emitted as error
events on the server-side:

    io.on("connection", (socket) => {
      socket.use(([event, ...args], next) => {
        if (isUnauthorized(event)) {
          return next(new Error("unauthorized event"));
        }
        // do not forget to call next
        next();
      });

      socket.on("error", (err) => {
        if (err && err.message === "unauthorized event") {
          socket.disconnect();
        }
      });
    });

[][]

Flags​

Flag: 'broadcast'​

Sets a modifier for a subsequent event emission that the event data will
only be broadcast to every sockets but the sender.

    io.on("connection", (socket) => {
      socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender
    });

[][]

Flag: 'volatile'​

Sets a modifier for a subsequent event emission that the event data may
be lost if the client is not ready to receive messages (because of
network slowness or other issues, or because they’re connected through
long polling and is in the middle of a request-response cycle).

    io.on("connection", (socket) => {
      socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it
    });

[][]

Client​

[Client in the class diagram for the server][Client in the class diagram
for the server]

The Client class represents an incoming transport (engine.io)
connection. A Client can be associated with many multiplexed Sockets
that belong to different Namespaces.

Attributes​

client.conn​

- <engine.Socket>

A reference to the underlying engine.io Socket connection.

client.request​

- <http.IncomingMessage>

A getter proxy that returns the reference to the request that originated
the engine.io connection. Useful for accessing request headers such as
Cookie or User-Agent.

Engine​

The Engine.IO server, which manages the WebSocket / HTTP long-polling
connections. More information here.

Its source code can be found here: https://github.com/socketio/engine.io

Events​

Event: 'connection_error'​

Added in v4.1.0

- error <Error>

    io.engine.on("connection_error", (err) => {
      console.log(err.req);      // the request object
      console.log(err.code);     // the error code, for example 1
      console.log(err.message);  // the error message, for example "Session ID unknown"
      console.log(err.context);  // some additional error context
    });

[][]

This event will be emitted when a connection is abnormally closed. Here
is the list of possible error codes:

   Code              Message
  ------ --------------------------------
    0          "Transport unknown"
    1          "Session ID unknown"
    2         "Bad handshake method"
    3             "Bad request"
    4              "Forbidden"
    5     "Unsupported protocol version"

Event: 'headers'​

Added in v4.1.0

- headers <Object> a hash of headers, indexed by header name
- request <http.IncomingMessage> the incoming request

This event will be emitted just before writing the response headers of
each HTTP request of the session (including the WebSocket upgrade),
allowing you to customize them.

    import { serialize, parse } from "cookie";

    io.engine.on("headers", (headers, request) => {
      if (!request.headers.cookie) return;
      const cookies = parse(request.headers.cookie);
      if (!cookies.randomId) {
        headers["set-cookie"] = serialize("randomId", "abc", { maxAge: 86400 });
      }
    });

[][]

Event: 'initial_headers'​

Added in v4.1.0

- headers <Object> a hash of headers, indexed by header name
- request <http.IncomingMessage> the incoming request

This event will be emitted just before writing the response headers of
the first HTTP request of the session (the handshake), allowing you to
customize them.

    import { serialize } from "cookie";

    io.engine.on("initial_headers", (headers, request) => {
      headers["set-cookie"] = serialize("uid", "1234", { sameSite: "strict" });
    });

[][]

If you need to perform some asynchronous operations, you will need to
use the allowRequest option:

    import { serialize } from "cookie";

    const io = new Server(httpServer, {
      allowRequest: async (req, callback) => {
        const session = await fetchSession(req);
        req.session = session;
        callback(null, true);
      }
    });

    io.engine.on("initial_headers", (headers, req) => {
      if (req.session) {
        headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });
      }
    });

[][]

See also:

- how to use with express-session
- how to deal with cookies

Attributes​

engine.clientsCount​

Added in v1.0.0

- <number>

The number of currently connected clients.

    const count = io.engine.clientsCount;
    // may or may not be similar to the count of Socket instances in the main namespace, depending on your usage
    const count2 = io.of("/").sockets.size;

[][]

Methods​

engine.generateId​

- <Function>

The function used to generate a new session ID. Defaults to base64id.

    const uuid = require("uuid");

    io.engine.generateId = () => {
      return uuid.v4(); // must be unique across all Socket.IO servers
    }

[][]

engine.handleUpgrade(request, socket, head)​

Added in v1.0.0

- request <http.IncomingMessage> the incoming request
- socket <stream.Duplex> the network socket between the server and
  client
- head <Buffer> the first packet of the upgraded stream (may be empty)

This method can be used to inject an HTTP upgrade:

Example with both a Socket.IO server and a plain WebSocket server:

    import { createServer } from "http";
    import { Server as WsServer } from "ws";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const wss = new WsServer({ noServer: true });
    const io = new Server(httpServer);

    httpServer.removeAllListeners("upgrade");

    httpServer.on("upgrade", (req, socket, head) => {
      if (req.url === "/") {
        wss.handleUpgrade(req, socket, head, (ws) => {
          wss.emit("connection", ws, req);
        });
      } else if (req.url.startsWith("/socket.io/")) {
        io.engine.handleUpgrade(req, socket, head);
      } else {
        socket.destroy();
      }
    });

    httpServer.listen(3000);

[][]

engine.use(middleware)​

Added in v4.6.0

- <Function>

Adds a new Express middleware.

    io.engine.use((req, res, next) => {
      // do something

      next();
    });

[][]

The middlewares will be called for each incoming HTTP requests,
including upgrade requests.

Example with express-session:

    import session from "express-session";

    io.engine.use(session({
      secret: "keyboard cat",
      resave: false,
      saveUninitialized: true,
      cookie: { secure: true }
    }));

[][]

Example with helmet:

    import helmet from "helmet";

    io.engine.use(helmet());

[][]

[]Edit this page

Last updated on Apr 24, 2025

Next

Options

- Server
  - Constructor
    - new Server(httpServer, options)
    - new Server(port, options)
    - new Server(options)
  - Events
    - Event: 'connect'
    - Event: 'connection'
    - Event: 'new_namespace'
  - Attributes
    - server.engine
    - server.sockets
  - Methods
    - server.adapter(value)
    - server.attach(httpServer, options)
    - server.attach(port, options)
    - server.attachApp(app, options)
    - server.bind(engine)
    - server.close(callback)
    - server.disconnectSockets(close)
    - server.emit(eventName, ...args)
    - server.emitWithAck(eventName, ...args)
    - server.except(rooms)
    - server.fetchSockets()
    - server.in(room)
    - server.listen(httpServer, options)
    - server.listen(port, options)
    - server.of(nsp)
    - server.on(eventName, listener)
    - server.onconnection(socket)
    - server.path(value)
    - server.serveClient(value)
    - server.serverSideEmit(eventName, ...args)
    - server.serverSideEmitWithAck(eventName, ...args)
    - server.socketsJoin(rooms)
    - server.socketsLeave(rooms)
    - server.timeout(value)
    - server.to(room)
    - server.use(fn)
- Namespace
  - Attributes
    - namespace.adapter
    - namespace.name
    - namespace.sockets
  - Events
    - Event: 'connect'
    - Event: 'connection'
  - Methods
    - namespace.allSockets()
    - namespace.disconnectSockets(close)
    - namespace.emit(eventName, ...args)
    - namespace.emitWithAck(eventName, ...args)
    - namespace.except(rooms)
    - namespace.fetchSockets()
    - namespace.in(room)
    - namespace.serverSideEmit(eventName, ...args)
    - namespace.serverSideEmitWithAck(eventName, ...args)
    - namespace.socketsJoin(rooms)
    - namespace.socketsLeave(rooms)
    - namespace.timeout(value)
    - namespace.to(room)
    - namespace.use(fn)
  - Flags
    - Flag: 'local'
    - Flag: 'volatile'
- Socket
  - Events
    - Event: 'disconnect'
    - Event: 'disconnecting'
  - Attributes
    - socket.client
    - socket.conn
    - socket.data
    - socket.handshake
    - socket.id
    - socket.recovered
    - socket.request
    - socket.rooms
  - Methods
    - socket.compress(value)
    - socket.disconnect(close)
    - socket.emit(eventName, ...args)
    - socket.emitWithAck(eventName, ...args)
    - socket.eventNames()
    - socket.except(rooms)
    - socket.in(room)
    - socket.join(room)
    - socket.leave(room)
    - socket.listenersAny()
    - socket.listenersAnyOutgoing()
    - socket.offAny(listener)
    - socket.offAnyOutgoing(listener)
    - socket.on(eventName, callback)
    - socket.onAny(callback)
    - socket.onAnyOutgoing(callback)
    - socket.once(eventName, listener)
    - socket.prependAny(callback)
    - socket.prependAnyOutgoing(callback)
    - socket.removeAllListeners(eventName)
    - socket.removeListener(eventName, listener)
    - socket.send(...args)
    - socket.timeout(value)
    - socket.to(room)
    - socket.use(fn)
  - Flags
    - Flag: 'broadcast'
    - Flag: 'volatile'
- Client
  - Attributes
    - client.conn
    - client.request
- Engine
  - Events
    - Event: 'connection_error'
    - Event: 'headers'
    - Event: 'initial_headers'
  - Attributes
    - engine.clientsCount
  - Methods
    - engine.generateId
    - engine.handleUpgrade(request, socket, head)
    - engine.use(middleware)

=============

## doc_docs_v4_server-application-structure_.txt

- []
- Server
- Application structure

Version: 4.x

On this page

Application structure

Registering event handlers​

You will find below two suggestions on how to register your event
handlers.

Please note that these are merely suggestions and not strict guidelines
that you must follow. Please adapt it to your own liking!

Each file registers its own event handlers​

Here, the entrypoint is kept tidy, but the event listeners may be less
discoverable (though strong naming convention/ctrl+f will help).

index.js

    const httpServer = require("http").createServer();
    const io = require("socket.io")(httpServer);

    const registerOrderHandlers = require("./orderHandler");
    const registerUserHandlers = require("./userHandler");

    const onConnection = (socket) => {
      registerOrderHandlers(io, socket);
      registerUserHandlers(io, socket);
    }

    io.on("connection", onConnection);

[][]

orderHandler.js

    module.exports = (io, socket) => {
      const createOrder = (payload) => {
        // ...
      }

      const readOrder = (orderId, callback) => {
        // ...
      }

      socket.on("order:create", createOrder);
      socket.on("order:read", readOrder);
    }

[][]

All event handlers are registered in the index.js file​

Here, each event name is located in the same place, which is great for
discoverability, but could get out of hand in a medium/big application.

index.js

    const httpServer = require("http").createServer();
    const io = require("socket.io")(httpServer);

    const { createOrder, readOrder } = require("./orderHandler")(io);
    const { updatePassword } = require("./userHandler")(io);

    const onConnection = (socket) => {
      socket.on("order:create", createOrder);
      socket.on("order:read", readOrder);

      socket.on("user:update-password", updatePassword);
    }

    io.on("connection", onConnection);

[][]

orderHandler.js

    module.exports = (io) => {
      const createOrder = function (payload) {
        const socket = this; // hence the 'function' above, as an arrow function will not work
        // ...
      };

      const readOrder = function (orderId, callback) {
        // ...
      };

      return {
        createOrder,
        readOrder
      }
    }

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Handling CORS

Next

Usage with bundlers

- Registering event handlers
  - Each file registers its own event handlers
  - All event handlers are registered in the index.js file

=============

## doc_docs_v4_server-initialization_.txt

- []
- Server
- Initialization

Version: 4.x

On this page

Server Initialization

Once you have installed the Socket.IO server library, you can now init
the server. The complete list of options can be found here.

[]tip

For TypeScript users, it is possible to provide type hints for the
events. Please check this.

Initialization​

Standalone​

- CommonJS
- ES modules
- TypeScript

    const { Server } = require("socket.io");

    const io = new Server({ /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    io.listen(3000);

[][]

    import { Server } from "socket.io";

    const io = new Server({ /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    io.listen(3000);

[][]

    import { Server } from "socket.io";

    const io = new Server({ /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    io.listen(3000);

[][]

You can also pass the port as the first argument:

- CommonJS
- ES modules
- TypeScript

    const { Server } = require("socket.io");

    const io = new Server(3000, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

[][]

    import { Server } from "socket.io";

    const io = new Server(3000, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

[][]

    import { Server } from "socket.io";

    const io = new Server(3000, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

[][]

This implicitly starts a Node.js HTTP server, which can be accessed
through io.httpServer.

With an HTTP server​

- CommonJS
- ES modules
- TypeScript

    const { createServer } = require("http");
    const { Server } = require("socket.io");

    const httpServer = createServer();
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

With an HTTPS server​

- CommonJS
- ES modules
- TypeScript

    const { readFileSync } = require("fs");
    const { createServer } = require("https");
    const { Server } = require("socket.io");

    const httpsServer = createServer({
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpsServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpsServer.listen(3000);

[][]

    import { readFileSync } from "fs";
    import { createServer } from "https";
    import { Server } from "socket.io";

    const httpsServer = createServer({
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpsServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpsServer.listen(3000);

[][]

    import { readFileSync } from "fs";
    import { createServer } from "https";
    import { Server } from "socket.io";

    const httpsServer = createServer({
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpsServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpsServer.listen(3000);

[][]

See also: Node.js documentation

With client-certificate authentication:

Server

    import { readFileSync } from "fs";
    import { createServer } from "https";
    import { Server } from "socket.io";

    const httpsServer = createServer({
      key: readFileSync("/path/to/server-key.pem"),
      cert: readFileSync("/path/to/server-cert.pem"),
      requestCert: true,
      ca: [
        readFileSync("/path/to/client-cert.pem")
      ]
    });

    const io = new Server(httpsServer, { /* options */ });

    io.engine.on("connection", (rawSocket) => {
      // if you need the certificate details (it is no longer available once the handshake is completed)
      rawSocket.peerCertificate = rawSocket.request.client.getPeerCertificate();
    });

    io.on("connection", (socket) => {
      console.log(socket.conn.peerCertificate);
      // ...
    });

    httpsServer.listen(3000);

[][]

Client

    import { readFileSync } from "fs";
    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      key: readFileSync("/path/to/client-key.pem"),
      cert: readFileSync("/path/to/client-cert.pem"),
      ca: [
        readFileSync("/path/to/server-cert.pem")
      ]
    });

[][]

With an HTTP/2 server​

- CommonJS
- ES modules
- TypeScript

    const { readFileSync } = require("fs");
    const { createSecureServer } = require("http2");
    const { Server } = require("socket.io");

    const httpServer = createSecureServer({
      allowHTTP1: true,
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import { readFileSync } from "fs";
    import { createSecureServer } from "http2";
    import { Server } from "socket.io";

    const httpServer = createSecureServer({
      allowHTTP1: true,
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import { readFileSync } from "fs";
    import { createSecureServer } from "http2";
    import { Server } from "socket.io";

    const httpServer = createSecureServer({
      allowHTTP1: true,
      key: readFileSync("/path/to/my/key.pem"),
      cert: readFileSync("/path/to/my/cert.pem")
    });

    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

See also: Node.js documentation

With Express​

- CommonJS
- ES modules
- TypeScript

    const express = require("express");
    const { createServer } = require("http");
    const { Server } = require("socket.io");

    const app = express();
    const httpServer = createServer(app);
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import express from "express";
    import { createServer } from "http";
    import { Server } from "socket.io";

    const app = express();
    const httpServer = createServer(app);
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import * as express from "express";
    import { createServer } from "http";
    import { Server } from "socket.io";

    const app = express();
    const httpServer = createServer(app);
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

[]caution

Using app.listen(3000) will not work here, as it creates a new HTTP
server.

More information here.

With Koa​

- CommonJS
- ES modules
- TypeScript

    const Koa = require("koa");
    const { createServer } = require("http");
    const { Server } = require("socket.io");

    const app = new Koa();
    const httpServer = createServer(app.callback());
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import Koa from "koa";
    import { createServer } from "http";
    import { Server } from "socket.io";

    const app = new Koa();
    const httpServer = createServer(app.callback());
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

    import * as Koa from "koa";
    import { createServer } from "http";
    import { Server } from "socket.io";

    const app = new Koa();
    const httpServer = createServer(app.callback());
    const io = new Server(httpServer, { /* options */ });

    io.on("connection", (socket) => {
      // ...
    });

    httpServer.listen(3000);

[][]

More information here.

With Nest​

See the documentation here.

[]caution

NestJS v7 and below relies on Socket.IO v2, while NestJS v8 relies on
Socket.IO v4. Please use a compatible client.

With Fastify​

You need to register the fastify-socket.io plugin:

- CommonJS
- ES modules
- TypeScript

    const fastify = require("fastify");
    const fastifyIO = require("fastify-socket.io");

    const server = fastify();
    server.register(fastifyIO);

    server.get("/", (req, reply) => {
      server.io.emit("hello");
    });

    server.ready().then(() => {
      // we need to wait for the server to be ready, else `server.io` is undefined
      server.io.on("connection", (socket) => {
        // ...
      });
    });

    server.listen({ port: 3000 });

[][]

    import fastify from "fastify";
    import fastifyIO from "fastify-socket.io";

    const server = fastify();
    server.register(fastifyIO);

    server.get("/", (req, reply) => {
      server.io.emit("hello");
    });

    server.ready().then(() => {
      // we need to wait for the server to be ready, else `server.io` is undefined
      server.io.on("connection", (socket) => {
        // ...
      });
    });

    server.listen({ port: 3000 });

[][]

    import fastify from "fastify";
    import fastifyIO from "fastify-socket.io";

    const server = fastify();
    server.register(fastifyIO);

    server.get("/", (req, reply) => {
      server.io.emit("hello");
    });

    server.ready().then(() => {
      // we need to wait for the server to be ready, else `server.io` is undefined
      server.io.on("connection", (socket) => {
        // ...
      });
    });

    server.listen({ port: 3000 });

[][]

With µWebSockets.js​

    import { App } from "uWebSockets.js";
    import { Server } from "socket.io";

    const app = App();
    const io = new Server();

    io.attachApp(app);

    io.on("connection", (socket) => {
      // ...
    });

    app.listen(3000, (token) => {
      if (!token) {
        console.warn("port already in use");
      }
    });

[][]

Reference: https://github.com/uNetworking/uWebSockets.js

With Hono (Node.js)​

- CommonJS
- ES modules
- TypeScript

    const { Hono } = require("hono");
    const { serve } = require("@hono/node-server");
    const { Server } = require("socket.io");

    const app = new Hono();

    const httpServer = serve({
        fetch: app.fetch,
        port: 3000,
    });

    const io = new Server(httpServer, {
        /* options */
    });

    io.on("connection", (socket) => {
        // ...
    });

[][]

    import { Hono } from "hono";
    import { serve } from "@hono/node-server";
    import { Server } from "socket.io";

    const app = new Hono();

    const httpServer = serve({
        fetch: app.fetch,
        port: 3000,
    });

    const io = new Server(httpServer, {
        /* options */
    });

    io.on("connection", (socket) => {
        // ...
    });

[][]

    import { Hono } from "hono";
    import { serve } from "@hono/node-server";
    import { Server } from "socket.io";
    import type { Server as HTTPServer } from "node:http";

    const app = new Hono();

    const httpServer = serve({
        fetch: app.fetch,
        port: 3000,
    });

    const io = new Server(httpServer as HTTPServer, {
        /* options */
    });

    io.on("connection", (socket) => {
        // ...
    });

[][]

More information here.

Options​

The complete list of available options can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Installation

Next

The Server instance

- Initialization
  - Standalone
  - With an HTTP server
  - With an HTTPS server
  - With an HTTP/2 server
  - With Express
  - With Koa
  - With Nest
  - With Fastify
  - With µWebSockets.js
  - With Hono (Node.js)
- Options

=============

## doc_docs_v4_server-installation_.txt

- []
- Server
- Installation

Version: 4.x

On this page

Server Installation

[]info

The latest release is currently 4.8.1, released in October 2024.

You can find the release notes here.

Prerequisites​

Please make sure that Node.js is installed on your system. The current
Long Term Support (LTS) release is an ideal starting point, see here.

[]info

At least Node.js 10 is needed, older versions are not supported anymore.

Installation​

To install the latest release:

- NPM
- Yarn
- pnpm
- Bun

    npm install socket.io

[][]

    yarn add socket.io

[][]

    pnpm add socket.io

[][]

    bun add socket.io

[][]

To install a specific version:

- NPM
- Yarn
- pnpm
- Bun

    npm install socket.io@version

[][]

    yarn add socket.io@version

[][]

    pnpm add socket.io@version

[][]

    bun add socket.io@version

[][]

Additional packages​

By default, Socket.IO use the WebSocket server provided by the ws
package.

There are 2 optional packages that can be installed alongside this
package. These packages are binary add-ons which improve certain
operations. Prebuilt binaries are available for the most popular
platforms so you don't necessarily need to have a C++ compiler installed
on your machine.

- bufferutil: Allows to efficiently perform operations such as masking
  and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains
  valid UTF-8 as required by the spec.

To install those packages:

- NPM
- Yarn
- pnpm
- Bun

    npm install --save-optional bufferutil utf-8-validate

[][]

    yarn add --optional bufferutil utf-8-validate

[][]

    pnpm add -O bufferutil utf-8-validate

[][]

    bun add --optional bufferutil utf-8-validate

[][]

Please note that these packages are optional, the WebSocket server will
fallback to the Javascript implementation if they are not available.
More information can be found here.

Other WebSocket server implementations​

Any Websocket server implementation which exposes the same API as ws
(notably the handleUpgrade method) can be used.

For example, you can use the eiows package, which is a fork of the (now
deprecated) uws package:

- NPM
- Yarn
- pnpm
- Bun

    npm install eiows

[][]

    yarn add eiows

[][]

    pnpm add eiows

[][]

    bun add eiows

[][]

And then use the wsEngine option:

    const { Server } = require("socket.io");
    const eiows = require("eiows");

    const io = new Server(3000, {
      wsEngine: eiows.Server
    });

[][]

This implementation "allows, but doesn't guarantee" significant
performance and memory-usage improvements over the default
implementation. As usual, please benchmark it against your own usage.

Usage with µWebSockets.js​

Starting with version 4.4.0, a Socket.IO server can now bind to a
µWebSockets.js server.

Installation:

- NPM
- Yarn
- pnpm
- Bun

    npm install uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0

[][]

    yarn add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0

[][]

    pnpm add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0

[][]

    bun add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0

[][]

Usage:

    const { App } = require("uWebSockets.js");
    const { Server } = require("socket.io");

    const app = App();
    const io = new Server();

    io.attachApp(app);

    io.on("connection", (socket) => {
      // ...
    });

    app.listen(3000, (token) => {
      if (!token) {
        console.warn("port already in use");
      }
    });

[][]

Miscellaneous​

Dependency tree​

A basic installation of the server includes 21 packages, of which 6 are
maintained by our team:

    └─┬ socket.io@4.8.1
      ├─┬ accepts@1.3.8
      │ ├─┬ mime-types@2.1.35
      │ │ └── mime-db@1.52.0
      │ └── negotiator@0.6.3
      ├── base64id@2.0.0
      ├─┬ cors@2.8.5
      │ ├── object-assign@4.1.1
      │ └── vary@1.1.2
      ├─┬ debug@4.3.7
      │ └── ms@2.1.3
      ├─┬ engine.io@6.6.4
      │ ├─┬ @types/cors@2.8.17
      │ │ └── @types/node@22.13.9 deduped
      │ ├─┬ @types/node@22.13.9
      │ │ └── undici-types@6.20.0
      │ ├── accepts@1.3.8 deduped
      │ ├── base64id@2.0.0 deduped
      │ ├── cookie@0.7.2
      │ ├── cors@2.8.5 deduped
      │ ├── debug@4.3.7 deduped
      │ ├── engine.io-parser@5.2.3
      │ └─┬ ws@8.17.1
      │   ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1
      │   └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2
      ├─┬ socket.io-adapter@2.5.5
      │ ├── debug@4.3.7 deduped
      │ └── ws@8.17.1 deduped
      └─┬ socket.io-parser@4.2.4
        ├── @socket.io/component-emitter@3.1.2
        └── debug@4.3.7 deduped

[][]

[]info

The type declarations for 3rd party packages are included, in order to
ease the use of the library for TypeScript users (but at the cost of a
slightly-larger package).

See also:
https://github.com/microsoft/types-publisher/issues/81#issuecomment-234051345

Transitive versions​

The engine.io package brings the engine that is responsible for managing
the low-level connections (HTTP long-polling or WebSocket). See also:
How it works

  socket.io version   engine.io version   ws version
  ------------------- ------------------- ------------
  4.8.x               6.6.x               8.17.x
  4.7.x               6.5.x               8.17.x
  4.6.x               6.4.x               8.11.x
  4.5.x               6.2.x               8.2.x
  4.4.x               6.1.x               8.2.x
  4.3.x               6.0.x               8.2.x
  4.2.x               5.2.x               7.4.x
  4.1.x               5.1.x               7.4.x
  4.0.x               5.0.x               7.4.x
  3.1.x               4.1.x               7.4.x
  3.0.x               4.0.x               7.4.x
  2.5.x               3.6.x               7.5.x
  2.4.x               3.5.x               7.4.x

[]Edit this page

Last updated on Mar 28, 2025

Previous

Memory usage

Next

Initialization

- Prerequisites
- Installation
- Additional packages
- Other WebSocket server implementations
- Usage with µWebSockets.js
- Miscellaneous
  - Dependency tree
  - Transitive versions

=============

## doc_docs_v4_server-instance_.txt

- []
- Server
- The Server instance

Version: 4.x

On this page

The Server instance

The Server instance (often called io in the code examples) has a few
attributes that may be of use in your application.

It also inherits all the methods of the main namespace, like
namespace.use() (see here) or namespace.allSockets().

Server#engine​

A reference to the underlying Engine.IO server.

It can be used to fetch the number of currently connected clients:

    const count = io.engine.clientsCount;
    // may or may not be similar to the count of Socket instances in the main namespace, depending on your usage
    const count2 = io.of("/").sockets.size;

[][]

Or to generate a custom session ID (the sid query parameter):

    const uuid = require("uuid");

    io.engine.generateId = (req) => {
      return uuid.v4(); // must be unique across all Socket.IO servers
    }

[][]

As of socket.io@4.1.0, the Engine.IO server emits three special events:

- initial_headers: will be emitted just before writing the response
  headers of the first HTTP request of the session (the handshake),
  allowing you to customize them.

    io.engine.on("initial_headers", (headers, req) => {
      headers["test"] = "123";
      headers["set-cookie"] = "mycookie=456";
    });

[][]

- headers: will be emitted just before writing the response headers of
  each HTTP request of the session (including the WebSocket upgrade),
  allowing you to customize them.

    io.engine.on("headers", (headers, req) => {
      headers["test"] = "789";
    });

[][]

- connection_error: will be emitted when a connection is abnormally
  closed

    io.engine.on("connection_error", (err) => {
      console.log(err.req);      // the request object
      console.log(err.code);     // the error code, for example 1
      console.log(err.message);  // the error message, for example "Session ID unknown"
      console.log(err.context);  // some additional error context
    });

[][]

Here is the list of possible error codes:

   Code              Message
  ------ --------------------------------
    0          "Transport unknown"
    1          "Session ID unknown"
    2         "Bad handshake method"
    3             "Bad request"
    4              "Forbidden"
    5     "Unsupported protocol version"

Utility methods​

Some utility methods were added in Socket.IO v4.0.0 to manage the Socket
instances and their rooms:

- socketsJoin: makes the matching socket instances join the specified
  rooms
- socketsLeave: makes the matching socket instances leave the specified
  rooms
- disconnectSockets: makes the matching socket instances disconnect
- fetchSockets: returns the matching socket instances

The serverSideEmit method was added in Socket.IO v4.1.0.

Those methods share the same semantics as broadcasting, and the same
filters apply:

    io.of("/admin").in("room1").except("room2").local.disconnectSockets();

[][]

Which makes all Socket instances of the "admin" namespace

- in the "room1" room (in("room1") or to("room1"))
- except the ones in "room2" (except("room2"))
- and only on the current Socket.IO server (local)

disconnect.

Please note that they are also compatible with the Redis adapter
(starting with socket.io-redis@6.1.0), which means that they will work
across Socket.IO servers.

socketsJoin​

This method makes the matching Socket instances join the specified
rooms:

    // make all Socket instances join the "room1" room
    io.socketsJoin("room1");

    // make all Socket instances in the "room1" room join the "room2" and "room3" rooms
    io.in("room1").socketsJoin(["room2", "room3"]);

    // make all Socket instances in the "room1" room of the "admin" namespace join the "room2" room
    io.of("/admin").in("room1").socketsJoin("room2");

    // this also works with a single socket ID
    io.in(theSocketId).socketsJoin("room1");

[][]

socketsLeave​

This method makes the matching Socket instances leave the specified
rooms:

    // make all Socket instances leave the "room1" room
    io.socketsLeave("room1");

    // make all Socket instances in the "room1" room leave the "room2" and "room3" rooms
    io.in("room1").socketsLeave(["room2", "room3"]);

    // make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" room
    io.of("/admin").in("room1").socketsLeave("room2");

    // this also works with a single socket ID
    io.in(theSocketId).socketsLeave("room1");

[][]

disconnectSockets​

This method makes the matching Socket instances disconnect:

    // make all Socket instances disconnect
    io.disconnectSockets();

    // make all Socket instances in the "room1" room disconnect (and discard the low-level connection)
    io.in("room1").disconnectSockets(true);

    // make all Socket instances in the "room1" room of the "admin" namespace disconnect
    io.of("/admin").in("room1").disconnectSockets();

    // this also works with a single socket ID
    io.of("/admin").in(theSocketId).disconnectSockets();

[][]

fetchSockets​

This method returns the matching Socket instances:

    // return all Socket instances of the main namespace
    const sockets = await io.fetchSockets();

    // return all Socket instances in the "room1" room of the main namespace
    const sockets = await io.in("room1").fetchSockets();

    // return all Socket instances in the "room1" room of the "admin" namespace
    const sockets = await io.of("/admin").in("room1").fetchSockets();

    // this also works with a single socket ID
    const sockets = await io.in(theSocketId).fetchSockets();

[][]

The sockets variable in the example above is an array of objects
exposing a subset of the usual Socket class:

    for (const socket of sockets) {
      console.log(socket.id);
      console.log(socket.handshake);
      console.log(socket.rooms);
      console.log(socket.data);
      socket.emit(/* ... */);
      socket.join(/* ... */);
      socket.leave(/* ... */);
      socket.disconnect(/* ... */);
    }

[][]

The data attribute is an arbitrary object that can be used to share
information between Socket.IO servers:

    // server A
    io.on("connection", (socket) => {
      socket.data.username = "alice";
    });

    // server B
    const sockets = await io.fetchSockets();
    console.log(sockets[0].data.username); // "alice"

[][]

serverSideEmit​

This method allows to emit events to the other Socket.IO servers of the
cluster, in a multi-server setup.

Syntax:

    io.serverSideEmit("hello", "world");

[][]

And on the receiving side:

    io.on("hello", (arg1) => {
      console.log(arg1); // prints "world"
    });

[][]

Acknowledgements are supported too:

    // server A
    io.serverSideEmit("ping", (err, responses) => {
      console.log(responses[0]); // prints "pong"
    });

    // server B
    io.on("ping", (cb) => {
      cb("pong");
    });

[][]

Notes:

- the connection, connect and new_namespace strings are reserved and
  cannot be used in your application.

- you can send any number of arguments, but binary structures are
  currently not supported (the array of arguments will be
  JSON.stringify-ed)

Example:

    io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });

[][]

- the acknowledgement callback might be called with an error, if the
  other Socket.IO servers do not respond after a given delay

    io.serverSideEmit("ping", (err, responses) => {
      if (err) {
        // at least one Socket.IO server has not responded
        // the 'responses' array contains all the responses already received though
      } else {
        // success! the 'responses' array contains one object per other Socket.IO server in the cluster
      }
    });

[][]

Events​

The Server instance emits one single event (well, technically two, but
connect is an alias for connection):

- connection

connection​

This event is fired upon a new connection. The first argument is a
Socket instance.

    io.on("connection", (socket) => {
      // ...
    });

[][]

Complete API​

The complete API exposed by the Server instance can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Initialization

Next

The Socket instance

- Server#engine
- Utility methods
  - socketsJoin
  - socketsLeave
  - disconnectSockets
  - fetchSockets
  - serverSideEmit
- Events
  - connection
- Complete API

=============

## doc_docs_v4_server-options_.txt

- []
- Options

Version: 4.x

On this page

Server options

Socket.IO server options​

The following options affect the behavior of the Socket.IO server.

adapter​

Default value: require("socket.io-adapter") (in-memory adapter, whose
source code can be found here)

The "Adapter" to use.

Example with the Redis adapter:

- CommonJS
- ES modules
- TypeScript

    const { Server } = require("socket.io");
    const { createAdapter } = require("@socket.io/redis-adapter");
    const { createClient } = require("redis");

    const pubClient = createClient({ host: "localhost", port: 6379 });
    const subClient = pubClient.duplicate();

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";
    import { createClient } from "redis";

    const pubClient = createClient({ host: "localhost", port: 6379 });
    const subClient = pubClient.duplicate();

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

    import { Server } from "socket.io";
    import { createAdapter } from "@socket.io/redis-adapter";
    import { createClient } from "redis";

    const pubClient = createClient({ host: "localhost", port: 6379 });
    const subClient = pubClient.duplicate();

    const io = new Server({
      adapter: createAdapter(pubClient, subClient)
    });

    io.listen(3000);

[][]

cleanupEmptyChildNamespaces​

Added in v4.6.0

Default value: false

Whether to remove child namespaces that have no sockets connected to
them.

This option might be useful if you create a lot of dynamic namespaces,
since each namespace creates its own adapter instance.

With this option enabled (disabled by default), when a socket
disconnects from a dynamic namespace and if there are no other sockets
connected to it then the namespace will be cleaned up and its adapter
will be closed.

connectionStateRecovery​

Added in v4.6.0

Default value: undefined

The option for the Connection state recovery feature:

    const io = new Server(httpServer, {
      connectionStateRecovery: {
        // the backup duration of the sessions and the packets
        maxDisconnectionDuration: 2 * 60 * 1000,
        // whether to skip middlewares upon successful recovery
        skipMiddlewares: true,
      }
    });

[][]

If the skipMiddlewares option is set to true, then the middlewares will
be skipped when the connection is successfully recovered:

    function computeUserIdFromHeaders(headers) {
      // to be implemented
    }

    // this middleware will be skipped if the connection is successfully recovered
    io.use(async (socket, next) => {
      socket.data.userId = await computeUserIdFromHeaders(socket.handshake.headers);

      next();
    });

    io.on("connection", (socket) => {
      // the userId attribute will either come:
      // - from the middleware above (first connection or failed recovery)
      // - from the recevery mechanism
      console.log("userId", socket.data.userId);
    });

[][]

connectTimeout​

Default value: 45000

The number of ms before disconnecting a client that has not successfully
joined a namespace.

parser​

Default value: socket.io-parser

The parser to use. Please see the documentation here.

path​

Default value: /socket.io/

It is the name of the path that is captured on the server side.

[]caution

The server and the client values must match (unless you are using a
path-rewriting proxy in between).

Server

    import { createServer } from "http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
      path: "/my-custom-path/"
    });

[][]

Client

    import { io } from "socket.io-client";

    const socket = io("https://example.com", {
      path: "/my-custom-path/"
    });

[][]

serveClient​

Default value: true

Whether to serve the client files. If true, the different bundles will
be served at the following location:

- <url>/socket.io/socket.io.js
- <url>/socket.io/socket.io.min.js
- <url>/socket.io/socket.io.msgpack.min.js

(including their associated source maps)

See also here.

Low-level engine options​

The following options affect the behavior of the underlying Engine.IO
server.

addTrailingSlash​

Added in v4.6.0

Default value: true

The trailing slash which was added by default can now be disabled:

    import { createServer } from "node:http";
    import { Server } from "socket.io";

    const httpServer = createServer();
    const io = new Server(httpServer, {
    addTrailingSlash: false
    });

[][]

In the example above, the clients can omit the trailing slash and use
/socket.io instead of /socket.io/.

allowEIO3​

Default value: false

Whether to enable compatibility with Socket.IO v2 clients.

See also: Migrating from 2.x to 3.0

Example:

    const io = new Server(httpServer, {
      allowEIO3: true // false by default
    });

[][]

allowRequest​

Default: -

A function that receives a given handshake or upgrade request as its
first parameter, and can decide whether to continue or not.

Example:

    const io = new Server(httpServer, {
      allowRequest: (req, callback) => {
        const isOriginValid = check(req);
        callback(null, isOriginValid);
      }
    });

[][]

This can also be used in conjunction with the initial_headers event, to
send a cookie to the client:

    import { serialize } from "cookie";

    const io = new Server(httpServer, {
      allowRequest: async (req, callback) => {
        const session = await fetchSession(req);
        req.session = session;
        callback(null, true);
      }
    });

    io.engine.on("initial_headers", (headers, req) => {
      if (req.session) {
        headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });
      }
    });

[][]

See also:

- how to use with express-session
- how to deal with cookies

allowUpgrades​

Default value: true

Whether to allow transport upgrades.

cookie​

Default value: -

The list of options that will be forwarded to the cookie module.
Available options:

- domain
- encode
- expires
- httpOnly
- maxAge
- path
- sameSite
- secure

Example:

    import { Server } from "socket.io";

    const io = new Server(httpServer, {
      cookie: {
        name: "my-cookie",
        httpOnly: true,
        sameSite: "strict",
        maxAge: 86400
      }
    });

[][]

[]info

Since Socket.IO v3, there is no cookie sent by default anymore
(reference).

cors​

Default value: -

The list of options that will be forwarded to the cors module. More
information can be found here.

Examples:

- allow a given origin

    const io = new Server(httpServer, {
      cors: {
        origin: ["https://example.com"]
      }
    });

[][]

- allow a given origin for local development

    const io = new Server(httpServer, {
      cors: {
        origin: process.env.NODE_ENV === "production" ? false : ["http://localhost:3000"]
      }
    });

[][]

- allow the given origins, headers and credentials (such as cookies,
  authorization headers or TLS client certificates)

    const io = new Server(httpServer, {
      cors: {
        origin: ["https://example.com", "https://dev.example.com"],
        allowedHeaders: ["my-custom-header"],
        credentials: true
      }
    });

[][]

[]note

If you want the browser to send credentials such as cookies,
authorization headers or TLS client certificates, you also need to set
withCredentials option to true on the client side:

    import { io } from "socket.io-client";

    const socket = io("https://my-backend.com", {
      withCredentials: true
    });

[][]

More information here.

- allow any origin

    const io = new Server(httpServer, {
      cors: {
        origin: "*"
      }
    });

[][]

[]danger

Please note that in that case, you are basically disabling the security
provided by Cross-Origin Resource Sharing (CORS), as any domain will be
able to reach your server. Please use with caution.

Available options:

  Option                 Description
  ---------------------- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  origin                 Configures the Access-Control-Allow-Origin CORS header.
  methods                Configures the Access-Control-Allow-Methods CORS header. Expects a comma-delimited string (ex: 'GET,PUT,POST') or an array (ex: ['GET', 'PUT', 'POST']).
  allowedHeaders         Configures the Access-Control-Allow-Headers CORS header. Expects a comma-delimited string (ex: 'Content-Type,Authorization') or an array (ex: ['Content-Type', 'Authorization']). If not specified, defaults to reflecting the headers specified in the request's Access-Control-Request-Headers header.
  exposedHeaders         Configures the Access-Control-Expose-Headers CORS header. Expects a comma-delimited string (ex: 'Content-Range,X-Content-Range') or an array (ex: ['Content-Range', 'X-Content-Range']). If not specified, no custom headers are exposed.
  credentials            Configures the Access-Control-Allow-Credentials CORS header. Set to true to pass the header, otherwise it is omitted.
  maxAge                 Configures the Access-Control-Max-Age CORS header. Set to an integer to pass the header, otherwise it is omitted.
  preflightContinue      Pass the CORS preflight response to the next handler.
  optionsSuccessStatus   Provides a status code to use for successful OPTIONS requests, since some legacy browsers (IE11, various SmartTVs) choke on 204.

Possible values for the origin option:

- Boolean - set origin to true to reflect the request origin, as defined
  by req.header('Origin'), or set it to false to disable CORS.
- String - set origin to a specific origin. For example if you set it to
  "http://example.com" only requests from "http://example.com" will be
  allowed.
- RegExp - set origin to a regular expression pattern which will be used
  to test the request origin. If it's a match, the request origin will
  be reflected. For example the pattern /example\.com$/ will reflect any
  request that is coming from an origin ending with "example.com".
- Array - set origin to an array of valid origins. Each origin can be a
  String or a RegExp. For example
  ["http://example1.com", /\.example2\.com$/] will accept any request
  from "http://example1.com" or from a subdomain of "example2.com".
- Function - set origin to a function implementing some custom logic.
  The function takes the request origin as the first parameter and a
  callback (which expects the signature err [object], allow [bool]) as
  the second.

[]note

The option is named origin (and not origins) even with multiple domains:

    const io = new Server(httpServer, {
      cors: {
        // BAD
        origins: ["https://example.com"],
        // GOOD
        origin: ["https://example.com"],
      }
    });

[][]

[]caution

You can't use origin: "*" when setting credentials: true:

    // THIS WON'T WORK
    const io = new Server(httpServer, {
      cors: {
        origin: "*",
        credentials: true
      }
    });

[][]

You will see an error like this in the browser console:

  Cross-Origin Request Blocked: The Same Origin Policy disallows reading
  the remote resource at
  ‘.../socket.io/?EIO=4&transport=polling&t=NvQfU77’. (Reason:
  Credential is not supported if the CORS header
  ‘Access-Control-Allow-Origin’ is ‘*’)

You need to either provide a list of domains (recommended solution) or
use the following method:

    const io = new Server(httpServer, {
      cors: {
        origin: (_req, callback) => {
          callback(null, true);
        },
        credentials: true
      }
    });

[][]

Please note that in that case, like with origin: "*" or origin: true,
you are basically disabling the security provided by Cross-Origin
Resource Sharing (CORS), as any domain will be able to reach your
server. Please use with caution.

httpCompression​

Added in v1.4.0

Default value: true

Whether to enable the compression for the HTTP long-polling transport.

Please note that if httpCompression is set to false, the compress flag
used when emitting (socket.compress(true).emit(...)) will be ignored
when the connection is established with HTTP long-polling requests.

All options from the Node.js zlib module are supported.

Example:

    const io = new Server(httpServer, {
      httpCompression: {
        // Engine.IO options
        threshold: 2048, // defaults to 1024
        // Node.js zlib options
        chunkSize: 8 * 1024, // defaults to 16 * 1024
        windowBits: 14, // defaults to 15
        memLevel: 7, // defaults to 8
      }
    });

[][]

maxHttpBufferSize​

Default value: 1e6 (1 MB)

This defines how many bytes a single message can be, before closing the
socket. You may increase or decrease this value depending on your needs.

    const io = new Server(httpServer, {
      maxHttpBufferSize: 1e8
    });

[][]

It matches the maxPayload option of the ws package.

perMessageDeflate​

History

  Version   Changes
  --------- --------------------------------------------------------------
  v3.0.0    The permessage-deflate extension is now disabled by default.
  v1.4.0    First implementation.

Default value: false

Whether to enable the permessage-deflate extension for the WebSocket
transport. This extension is known to add a significant overhead in
terms of performance and memory consumption, so we suggest to only
enable it if it is really needed.

Please note that if perMessageDeflate is set to false (which is the
default), the compress flag used when emitting
(socket.compress(true).emit(...)) will be ignored when the connection is
established with WebSockets, as the permessage-deflate extension cannot
be enabled on a per-message basis.

All options from the ws module are supported:

    const io = new Server(httpServer, {
      perMessageDeflate: {
        threshold: 2048, // defaults to 1024

        zlibDeflateOptions: {
          chunkSize: 8 * 1024, // defaults to 16 * 1024
        },

        zlibInflateOptions: {
          windowBits: 14, // defaults to 15
          memLevel: 7, // defaults to 8
        },

        clientNoContextTakeover: true, // defaults to negotiated value.
        serverNoContextTakeover: true, // defaults to negotiated value.
        serverMaxWindowBits: 10, // defaults to negotiated value.

        concurrencyLimit: 20, // defaults to 10
      }
    });

[][]

pingInterval​

Default value: 25000

This value is used in the heartbeat mechanism, which periodically checks
if the connection is still alive between the server and the client.

The server sends a ping packet every pingInterval ms, and if the client
does not answer with a pong within pingTimeout ms, the server considers
that the connection is closed.

Similarly, if the client does not receive a ping packet from the server
within pingInterval + pingTimeout ms, then the client also considers
that the connection is closed.

In both cases, the disconnection reason will be: ping timeout

    socket.on("disconnect", (reason) => {
      console.log(reason); // "ping timeout"
    });

[][]

[]caution

Using a small value like 1000 (one heartbeat per second) will incur some
load on your server, which might become noticeable with a few thousands
connected clients.

pingTimeout​

History

  Version   Changes
  --------- ---------------------------------------
  v4.0.0    pingTimeout now defaults to 20000 ms.
  v2.1.0    Defaults to 5000 ms.
  v1.0.0    Defaults to 60000 ms.

Default value: 20000

See above.

[]caution

Using a smaller value means that a temporarily unresponsive server might
trigger a lot of client reconnections.

On the contrary, using a bigger value means that a broken connection
will take longer to get detected (and you might get a warning on React
Native if pingInterval + pingTimeout is bigger than 60 seconds).

transports​

Default value: ["polling", "websocket"]

The low-level transports that are allowed on the server-side.

Example with WebTransport enabled:

    const io = new Server({
      transports: ["polling", "websocket", "webtransport"]
    });

[][]

Please check the WebTransport example here.

See also: client-side transports

upgradeTimeout​

Default value: 10000

This is the delay in milliseconds before an uncompleted transport
upgrade is cancelled.

wsEngine​

Default value: require("ws").Server (source code can be found here)

The WebSocket server implementation to use. Please see the documentation
here.

Example:

    const io = new Server(httpServer, {
      wsEngine: require("eiows").Server
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

API

- Socket.IO server options
  - adapter
  - cleanupEmptyChildNamespaces
  - connectionStateRecovery
  - connectTimeout
  - parser
  - path
  - serveClient
- Low-level engine options
  - addTrailingSlash
  - allowEIO3
  - allowRequest
  - allowUpgrades
  - cookie
  - cors
  - httpCompression
  - maxHttpBufferSize
  - perMessageDeflate
  - pingInterval
  - pingTimeout
  - transports
  - upgradeTimeout
  - wsEngine

=============

## doc_docs_v4_server-socket-instance_.txt

- []
- Server
- The Socket instance

Version: 4.x

On this page

The Socket instance (server-side)

A Socket is the fundamental class for interacting with the client. It
inherits all the methods of the Node.js EventEmitter, like emit, on,
once or removeListener.

[Bidirectional communication between server and client][Bidirectional
communication between server and client]

Besides:

- emitting and listening to events
- broadcasting events
- joining and leaving rooms

The Socket instance has a few attributes that may be of use in your
application:

Socket#id​

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the client-side.

    // server-side
    io.on("connection", (socket) => {
      console.log(socket.id); // ojIckSD2jqNzOqIrAGzL
    });

    // client-side
    socket.on("connect", () => {
      console.log(socket.id); // ojIckSD2jqNzOqIrAGzL
    });

[][]

[]caution

Please note that, unless connection state recovery is enabled, the id
attribute is an ephemeral ID that is not meant to be used in your
application (or only for debugging purposes) because:

- this ID is regenerated after each reconnection (for example when the
  WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if
  the client is disconnected, the messages sent from the server to this
  ID are lost)

Please use a regular session ID instead (either sent in a cookie, or
stored in the localStorage and sent in the auth payload).

See also:

- Part II of our private message guide
- How to deal with cookies

Note: you can't overwrite this identifier, as it is used in several
parts of the Socket.IO codebase.

Socket#handshake​

This object contains some details about the handshake that happens at
the beginning of the Socket.IO session.

    {
      headers: /* the headers of the initial request */
      query: /* the query params of the initial request */
      auth: /* the authentication payload */
      time: /* the date of creation (as string) */
      issued: /* the date of creation (unix timestamp) */
      url: /* the request URL string */
      address: /* the ip of the client */
      xdomain: /* whether the connection is cross-domain */
      secure: /* whether the connection is secure */
    }

[][]

Example:

    {
      "headers": {
        "user-agent": "xxxx",
        "accept": "*/*",
        "host": "example.com",
        "connection": "close"
      },
      "query": {
        "EIO": "4",
        "transport": "polling",
        "t": "NNjNltH"
      },
      "auth": {
        "token": "123"
      },
      "time": "Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)",
      "issued": 1606005226969,
      "url": "/socket.io/?EIO=4&transport=polling&t=NNjNltH",
      "address": "::ffff:1.2.3.4",
      "xdomain": false,
      "secure": true
    }

[][]

Socket#rooms​

This is a reference to the rooms the Socket is currently in.

    io.on("connection", (socket) => {
      console.log(socket.rooms); // Set { <socket.id> }
      socket.join("room1");
      console.log(socket.rooms); // Set { <socket.id>, "room1" }
    });

[][]

Socket#data​

An arbitrary object that can be used in conjunction with the
fetchSockets() utility method:

    // server A
    io.on("connection", (socket) => {
      socket.data.username = "alice";
    });

    // server B
    const sockets = await io.fetchSockets();
    console.log(sockets[0].data.username); // "alice"

[][]

More information here.

Socket#conn​

A reference to the underlying Engine.IO socket (see here).

    io.on("connection", (socket) => {
      console.log("initial transport", socket.conn.transport.name); // prints "polling"

      socket.conn.once("upgrade", () => {
        // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)
        console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"
      });

      socket.conn.on("packet", ({ type, data }) => {
        // called for each packet received
      });

      socket.conn.on("packetCreate", ({ type, data }) => {
        // called for each packet sent
      });

      socket.conn.on("drain", () => {
        // called when the write buffer is drained
      });

      socket.conn.on("close", (reason) => {
        // called when the underlying connection is closed
      });
    });

[][]

Additional attributes​

As long as you do not overwrite any existing attribute, you can attach
any attribute to the Socket instance and use it later:

    // in a middleware
    io.use(async (socket, next) => {
      try {
        const user = await fetchUser(socket);
        socket.user = user;
      } catch (e) {
        next(new Error("unknown user"));
      }
    });

    io.on("connection", (socket) => {
      console.log(socket.user);

      // in a listener
      socket.on("set username", (username) => {
        socket.username = username;
      });
    });

[][]

Socket middlewares​

Those middlewares look a lot like the usual middlewares, except that
they are called for each incoming packet:

    socket.use(([event, ...args], next) => {
      // do something with the packet (logging, authorization, rate limiting...)
      // do not forget to call next() at the end
      next();
    });

[][]

The next method can also be called with an error object. In that case,
the event will not reach the registered event handlers and an error
event will be emitted instead:

    io.on("connection", (socket) => {
      socket.use(([event, ...args], next) => {
        if (isUnauthorized(event)) {
          return next(new Error("unauthorized event"));
        }
        next();
      });

      socket.on("error", (err) => {
        if (err && err.message === "unauthorized event") {
          socket.disconnect();
        }
      });
    });

[][]

Note: this feature only exists on the server-side. For the client-side,
you might be interested in catch-all listeners.

Events​

On the server-side, the Socket instance emits two special events:

- disconnect
- disconnecting

disconnect​

This event is fired by the Socket instance upon disconnection.

    io.on("connection", (socket) => {
      socket.on("disconnect", (reason) => {
        // ...
      });
    });

[][]

Here is the list of possible reasons:

  Reason                        Description
  ----------------------------- ----------------------------------------------------------------------------------------------------------------
  server namespace disconnect   The socket was forcefully disconnected with socket.disconnect().
  client namespace disconnect   The client has manually disconnected the socket using socket.disconnect().
  server shutting down          The server is, well, shutting down.
  ping timeout                  The client did not send a PONG packet in the pingTimeout delay.
  transport close               The connection was closed (example: the user has lost connection, or the network was changed from WiFi to 4G).
  transport error               The connection has encountered an error.
  parse error                   The server has received an invalid packet from the client.
  forced close                  The server has received an invalid packet from the client.
  forced server close           The client did not join a namespace in time (see the connectTimeout option) and was forcefully closed.

disconnecting​

This event is similar to disconnect but is fired a bit earlier, when the
Socket#rooms set is not empty yet

    io.on("connection", (socket) => {
      socket.on("disconnecting", (reason) => {
        for (const room of socket.rooms) {
          if (room !== socket.id) {
            socket.to(room).emit("user has left", socket.id);
          }
        }
      });
    });

[][]

Note: those events, along with connect, connect_error, newListener and
removeListener, are special events that shouldn't be used in your
application:

    // BAD, will throw an error
    socket.emit("disconnect");

[][]

Complete API​

The complete API exposed by the Socket instance can be found here.

[]Edit this page

Last updated on Mar 28, 2025

Previous

The Server instance

Next

Middlewares

- Socket#id
- Socket#handshake
- Socket#rooms
- Socket#data
- Socket#conn
- Additional attributes
- Socket middlewares
- Events
  - disconnect
  - disconnecting
- Complete API

=============

## doc_docs_v4_server-with-bundlers_.txt

- []
- Server
- Usage with bundlers

Version: 4.x

On this page

Usage with bundlers

While less common than frontend bundling, it is totally possible to
create a bundle for the server.

Webpack 5​

Without serving the client files​

Installation:

    npm install -D webpack webpack-cli socket.io bufferutil utf-8-validate

[][]

index.js

    const { Server } = require("socket.io");

    const io = new Server({
      serveClient: false
    });

    io.on("connection", socket => {
      console.log(`connect ${socket.id}`);

      socket.on("disconnect", (reason) => {
        console.log(`disconnect ${socket.id} due to ${reason}`);
      });
    });

    io.listen(3000);

[][]

webpack.config.js

    const path = require("path");

    module.exports = {
      entry: "./index.js",
      target: "node",
      mode: "production",
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "index.js",
      }
    };

[][]

Note: bufferutil and utf-8-validate are two optional dependencies from
the ws package. You can also set them as "external" with:

    const path = require("path");

    module.exports = {
      entry: "./index.js",
      target: "node",
      mode: "production",
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "index.js",
      },
      externals: {
        bufferutil: "bufferutil",
        "utf-8-validate": "utf-8-validate",
      },
    };

[][]

Documentation: https://webpack.js.org/configuration/externals/

Including serving the client files​

In that case, we'll have to use Asset modules and override the sendFile
function of the Socket.IO server:

index.js

    const { Server } = require("socket.io");

    const clientFile = require("./node_modules/socket.io/client-dist/socket.io.min?raw");
    const clientMap = require("./node_modules/socket.io/client-dist/socket.io.min.js.map?raw");

    Server.sendFile = (filename, req, res) => {
      res.end(filename.endsWith(".map") ? clientMap : clientFile);
    };

    const io = new Server();

    io.on("connection", socket => {
      console.log(`connect ${socket.id}`);

      socket.on("disconnect", (reason) => {
        console.log(`disconnect ${socket.id} due to ${reason}`);
      });
    });

    io.listen(3000);

[][]

webpack.config.js

    const path = require("path");

    module.exports = {
      entry: "./index.js",
      target: "node",
      mode: "production",
      output: {
        path: path.resolve(__dirname, "dist"),
        filename: "index.js",
      },
      module: {
        rules: [
          {
            resourceQuery: /raw/,
            type: "asset/source",
          },
        ],
      },
    };

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Application structure

Next

Installation

- Webpack 5
  - Without serving the client files
  - Including serving the client files

=============

## doc_docs_v4_socket-io-protocol_.txt

- []
- Miscellaneous
- The Socket.IO protocol

Version: 4.x

On this page

The Socket.IO protocol

This document describes the 5th version of the Socket.IO protocol.

The source of this document can be found here.

Table of content

- Introduction
- Exchange protocol
  - Connection to a namespace
  - Sending and receiving data
  - Acknowledgement
  - Disconnection from a namespace
- Packet encoding
  - Format
  - Examples
    - Connection to a namespace
    - Sending and receiving data
    - Acknowledgement
    - Disconnection from a namespace
- Sample session
- History
  - Difference between v5 and v4
  - Difference between v4 and v3
  - Difference between v3 and v2
  - Difference between v2 and v1
  - Initial revision
- Test suite

Introduction​

The Socket.IO protocol enables full-duplex and low-overhead
communication between a client and a server.

It is built on top of the Engine.IO protocol, which handles the
low-level plumbing with WebSocket and HTTP long-polling.

The Socket.IO protocol adds the following features:

- multiplexing (referred as "namespace" in the Socket.IO jargon)

Example with the JavaScript API:

Server

    // declare the namespace
    const namespace = io.of("/admin");
    // handle the connection to the namespace
    namespace.on("connection", (socket) => {
      // ...
    });

[][]

Client

    // reach the main namespace
    const socket1 = io();
    // reach the "/admin" namespace (with the same underlying WebSocket connection)
    const socket2 = io("/admin");
    // handle the connection to the namespace
    socket2.on("connect", () => {
      // ...
    });

[][]

- acknowledgement of packets

Example with the JavaScript API:

    // on one side
    socket.emit("hello", "foo", (arg) => {
      console.log("received", arg);
    });

    // on the other side
    socket.on("hello", (arg, ack) => {
      ack("bar");
    });

[][]

The reference implementation is written in TypeScript:

- server: https://github.com/socketio/socket.io
- client: https://github.com/socketio/socket.io-client

Exchange protocol​

A Socket.IO packet contains the following fields:

- a packet type (integer)
- a namespace (string)
- optionally, a payload (Object | Array)
- optionally, an acknowledgment id (integer)

Here is the list of available packet types:

  Type            ID   Usage
  --------------- ---- -------------------------------------------------------------------
  CONNECT         0    Used during the connection to a namespace.
  DISCONNECT      1    Used when disconnecting from a namespace.
  EVENT           2    Used to send data to the other side.
  ACK             3    Used to acknowledge an event.
  CONNECT_ERROR   4    Used during the connection to a namespace.
  BINARY_EVENT    5    Used to send binary data to the other side.
  BINARY_ACK      6    Used to acknowledge an event (the response includes binary data).

Connection to a namespace​

At the beginning of a Socket.IO session, the client MUST send a CONNECT
packet:

The server MUST respond with either:

- a CONNECT packet if the connection is successful, with the session ID
  in the payload
- or a CONNECT_ERROR packet if the connection is not allowed

    CLIENT                                                      SERVER

      │  ───────────────────────────────────────────────────────►  │
      │             { type: CONNECT, namespace: "/" }              │
      │  ◄───────────────────────────────────────────────────────  │
      │   { type: CONNECT, namespace: "/", data: { sid: "..." } }  │

[][]

If the server does not receive a CONNECT packet first, then it MUST
close the connection immediately.

A client MAY be connected to multiple namespaces at the same time, with
the same underlying WebSocket connection.

Examples:

- with the main namespace (named "/")

    Client > { type: CONNECT, namespace: "/" }
    Server > { type: CONNECT, namespace: "/", data: { sid: "wZX3oN0bSVIhsaknAAAI" } }

[][]

- with a custom namespace

    Client > { type: CONNECT, namespace: "/admin" }
    Server > { type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }

[][]

- with an additional payload

    Client > { type: CONNECT, namespace: "/admin", data: { "token": "123" } }
    Server > { type: CONNECT, namespace: "/admin", data: { sid: "iLnRaVGHY4B75TeVAAAB" } }

[][]

- in case the connection is refused

    Client > { type: CONNECT, namespace: "/" }
    Server > { type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }

[][]

Sending and receiving data​

Once the connection to a namespace is established, the client and the
server can begin exchanging data:

    CLIENT                                                      SERVER

      │  ───────────────────────────────────────────────────────►  │
      │        { type: EVENT, namespace: "/", data: ["foo"] }      │
      │                                                            │
      │  ◄───────────────────────────────────────────────────────  │
      │        { type: EVENT, namespace: "/", data: ["bar"] }      │

[][]

The payload is mandatory and MUST be a non-empty array. If that's not
the case, then the receiver MUST close the connection.

Examples:

- with the main namespace

    Client > { type: EVENT, namespace: "/", data: ["foo"] }

[][]

- with a custom namespace

    Server > { type: EVENT, namespace: "/admin", data: ["bar"] }

[][]

- with binary data

    Client > { type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }

[][]

Acknowledgement​

The sender MAY include an event ID in order to request an
acknowledgement from the receiver:

    CLIENT                                                      SERVER

      │  ───────────────────────────────────────────────────────►  │
      │   { type: EVENT, namespace: "/", data: ["foo"], id: 12 }   │
      │  ◄───────────────────────────────────────────────────────  │
      │    { type: ACK, namespace: "/", data: ["bar"], id: 12 }    │

[][]

The receiver MUST respond with an ACK packet with the same event ID.

The payload is mandatory and MUST be an array (possibly empty).

Examples:

- with the main namespace

    Client > { type: EVENT, namespace: "/", data: ["foo"], id: 12 }
    Server > { type: ACK, namespace: "/", data: [], id: 12 }

[][]

- with a custom namespace

    Server > { type: EVENT, namespace: "/admin", data: ["foo"], id: 13 }
    Client > { type: ACK, namespace: "/admin", data: ["bar"], id: 13 }

[][]

- with binary data

    Client > { type: BINARY_EVENT, namespace: "/", data: ["foo", <buffer <01 02 03 04> ], id: 14 }
    Server > { type: ACK, namespace: "/", data: ["bar"], id: 14 }

    or

    Server > { type: EVENT, namespace: "/", data: ["foo" ], id: 15 }
    Client > { type: BINARY_ACK, namespace: "/", data: ["bar", <buffer <01 02 03 04>], id: 15 }

[][]

Disconnection from a namespace​

At any time, one side can end the connection to a namespace by sending a
DISCONNECT packet:

    CLIENT                                                      SERVER

      │  ───────────────────────────────────────────────────────►  │
      │           { type: DISCONNECT, namespace: "/" }             │

[][]

No response is expected from the other side. The low-level connection
MAY be kept alive if the client is connected to another namespace.

Packet encoding​

This section details the encoding used by the default parser which is
included in Socket.IO server and client, and whose source can be found
here.

The JavaScript server and client implementations also supports custom
parsers, which have different tradeoffs and may benefit to certain kind
of applications. Please see socket.io-json-parser or
socket.io-msgpack-parser for example.

Please also note that each Socket.IO packet is sent as a Engine.IO
message packet (more information here), so the encoded result will be
prefixed by the character "4" when sent over the wire (in the
request/response body with HTTP long-polling, or in the WebSocket
frame).

Format​

    <packet type>[<# of binary attachments>-][<namespace>,][<acknowledgment id>][JSON-stringified payload without binary]

    + binary attachments extracted

[][]

Note: the namespace is only included if it is different from the main
namespace (/)

Examples​

Connection to a namespace​

- with the main namespace

Packet

    { type: CONNECT, namespace: "/" }

[][]

Encoded

    0

[][]

- with a custom namespace

Packet

    { type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }

[][]

Encoded

    0/admin,{"sid":"oSO0OpakMV_3jnilAAAA"}

[][]

- in case the connection is refused

Packet

    { type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }

[][]

Encoded

    4{"message":"Not authorized"}

[][]

Sending and receiving data​

- with the main namespace

Packet

    { type: EVENT, namespace: "/", data: ["foo"] }

[][]

Encoded

    2["foo"]

[][]

- with a custom namespace

Packet

    { type: EVENT, namespace: "/admin", data: ["bar"] }

[][]

Encoded

    2/admin,["bar"]

[][]

- with binary data

Packet

    { type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }

[][]

Encoded

    51-["baz",{"_placeholder":true,"num":0}]

    + <Buffer <01 02 03 04>>

[][]

- with multiple attachments

Packet

    { type: BINARY_EVENT, namespace: "/admin", data: ["baz", <Buffer <01 02>>, <Buffer <03 04>> ] }

[][]

Encoded

    52-/admin,["baz",{"_placeholder":true,"num":0},{"_placeholder":true,"num":1}]

    + <Buffer <01 02>>
    + <Buffer <03 04>>

[][]

Please remember that each Socket.IO packet is wrapped in a Engine.IO
message packet, so they will be prefixed by the character "4" when sent
over the wire.

Example: { type: EVENT, namespace: "/", data: ["foo"] } will be sent as
42["foo"]

Acknowledgement​

- with the main namespace

Packet

    { type: EVENT, namespace: "/", data: ["foo"], id: 12 }

[][]

Encoded

    212["foo"]

[][]

- with a custom namespace

Packet

    { type: ACK, namespace: "/admin", data: ["bar"], id: 13 }

[][]

Encoded

    3/admin,13["bar"]`

[][]

- with binary data

Packet

    { type: BINARY_ACK, namespace: "/", data: ["bar", <Buffer <01 02 03 04>>], id: 15 }

[][]

Encoded

    61-15["bar",{"_placeholder":true,"num":0}]

    + <Buffer <01 02 03 04>>

[][]

Disconnection from a namespace​

- with the main namespace

Packet

    { type: DISCONNECT, namespace: "/" }

[][]

Encoded

    1

[][]

- with a custom namespace

    { type: DISCONNECT, namespace: "/admin" }

[][]

Encoded

    1/admin,

[][]

Sample session​

Here is an example of what is sent over the wire when combining both the
Engine.IO and the Socket.IO protocols.

- Request n°1 (open packet)

    GET /socket.io/?EIO=4&transport=polling&t=N8hyd6w
    < HTTP/1.1 200 OK
    < Content-Type: text/plain; charset=UTF-8
    0{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}

[][]

Details:

    0           => Engine.IO "open" packet type
    {"sid":...  => the Engine.IO handshake data

[][]

Note: the t query param is used to ensure that the request is not cached
by the browser.

- Request n°2 (namespace connection request):

    POST /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC
    < HTTP/1.1 200 OK
    < Content-Type: text/plain; charset=UTF-8
    40

[][]

Details:

    4           => Engine.IO "message" packet type
    0           => Socket.IO "CONNECT" packet type

[][]

- Request n°3 (namespace connection approval)

    GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC
    < HTTP/1.1 200 OK
    < Content-Type: text/plain; charset=UTF-8
    40{"sid":"wZX3oN0bSVIhsaknAAAI"}

[][]

- Request n°4

socket.emit('hey', 'Jude') is executed on the server:

    GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC
    < HTTP/1.1 200 OK
    < Content-Type: text/plain; charset=UTF-8
    42["hey","Jude"]

[][]

Details:

    4           => Engine.IO "message" packet type
    2           => Socket.IO "EVENT" packet type
    [...]       => content

[][]

- Request n°5 (message out)

socket.emit('hello'); socket.emit('world'); is executed on the client:

    POST /socket.io/?EIO=4&transport=polling&t=N8hzxke&sid=lv_VI97HAXpY6yYWAAAC
    > Content-Type: text/plain; charset=UTF-8
    42["hello"]\x1e42["world"]
    < HTTP/1.1 200 OK
    < Content-Type: text/plain; charset=UTF-8
    ok

[][]

Details:

    4           => Engine.IO "message" packet type
    2           => Socket.IO "EVENT" packet type
    ["hello"]   => the 1st content
    \x1e        => separator
    4           => Engine.IO "message" packet type
    2           => Socket.IO "EVENT" packet type
    ["world"]   => the 2nd content

[][]

- Request n°6 (WebSocket upgrade)

    GET /socket.io/?EIO=4&transport=websocket&sid=lv_VI97HAXpY6yYWAAAC
    < HTTP/1.1 101 Switching Protocols

[][]

WebSocket frames:

    < 2probe                                        => Engine.IO probe request
    > 3probe                                        => Engine.IO probe response
    > 5                                             => Engine.IO "upgrade" packet type
    > 42["hello"]
    > 42["world"]
    > 40/admin,                                     => request access to the admin namespace (Socket.IO "CONNECT" packet)
    < 40/admin,{"sid":"-G5j-67EZFp-q59rADQM"}       => grant access to the admin namespace
    > 42/admin,1["tellme"]                          => Socket.IO "EVENT" packet with acknowledgement
    < 461-/admin,1[{"_placeholder":true,"num":0}]   => Socket.IO "BINARY_ACK" packet with a placeholder
    < <binary>                                      => the binary attachment (sent in the following frame)
    ... after a while without message
    > 2                                             => Engine.IO "ping" packet type
    < 3                                             => Engine.IO "pong" packet type
    > 1                                             => Engine.IO "close" packet type

[][]

History​

Difference between v5 and v4​

The 5th revision (current) of the Socket.IO protocol is used in
Socket.IO v3 and above (v3.0.0 was released in November 2020).

It is built on top of the 4th revision of the Engine.IO protocol (hence
the EIO=4 query parameter).

List of changes:

- remove the implicit connection to the default namespace

In previous versions, a client was always connected to the default
namespace, even if it requested access to another namespace.

This is not the case anymore, the client must send a CONNECT packet in
any case.

Commits: 09b6f23 (server) and 249e0be (client)

- rename ERROR to CONNECT_ERROR

The meaning and the code number (4) are not modified: this packet type
is still used by the server when the connection to a namespace is
refused. But we feel the name is more self-descriptive.

Commits: d16c035 (server) and 13e1db7c (client).

- the CONNECT packet now can contain a payload

The client can send a payload for authentication/authorization purposes.
Example:

    {
      "type": 0,
      "nsp": "/admin",
      "data": {
        "token": "123"
      }
    }

[][]

In case of success, the server responds with a payload contain the ID of
the Socket. Example:

    {
      "type": 0,
      "nsp": "/admin",
      "data": {
        "sid": "CjdVH4TQvovi1VvgAC5Z"
      }
    }

[][]

This change means that the ID of the Socket.IO connection will now be
different from the ID of the underlying Engine.IO connection (the one
that is found in the query parameters of the HTTP requests).

Commits: 2875d2c (server) and bbe94ad (client)

- the payload CONNECT_ERROR packet is now an object instead of a plain
  string

Commits: 54bf4a4 (server) and 0939395 (client)

Difference between v4 and v3​

The 4th revision of the Socket.IO protocol is used in Socket.IO v1
(v1.0.3 was released in June 2014) and v2 (v2.0.0 was released in May
2017).

The details of the revision can be found here:
https://github.com/socketio/socket.io-protocol/tree/v4

It is built on top of the 3rd revision of the Engine.IO protocol (hence
the EIO=3 query parameter).

List of changes:

- add a BINARY_ACK packet type

Previously, an ACK packet was always treated as if it may contain binary
objects, with recursive search for such objects, which could hurt
performance.

Reference:
https://github.com/socketio/socket.io-parser/commit/ca4f42a922ba7078e840b1bc09fe3ad618acc065

Difference between v3 and v2​

The 3rd revision of the Socket.IO protocol is used in early Socket.IO v1
versions (socket.io@1.0.0...1.0.2) (released in May 2014).

The details of the revision can be found here:
https://github.com/socketio/socket.io-protocol/tree/v3

List of changes:

- remove the usage of msgpack to encode packets containing binary
  objects (see also 299849b)

Difference between v2 and v1​

List of changes:

- add a BINARY_EVENT packet type

This was added during the work towards Socket.IO 1.0, in order to add
support for binary objects. The BINARY_EVENT packets were encoded with
msgpack.

Initial revision​

This first revision was the result of the split between the Engine.IO
protocol (low-level plumbing with WebSocket / HTTP long-polling,
heartbeat) and the Socket.IO protocol. It was never included in a
Socket.IO release, but paved the way for the next iterations.

Test suite​

The test suite in the test-suite/ directory lets you check the
compliance of a server implementation.

Usage:

- in Node.js: npm ci && npm test
- in a browser: simply open the index.html file in your browser

For reference, here is expected configuration for the JavaScript server
to pass all tests:

    import { Server } from "socket.io";

    const io = new Server(3000, {
      pingInterval: 300,
      pingTimeout: 200,
      maxPayload: 1000000,
      cors: {
        origin: "*"
      }
    });

    io.on("connection", (socket) => {
      socket.emit("auth", socket.handshake.auth);

      socket.on("message", (...args) => {
        socket.emit.apply(socket, ["message-back", ...args]);
      });

      socket.on("message-with-ack", (...args) => {
        const ack = args.pop();
        ack(...args);
      })
    });

    io.of("/custom").on("connection", (socket) => {
      socket.emit("auth", socket.handshake.auth);
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

The Engine.IO protocol

- Introduction
- Exchange protocol
  - Connection to a namespace
  - Sending and receiving data
  - Acknowledgement
  - Disconnection from a namespace
- Packet encoding
  - Format
  - Examples
- Sample session
- History
  - Difference between v5 and v4
  - Difference between v4 and v3
  - Difference between v3 and v2
  - Difference between v2 and v1
  - Initial revision
- Test suite

=============

## doc_docs_v4_testing_.txt

- []
- Documentation
- Testing

Version: 4.x

Testing

You will find below some code examples with common testing libraries:

- mocha
- jest
- tape
- vitest

- CommonJS
- ES modules
- TypeScript

Installation:

    npm install --save-dev mocha chai

[][]

Test suite:

test/basic.js

    const { createServer } = require("node:http");
    const { Server } = require("socket.io");
    const ioc = require("socket.io-client");
    const { assert } = require("chai");

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      before((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = httpServer.address().port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      after(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          assert.equal(arg, "world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      it("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          assert.equal(arg, "hola");
          done();
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        assert.equal(result, "bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev mocha chai

[][]

Test suite:

test/basic.js

    import { createServer } from "node:http";
    import { io as ioc } from "socket.io-client";
    import { Server } from "socket.io";
    import { assert } from "chai";

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      before((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = httpServer.address().port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      after(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          assert.equal(arg, "world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      it("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          assert.equal(arg, "hola");
          done();
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        assert.equal(result, "bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev mocha chai @types/mocha @types/chai

[][]

Test suite:

test/basic.ts

    import { createServer } from "node:http";
    import { type AddressInfo } from "node:net";
    import { io as ioc, type Socket as ClientSocket } from "socket.io-client";
    import { Server, type Socket as ServerSocket } from "socket.io";
    import { assert } from "chai";

    function waitFor(socket: ServerSocket | ClientSocket, event: string) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;

      before((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = (httpServer.address() as AddressInfo).port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      after(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          assert.equal(arg, "world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      it("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          assert.equal(arg, "hola");
          done();
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        assert.equal(result, "bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Reference: https://mochajs.org/

- CommonJS
- ES modules
- TypeScript

Installation:

    npm install --save-dev jest

[][]

Test suite:

__tests__/basic.test.js

    const { createServer } = require("node:http");
    const { Server } = require("socket.io");
    const ioc = require("socket.io-client");

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      beforeAll((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = httpServer.address().port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      test("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          expect(arg).toBe("world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      test("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          expect(arg).toBe("hola");
          done();
        });
      });

      test("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toBe("bar");
      });

      test("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev jest

[][]

Test suite:

__tests__/basic.test.js

    import { createServer } from "node:http";
    import { io as ioc } from "socket.io-client";
    import { Server } from "socket.io";

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      beforeAll((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = httpServer.address().port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      test("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          expect(arg).toBe("world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      test("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          expect(arg).toBe("hola");
          done();
        });
      });

      test("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toBe("bar");
      });

      test("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev jest @types/jest

[][]

Test suite:

__tests__/basic.test.ts

    import { createServer } from "node:http";
    import { type AddressInfo } from "node:net";
    import { io as ioc, type Socket as ClientSocket } from "socket.io-client";
    import { Server, type Socket as ServerSocket } from "socket.io";

    function waitFor(socket: ServerSocket | ClientSocket, event: string) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      beforeAll((done) => {
        const httpServer = createServer();
        io = new Server(httpServer);
        httpServer.listen(() => {
          const port = (httpServer.address() as AddressInfo).port;
          clientSocket = ioc(`http://localhost:${port}`);
          io.on("connection", (socket) => {
            serverSocket = socket;
          });
          clientSocket.on("connect", done);
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      test("should work", (done) => {
        clientSocket.on("hello", (arg) => {
          expect(arg).toBe("world");
          done();
        });
        serverSocket.emit("hello", "world");
      });

      test("should work with an acknowledgement", (done) => {
        serverSocket.on("hi", (cb) => {
          cb("hola");
        });
        clientSocket.emit("hi", (arg) => {
          expect(arg).toBe("hola");
          done();
        });
      });

      test("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toBe("bar");
      });

      test("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Reference: https://jestjs.io/

- CommonJS
- ES modules
- TypeScript

Installation:

    npm install --save-dev tape

[][]

Test suite:

test/basic.js

    const test = require("tape");
    const { createServer } = require("node:http");
    const { Server } = require("socket.io");
    const ioc = require("socket.io-client");

    let io, serverSocket, clientSocket;

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    test("setup", (t) => {
      const httpServer = createServer();
      io = new Server(httpServer);
      httpServer.listen(() => {
        const port = httpServer.address().port;
        clientSocket = ioc(`http://localhost:${port}`);
        io.on("connection", (socket) => {
          serverSocket = socket;
        });
        clientSocket.on("connect", t.end);
      });
    });

    test("it works", (t) => {
      t.plan(1);
      clientSocket.on("hello", (arg) => {
        t.equal(arg, "world");
      });
      serverSocket.emit("hello", "world");
    });

    test("it works with an acknowledgement", (t) => {
      t.plan(1);
      serverSocket.on("hi", (cb) => {
        cb("hola");
      });
      clientSocket.emit("hi", (arg) => {
        t.equal(arg, "hola");
      });
    });

    test("it works with emitWithAck()", async (t) => {
      t.plan(1);
      serverSocket.on("foo", (cb) => {
        cb("bar");
      });
      const result = await clientSocket.emitWithAck("foo");
      t.equal(result, "bar");
    });

    test("it works with waitFor()", async (t) => {
      t.plan(1);
      clientSocket.emit("baz");

      await waitFor(serverSocket, "baz");
      t.pass();
    });

    test.onFinish(() => {
      io.close();
      clientSocket.disconnect();
    });

[][]

Installation:

    npm install --save-dev tape

[][]

Test suite:

test/basic.js

    import { test } from "tape";
    import { createServer } from "node:http";
    import { io as ioc } from "socket.io-client";
    import { Server } from "socket.io";

    let io, serverSocket, clientSocket;

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    test("setup", (t) => {
      const httpServer = createServer();
      io = new Server(httpServer);
      httpServer.listen(() => {
        const port = httpServer.address().port;
        clientSocket = ioc(`http://localhost:${port}`);
        io.on("connection", (socket) => {
          serverSocket = socket;
        });
        clientSocket.on("connect", t.end);
      });
    });

    test("it works", (t) => {
      t.plan(1);
      clientSocket.on("hello", (arg) => {
        t.equal(arg, "world");
      });
      serverSocket.emit("hello", "world");
    });

    test("it works with an acknowledgement", (t) => {
      t.plan(1);
      serverSocket.on("hi", (cb) => {
        cb("hola");
      });
      clientSocket.emit("hi", (arg) => {
        t.equal(arg, "hola");
      });
    });

    test("it works with emitWithAck()", async (t) => {
      t.plan(1);
      serverSocket.on("foo", (cb) => {
        cb("bar");
      });
      const result = await clientSocket.emitWithAck("foo");
      t.equal(result, "bar");
    });

    test("it works with waitFor()", async (t) => {
      t.plan(1);
      clientSocket.emit("baz");

      await waitFor(serverSocket, "baz");
      t.pass();
    });

    test.onFinish(() => {
      io.close();
      clientSocket.disconnect();
    });

[][]

Installation:

    npm install --save-dev tape

[][]

Test suite:

test/basic.ts

    import { test } from "tape";
    import { createServer } from "node:http";
    import { type AddressInfo } from "node:net";
    import { io as ioc, type Socket as ClientSocket } from "socket.io-client";
    import { Server, type Socket as ServerSocket } from "socket.io";

    let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;

    function waitFor(socket: ServerSocket | ClientSocket, event: string) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    test("setup", (t) => {
      const httpServer = createServer();
      io = new Server(httpServer);
      httpServer.listen(() => {
        const port = (httpServer.address() as AddressInfo).port;
        clientSocket = ioc(`http://localhost:${port}`);
        io.on("connection", (socket) => {
          serverSocket = socket;
        });
        clientSocket.on("connect", t.end);
      });
    });

    test("it works", (t) => {
      t.plan(1);
      clientSocket.on("hello", (arg) => {
        t.equal(arg, "world");
      });
      serverSocket.emit("hello", "world");
    });

    test("it works with an acknowledgement", (t) => {
      t.plan(1);
      serverSocket.on("hi", (cb) => {
        cb("hola");
      });
      clientSocket.emit("hi", (arg) => {
        t.equal(arg, "hola");
      });
    });

    test("it works with emitWithAck()", async (t) => {
      t.plan(1);
      serverSocket.on("foo", (cb) => {
        cb("bar");
      });
      const result = await clientSocket.emitWithAck("foo");
      t.equal(result, "bar");
    });

    test("it works with waitFor()", async (t) => {
      t.plan(1);
      clientSocket.emit("baz");

      await waitFor(serverSocket, "baz");
      t.pass();
    });

    test.onFinish(() => {
      io.close();
      clientSocket.disconnect();
    });

[][]

Reference: https://github.com/ljharb/tape

- CommonJS
- ES modules
- TypeScript

Installation:

    npm install --save-dev vitest

[][]

Test suite:

test/basic.js

    const { beforeAll, afterAll, describe, it, expect } = require("vitest");
    const { createServer } = require("node:http");
    const { Server } = require("socket.io");
    const ioc = require("socket.io-client");

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      beforeAll(() => {
        return new Promise((resolve) => {
          const httpServer = createServer();
          io = new Server(httpServer);
          httpServer.listen(() => {
            const port = httpServer.address().port;
            clientSocket = ioc(`http://localhost:${port}`);
            io.on("connection", (socket) => {
              serverSocket = socket;
            });
            clientSocket.on("connect", resolve);
          });
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", () => {
        return new Promise((resolve) => {
          clientSocket.on("hello", (arg) => {
            expect(arg).toEqual("world");
            resolve();
          });
          serverSocket.emit("hello", "world");
        });
      });

      it("should work with an acknowledgement", () => {
        return new Promise((resolve) => {
          serverSocket.on("hi", (cb) => {
            cb("hola");
          });
          clientSocket.emit("hi", (arg) => {
            expect(arg).toEqual("hola");
            resolve();
          });
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toEqual("bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev vitest

[][]

Test suite:

test/basic.js

    import { beforeAll, afterAll, describe, it, expect } from "vitest";
    import { createServer } from "node:http";
    import { io as ioc } from "socket.io-client";
    import { Server } from "socket.io";

    function waitFor(socket, event) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io, serverSocket, clientSocket;

      beforeAll(() => {
        return new Promise((resolve) => {
          const httpServer = createServer();
          io = new Server(httpServer);
          httpServer.listen(() => {
            const port = httpServer.address().port;
            clientSocket = ioc(`http://localhost:${port}`);
            io.on("connection", (socket) => {
              serverSocket = socket;
            });
            clientSocket.on("connect", resolve);
          });
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", () => {
        return new Promise((resolve) => {
          clientSocket.on("hello", (arg) => {
            expect(arg).toEqual("world");
            resolve();
          });
          serverSocket.emit("hello", "world");
        });
      });

      it("should work with an acknowledgement", () => {
        return new Promise((resolve) => {
          serverSocket.on("hi", (cb) => {
            cb("hola");
          });
          clientSocket.emit("hi", (arg) => {
            expect(arg).toEqual("hola");
            resolve();
          });
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toEqual("bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Installation:

    npm install --save-dev vitest

[][]

Test suite:

test/basic.ts

    import { beforeAll, afterAll, describe, it, expect } from "vitest";
    import { createServer } from "node:http";
    import { type AddressInfo } from "node:net";
    import { io as ioc, type Socket as ClientSocket } from "socket.io-client";
    import { Server, type Socket as ServerSocket } from "socket.io";

    function waitFor(socket: ServerSocket | ClientSocket, event: string) {
      return new Promise((resolve) => {
        socket.once(event, resolve);
      });
    }

    describe("my awesome project", () => {
      let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;

      beforeAll(() => {
        return new Promise((resolve) => {
          const httpServer = createServer();
          io = new Server(httpServer);
          httpServer.listen(() => {
            const port = (httpServer.address() as AddressInfo).port;
            clientSocket = ioc(`http://localhost:${port}`);
            io.on("connection", (socket) => {
              serverSocket = socket;
            });
            clientSocket.on("connect", resolve);
          });
        });
      });

      afterAll(() => {
        io.close();
        clientSocket.disconnect();
      });

      it("should work", () => {
        return new Promise((resolve) => {
          clientSocket.on("hello", (arg) => {
            expect(arg).toEqual("world");
            resolve();
          });
          serverSocket.emit("hello", "world");
        });
      });

      it("should work with an acknowledgement", () => {
        return new Promise((resolve) => {
          serverSocket.on("hi", (cb) => {
            cb("hola");
          });
          clientSocket.emit("hi", (arg) => {
            expect(arg).toEqual("hola");
            resolve();
          });
        });
      });

      it("should work with emitWithAck()", async () => {
        serverSocket.on("foo", (cb) => {
          cb("bar");
        });
        const result = await clientSocket.emitWithAck("foo");
        expect(result).toEqual("bar");
      });

      it("should work with waitFor()", () => {
        clientSocket.emit("baz");

        return waitFor(serverSocket, "baz");
      });
    });

[][]

Reference: https://vitest.dev/

[]Edit this page

Last updated on Mar 28, 2025

Previous

Logging and debugging

Next

Troubleshooting

=============

## doc_docs_v4_troubleshooting-connection-issues_.txt

- []
- Documentation
- Troubleshooting

Version: 4.x

On this page

Troubleshooting connection issues

[]tip

The Admin UI can give you additional insights about the status of your
Socket.IO deployment.

Common/known issues:

- the socket is not able to connect
- the socket gets disconnected
- the socket is stuck in HTTP long-polling

Other common gotchas:

- Duplicate event registration
- Delayed event handler registration
- Usage of the socket.id attribute
- Deployment on a serverless platform

Problem: the socket is not able to connect​

Troubleshooting steps​

On the client side, the connect_error event provides additional
information:

    socket.on("connect_error", (err) => {
      // the reason of the error, for example "xhr poll error"
      console.log(err.message);

      // some additional description, for example the status code of the initial HTTP response
      console.log(err.description);

      // some additional context, for example the XMLHttpRequest object
      console.log(err.context);
    });

[][]

On the server side, the connection_error event may also provide some
additional insights:

    io.engine.on("connection_error", (err) => {
      console.log(err.req);      // the request object
      console.log(err.code);     // the error code, for example 1
      console.log(err.message);  // the error message, for example "Session ID unknown"
      console.log(err.context);  // some additional error context
    });

[][]

Here is the list of possible error codes:

   Code              Message              Possible explanations
  ------ -------------------------------- -----------------------------------------------------------------------------------------------------------------------
    0          "Transport unknown"        This should not happen under normal circumstances.
    1          "Session ID unknown"       Usually, this means that sticky sessions are not enabled (see below).
    2         "Bad handshake method"      This should not happen under normal circumstances.
    3             "Bad request"           Usually, this means that a proxy in front of your server is not properly forwarding the WebSocket headers (see here).
    4              "Forbidden"            The connection was denied by the allowRequest() method.
    5     "Unsupported protocol version"  The version of the client is not compatible with the server (see here).

Possible explanations​

You are trying to reach a plain WebSocket server​

As explained in the "What Socket.IO is not" section, the Socket.IO
client is not a WebSocket implementation and thus will not be able to
establish a connection with a WebSocket server, even with
transports: ["websocket"]:

    const socket = io("ws://echo.websocket.org", {
      transports: ["websocket"]
    });

[][]

The server is not reachable​

Please make sure the Socket.IO server is actually reachable at the given
URL. You can test it with:

    curl "<the server URL>/socket.io/?EIO=4&transport=polling"

[][]

which should return something like this:

    0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}

[][]

If that's not the case, please check that the Socket.IO server is
running, and that there is nothing in between that prevents the
connection.

[]note

v1/v2 servers (which implement the v3 of the protocol, hence the EIO=3)
will return something like this:

    96:0{"sid":"ptzi_578ycUci8WLB9G1","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40

[][]

The client is not compatible with the version of the server​

Maintaining backward compatibility is a top priority for us, but in some
particular cases we had to implement some breaking changes at the
protocol level:

- from v1.x to v2.0.0 (released in May 2017), to improve the
  compatibility with non-Javascript clients (see here)
- from v2.x to v3.0.0 (released in November 2020), to fix some
  long-standing issues in the protocol once for all (see here)

[]info

v4.0.0 contains some breaking changes in the API of the JavaScript
server. The Socket.IO protocol itself was not updated, so a v3 client
will be able to reach a v4 server and vice-versa (see here).

For example, reaching a v3/v4 server with a v1/v2 client will result in
the following response:

    < HTTP/1.1 400 Bad Request
    < Content-Type: application/json

    {"code":5,"message":"Unsupported protocol version"}

[][]

Here is the compatibility table for the JS client:

   JS Client version   Socket.IO server version               
  ------------------- -------------------------- ----- ------ ------
          1.x                    2.x              3.x   4.x   
          1.x                    YES              NO     NO   NO
          2.x                     NO              YES   YES¹  YES¹
          3.x                     NO              NO    YES   YES
          4.x                     NO              NO    YES   YES

[1] Yes, with allowEIO3: true

Here is the compatibility table for the Java client:

   Java Client version   Socket.IO server version         
  --------------------- -------------------------- ------ ------
           2.x                     3.x              4.x   
           1.x                     YES              YES¹  YES¹
           2.x                      NO              YES   YES

[1] Yes, with allowEIO3: true

Here is the compatibility table for the Swift client:

   Swift Client version   Socket.IO server version         
  ---------------------- -------------------------- ------ ------
           2.x                      3.x              4.x   
          v15.x                     YES              YES¹  YES²
          v16.x                     YES³             YES   YES

[1] Yes, with allowEIO3: true (server) and .connectParams(["EIO": "3"])
(client):

    SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.connectParams(["EIO": "3"])])

[][]

[2] Yes, allowEIO3: true (server)

[3] Yes, with .version(.two) (client):

    SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.version(.two)])

[][]

The server does not send the necessary CORS headers​

If you see the following error in your console:

    Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...

[][]

It probably means that:

- either you are not actually reaching the Socket.IO server (see above)
- or you didn't enable Cross-Origin Resource Sharing (CORS) on the
  server-side.

Please see the documentation here.

You didn't enable sticky sessions (in a multi server setup)​

When scaling to multiple Socket.IO servers, you need to make sure that
all the requests of a given Socket.IO session reach the same Socket.IO
server. The explanation can be found here.

Failure to do so will result in HTTP 400 responses with the code:
{"code":1,"message":"Session ID unknown"}

Please see the documentation here.

The request path does not match on both sides​

By default, the client sends — and the server expects — HTTP requests
with the "/socket.io/" request path.

This can be controlled with the path option:

Server

    import { Server } from "socket.io";

    const io = new Server({
      path: "/my-custom-path/"
    });

    io.listen(3000);

[][]

Client

    import { io } from "socket.io-client";

    const socket = io(SERVER_URL, {
      path: "/my-custom-path/"
    });

[][]

In that case, the HTTP requests will look like
<SERVER_URL>/my-custom-path/?EIO=4&transport=polling[&...].

[]caution

    import { io } from "socket.io-client";

    const socket = io("/my-custom-path/");

[][]

means the client will try to reach the namespace named
"/my-custom-path/", but the request path will still be "/socket.io/".

Problem: the socket gets disconnected​

Troubleshooting steps​

First and foremost, please note that disconnections are common and
expected, even on a stable Internet connection:

- anything between the user and the Socket.IO server may encounter a
  temporary failure or be restarted
- the server itself may be killed as part of an autoscaling policy
- the user may lose connection or switch from WiFi to 4G, in case of a
  mobile browser
- the browser itself may freeze an inactive tab

That being said, the Socket.IO client will always try to reconnect,
unless specifically told otherwise.

The disconnect event provides additional information:

    socket.on("disconnect", (reason, details) => {
      // the reason of the disconnection, for example "transport error"
      console.log(reason);

      // the low-level reason of the disconnection, for example "xhr post error"
      console.log(details.message);

      // some additional description, for example the status code of the HTTP response
      console.log(details.description);

      // some additional context, for example the XMLHttpRequest object
      console.log(details.context);
    });

[][]

The possible reasons are listed here.

Possible explanations​

Something between the server and the client closes the connection​

If the disconnection happens at a regular interval, this might indicate
that something between the server and the client is not properly
configured and closes the connection:

- nginx

The value of nginx's proxy_read_timeout (60 seconds by default) must be
bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by
default), else it will forcefully close the connection if no data is
sent after the given delay and the client will get a "transport close"
error.

- Apache HTTP Server

The value of httpd's ProxyTimeout (60 seconds by default) must be bigger
than Socket.IO's pingInterval + pingTimeout (45 seconds by default),
else it will forcefully close the connection if no data is sent after
the given delay and the client will get a "transport close" error.

The browser tab was minimized and heartbeat has failed​

When a browser tab is not in focus, some browsers (like Chrome) throttle
JavaScript timers, which could lead to a disconnection by ping timeout
in Socket.IO v2, as the heartbeat mechanism relied on setTimeout
function on the client side.

As a workaround, you can increase the pingTimeout value on the server
side:

    const io = new Server({
      pingTimeout: 60000
    });

[][]

Please note that upgrading to Socket.IO v4 (at least
socket.io-client@4.1.3, due to this) should prevent this kind of issues,
as the heartbeat mechanism has been reversed (the server now sends PING
packets).

The client is not compatible with the version of the server​

Since the format of the packets sent over the WebSocket transport is
similar in v2 and v3/v4, you might be able to connect with an
incompatible client (see above), but the connection will eventually be
closed after a given delay.

So if you are experiencing a regular disconnection after 30 seconds
(which was the sum of the values of pingTimeout and pingInterval in
Socket.IO v2), this is certainly due to a version incompatibility.

You are trying to send a huge payload​

If you get disconnected while sending a huge payload, this may mean that
you have reached the maxHttpBufferSize value, which defaults to 1 MB.
Please adjust it according to your needs:

    const io = require("socket.io")(httpServer, {
      maxHttpBufferSize: 1e8
    });

[][]

A huge payload taking more time to upload than the value of the
pingTimeout option can also trigger a disconnection (since the heartbeat
mechanism fails during the upload). Please adjust it according to your
needs:

    const io = require("socket.io")(httpServer, {
      pingTimeout: 60000
    });

[][]

Problem: the socket is stuck in HTTP long-polling​

Troubleshooting steps​

In most cases, you should see something like this:

[Network monitor upon success]

1.  the Engine.IO handshake (contains the session ID — here,
    zBjrh...AAAK — that is used in subsequent requests)
2.  the Socket.IO handshake request (contains the value of the auth
    option)
3.  the Socket.IO handshake response (contains the Socket#id)
4.  the WebSocket connection
5.  the first HTTP long-polling request, which is closed once the
    WebSocket connection is established

If you don't see a HTTP 101 Switching Protocols response for the 4th
request, that means that something between the server and your browser
is preventing the WebSocket connection.

Please note that this is not necessarily blocking since the connection
is still established with HTTP long-polling, but it is less efficient.

You can get the name of the current transport with:

Client-side

    socket.on("connect", () => {
      const transport = socket.io.engine.transport.name; // in most cases, "polling"

      socket.io.engine.on("upgrade", () => {
        const upgradedTransport = socket.io.engine.transport.name; // in most cases, "websocket"
      });
    });

[][]

Server-side

    io.on("connection", (socket) => {
      const transport = socket.conn.transport.name; // in most cases, "polling"

      socket.conn.on("upgrade", () => {
        const upgradedTransport = socket.conn.transport.name; // in most cases, "websocket"
      });
    });

[][]

Possible explanations​

A proxy in front of your servers does not accept the WebSocket connection​

If a proxy like nginx or Apache HTTPD is not properly configured to
accept WebSocket connections, then you might get a TRANSPORT_MISMATCH
error:

    io.engine.on("connection_error", (err) => {
      console.log(err.code);     // 3
      console.log(err.message);  // "Bad request"
      console.log(err.context);  // { name: 'TRANSPORT_MISMATCH', transport: 'websocket', previousTransport: 'polling' }
    });

[][]

Which means that the Socket.IO server does not receive the necessary
Connection: upgrade header (you can check the err.req.headers object).

Please see the documentation here.

express-status-monitor runs its own socket.io instance​

Please see the solution here.

Other common gotchas​

Duplicate event registration​

On the client side, the connect event will be emitted every time the
socket reconnects, so the event listeners must be registered outside the
connect event listener:

BAD ⚠️

    socket.on("connect", () => {
      socket.on("foo", () => {
        // ...
      });
    });

[][]

GOOD 👍

    socket.on("connect", () => {
      // ...
    });

    socket.on("foo", () => {
      // ...
    });

[][]

If that's not the case, your event listener might be called multiple
times.

Delayed event handler registration​

BAD ⚠️

    io.on("connection", async (socket) => {
      await longRunningOperation();

      // WARNING! Some packets might be received by the server but without handler
      socket.on("hello", () => {
        // ...
      });
    });

[][]

GOOD 👍

    io.on("connection", async (socket) => {
      socket.on("hello", () => {
        // ...
      });

      await longRunningOperation();
    });

[][]

Usage of the socket.id attribute​

Please note that, unless connection state recovery is enabled, the id
attribute is an ephemeral ID that is not meant to be used in your
application (or only for debugging purposes) because:

- this ID is regenerated after each reconnection (for example when the
  WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if
  the client is disconnected, the messages sent from the server to this
  ID are lost)

Please use a regular session ID instead (either sent in a cookie, or
stored in the localStorage and sent in the auth payload).

See also:

- Part II of our private message guide
- How to deal with cookies

Deployment on a serverless platform​

Since most serverless platforms (such as Vercel) bill by the duration of
the request handler, maintaining a long-running connection with
Socket.IO (or even plain WebSocket) is not recommended.

References:

- https://vercel.com/guides/do-vercel-serverless-functions-support-websocket-connections
- https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html

[]Edit this page

Last updated on Mar 28, 2025

Previous

Testing

Next

TypeScript

- Problem: the socket is not able to connect
  - Troubleshooting steps
  - Possible explanations
    - You are trying to reach a plain WebSocket server
    - The server is not reachable
    - The client is not compatible with the version of the server
    - The server does not send the necessary CORS headers
    - You didn't enable sticky sessions (in a multi server setup)
    - The request path does not match on both sides
- Problem: the socket gets disconnected
  - Troubleshooting steps
  - Possible explanations
    - Something between the server and the client closes the connection
    - The browser tab was minimized and heartbeat has failed
    - The client is not compatible with the version of the server
    - You are trying to send a huge payload
- Problem: the socket is stuck in HTTP long-polling
  - Troubleshooting steps
  - Possible explanations
    - A proxy in front of your servers does not accept the WebSocket
      connection
    - express-status-monitor runs its own socket.io instance
- Other common gotchas
  - Duplicate event registration
  - Delayed event handler registration
  - Usage of the socket.id attribute
  - Deployment on a serverless platform

=============

## doc_docs_v4_tutorial_ending-notes.txt

- []
- Ending notes

Version: 4.x

On this page

Ending notes

Final server code​

- CommonJS
- ES modules

index.js

    const express = require('express');
    const { createServer } = require('node:http');
    const { join } = require('node:path');
    const { Server } = require('socket.io');
    const sqlite3 = require('sqlite3');
    const { open } = require('sqlite');
    const { availableParallelism } = require('node:os');
    const cluster = require('node:cluster');
    const { createAdapter, setupPrimary } = require('@socket.io/cluster-adapter');

    if (cluster.isPrimary) {
      const numCPUs = availableParallelism();
      for (let i = 0; i < numCPUs; i++) {
        cluster.fork({
          PORT: 3000 + i
        });
      }

      return setupPrimary();
    }

    async function main() {
      const db = await open({
        filename: 'chat.db',
        driver: sqlite3.Database
      });

      await db.exec(`
        CREATE TABLE IF NOT EXISTS messages (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          client_offset TEXT UNIQUE,
          content TEXT
        );
      `);

      const app = express();
      const server = createServer(app);
      const io = new Server(server, {
        connectionStateRecovery: {},
        adapter: createAdapter()
      });

      app.get('/', (req, res) => {
        res.sendFile(join(__dirname, 'index.html'));
      });

      io.on('connection', async (socket) => {
        socket.on('chat message', async (msg, clientOffset, callback) => {
          let result;
          try {
            result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);
          } catch (e) {
            if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {
              callback();
            } else {
              // nothing to do, just let the client retry
            }
            return;
          }
          io.emit('chat message', msg, result.lastID);
          callback();
        });

        if (!socket.recovered) {
          try {
            await db.each('SELECT id, content FROM messages WHERE id > ?',
              [socket.handshake.auth.serverOffset || 0],
              (_err, row) => {
                socket.emit('chat message', row.content, row.id);
              }
            )
          } catch (e) {
            // something went wrong
          }
        }
      });

      const port = process.env.PORT;

      server.listen(port, () => {
        console.log(`server running at http://localhost:${port}`);
      });
    }

    main();

[][]

index.js

    import express from 'express';
    import { createServer } from 'node:http';
    import { fileURLToPath } from 'node:url';
    import { dirname, join } from 'node:path';
    import { Server } from 'socket.io';
    import sqlite3 from 'sqlite3';
    import { open } from 'sqlite';
    import { availableParallelism } from 'node:os';
    import cluster from 'node:cluster';
    import { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';

    if (cluster.isPrimary) {
      const numCPUs = availableParallelism();
      for (let i = 0; i < numCPUs; i++) {
        cluster.fork({
          PORT: 3000 + i
        });
      }

      setupPrimary();
    } else {
      const db = await open({
        filename: 'chat.db',
        driver: sqlite3.Database
      });

      await db.exec(`
        CREATE TABLE IF NOT EXISTS messages (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          client_offset TEXT UNIQUE,
          content TEXT
        );
      `);

      const app = express();
      const server = createServer(app);
      const io = new Server(server, {
        connectionStateRecovery: {},
        adapter: createAdapter()
      });

      const __dirname = dirname(fileURLToPath(import.meta.url));

      app.get('/', (req, res) => {
        res.sendFile(join(__dirname, 'index.html'));
      });

      io.on('connection', async (socket) => {
        socket.on('chat message', async (msg, clientOffset, callback) => {
          let result;
          try {
            result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);
          } catch (e) {
            if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {
              callback();
            } else {
              // nothing to do, just let the client retry
            }
            return;
          }
          io.emit('chat message', msg, result.lastID);
          callback();
        });

        if (!socket.recovered) {
          try {
            await db.each('SELECT id, content FROM messages WHERE id > ?',
              [socket.handshake.auth.serverOffset || 0],
              (_err, row) => {
                socket.emit('chat message', row.content, row.id);
              }
            )
          } catch (e) {
            // something went wrong
          }
        }
      });

      const port = process.env.PORT;

      server.listen(port, () => {
        console.log(`server running at http://localhost:${port}`);
      });
    }

[][]

Final client code​

- ES6
- ES5

index.html

    <!DOCTYPE html>
    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>Socket.IO chat</title>
        <style>
          body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }

          #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }
          #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }
          #input:focus { outline: none; }
          #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }

          #messages { list-style-type: none; margin: 0; padding: 0; }
          #messages > li { padding: 0.5rem 1rem; }
          #messages > li:nth-child(odd) { background: #efefef; }
        </style>
      </head>
      <body>
        <ul id="messages"></ul>
        <form id="form" action="">
          <input id="input" autocomplete="off" /><button>Send</button>
        </form>
        <script src="/socket.io/socket.io.js"></script>
        <script>
          let counter = 0;
      
          const socket = io({
            ackTimeout: 10000,
            retries: 3,
            auth: {
              serverOffset: 0
            }
          });
      
          const form = document.getElementById('form');
          const input = document.getElementById('input');
          const messages = document.getElementById('messages');
      
          form.addEventListener('submit', (e) => {
            e.preventDefault();
            if (input.value) {
              const clientOffset = `${socket.id}-${counter++}`;
              socket.emit('chat message', input.value, clientOffset);
              input.value = '';
            }
          });
      
          socket.on('chat message', (msg, serverOffset) => {
            const item = document.createElement('li');
            item.textContent = msg;
            messages.appendChild(item);
            window.scrollTo(0, document.body.scrollHeight);
            socket.auth.serverOffset = serverOffset;
          });
        </script>
      </body>
    </html>

[][]

index.html

    <!DOCTYPE html>
    <html>
      <head>
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
        <title>Socket.IO chat</title>
        <style>
          body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }

          #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }
          #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }
          #input:focus { outline: none; }
          #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }

          #messages { list-style-type: none; margin: 0; padding: 0; }
          #messages > li { padding: 0.5rem 1rem; }
          #messages > li:nth-child(odd) { background: #efefef; }
        </style>
      </head>
      <body>
        <ul id="messages"></ul>
        <form id="form" action="">
          <input id="input" autocomplete="off" /><button>Send</button>
        </form>
        <script src="/socket.io/socket.io.js"></script>
        <script>
          var counter = 0;
      
          var socket = io({
            ackTimeout: 10000,
            retries: 3,
            auth: {
              serverOffset: 0
            }
          });
      
          var form = document.getElementById('form');
          var input = document.getElementById('input');
          var messages = document.getElementById('messages');
      
          form.addEventListener('submit', function(e) {
            e.preventDefault();
            if (input.value) {
              const clientOffset = `${socket.id}-${counter++}`;
              socket.emit('chat message', input.value, clientOffset);
              input.value = '';
            }
          });
      
          socket.on('chat message', function(msg, serverOffset) {
            var item = document.createElement('li');
            item.textContent = msg;
            messages.appendChild(item);
            window.scrollTo(0, document.body.scrollHeight);
            socket.auth.serverOffset = serverOffset;
          });
        </script>
      </body>
    </html>

[][]

Homework​

Here are some ideas to improve the application:

- Broadcast a message to connected users when someone connects or
  disconnects.
- Add support for nicknames.
- Don’t send the same message to the user that sent it. Instead, append
  the message directly as soon as they press enter.
- Add “{user} is typing” functionality.
- Show who’s online.
- Add private messaging.
- Share your improvements!

Getting this example​

You can find it on GitHub here.

    git clone https://github.com/socketio/chat-example.git

[][]

Next steps​

Please check out:

- our other examples
- our Troubleshooting guide
- the Emit cheatsheet
- the complete Server API
- the complete Client API
- the different sections of our guide

[]Edit this page

Last updated on Mar 28, 2025

Previous

Step #9: Scaling horizontally

- Final server code
- Final client code
- Homework
- Getting this example
- Next steps

=============

## doc_docs_v4_tutorial_introduction.txt

- []
- Introduction

Version: 4.x

On this page

Getting started

Welcome to the Socket.IO tutorial!

In this tutorial we'll create a basic chat application. It requires
almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal
for users of all knowledge levels.

Introduction​

Writing a chat application with popular web applications stacks like
LAMP (PHP) has normally been very hard. It involves polling the server
for changes, keeping track of timestamps, and it’s a lot slower than it
should be.

Sockets have traditionally been the solution around which most real-time
chat systems are architected, providing a bi-directional communication
channel between a client and a server.

This means that the server can push messages to clients. Whenever you
write a chat message, the idea is that the server will get it and push
it to all other connected clients.

How to use this tutorial​

Tooling​

Any text editor (from a basic text editor to a complete IDE such as VS
Code) should be sufficient to complete this tutorial.

Additionally, at the end of each step you will find a link to some
online platforms (CodeSandbox and StackBlitz, namely), allowing you to
run the code directly from your browser:

[Screenshot of the CodeSandbox platform]

Syntax settings​

In the Node.js world, there are two ways to import modules:

- the standard way: ECMAScript modules (or ESM)

    import { Server } from "socket.io";

[][]

Reference: https://nodejs.org/api/esm.html

- the legacy way: CommonJS

    const { Server } = require("socket.io");

[][]

Reference: https://nodejs.org/api/modules.html

Socket.IO supports both syntax.

[]tip

We recommend using the ESM syntax in your project, though this might not
always be feasible due to some packages not supporting this syntax.

For your convenience, throughout the tutorial, each code block allows
you to select your preferred syntax:

- CommonJS
- ES modules

    const { Server } = require("socket.io");

[][]

    import { Server } from "socket.io";

[][]

Ready? Click "Next" to get started.

[]Edit this page

Last updated on Mar 28, 2025

Next

Step #1: Project initialization

- Introduction
- How to use this tutorial
  - Tooling
  - Syntax settings

=============

## doc_docs_v4_typescript_.txt

- []
- Documentation
- TypeScript

Version: 4.x

On this page

TypeScript

Starting with v3, Socket.IO now has first class support for TypeScript.

Types for the server​

First, declare some types:

    interface ServerToClientEvents {
      noArg: () => void;
      basicEmit: (a: number, b: string, c: Buffer) => void;
      withAck: (d: string, callback: (e: number) => void) => void;
    }

    interface ClientToServerEvents {
      hello: () => void;
    }

    interface InterServerEvents {
      ping: () => void;
    }

    interface SocketData {
      name: string;
      age: number;
    }

[][]

And use them when creating your server:

    const io = new Server<
      ClientToServerEvents,
      ServerToClientEvents,
      InterServerEvents,
      SocketData
    >();

[][]

Then, profit from the help of your IDE!

The events declared in the ServerToClientEvents interface are used when
sending and broadcasting events:

    io.on("connection", (socket) => {
      socket.emit("noArg");
      socket.emit("basicEmit", 1, "2", Buffer.from([3]));
      socket.emit("withAck", "4", (e) => {
        // e is inferred as number
      });

      // works when broadcast to all
      io.emit("noArg");

      // works when broadcasting to a room
      io.to("room1").emit("basicEmit", 1, "2", Buffer.from([3]));
    });

[][]

The ones declared in the ClientToServerEvents interface are used when
receiving events:

    io.on("connection", (socket) => {
      socket.on("hello", () => {
        // ...
      });
    });

[][]

The ones declared in the InterServerEvents interface are used for
inter-server communication (added in socket.io@4.1.0):

    io.serverSideEmit("ping");

    io.on("ping", () => {
      // ...
    });

[][]

And finally, the SocketData type is used to type the socket.data
attribute (added in socket.io@4.4.0):

    io.on("connection", (socket) => {
      socket.data.name = "john";
      socket.data.age = 42;
    });

[][]

[]caution

These type hints do not replace proper validation/sanitization of the
input. As usual, never trust user input.

Types for the client​

On the client side, you can reuse the same ServerToClientEvents and
ClientToServerEvents interfaces:

    import { io, Socket } from "socket.io-client";

    // please note that the types are reversed
    const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();

[][]

Similarly, the events declared in the ClientToServerEvents interface are
used when sending events:

    socket.emit("hello");

[][]

And the ones declared in ServerToClientEvents are used when receiving
events:

    socket.on("noArg", () => {
      // ...
    });

    socket.on("basicEmit", (a, b, c) => {
      // a is inferred as number, b as string and c as buffer
    });

    socket.on("withAck", (d, callback) => {
      // d is inferred as string and callback as a function that takes a number as argument
    });

[][]

Custom types for each namespace​

Since each Namespace can have its own set of events, you can also
provide some types for each one of them:

    import { Server } from "socket.io";

    // types for the main namespace
    const io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>();

    // types for the namespace named "/my-namespace"
    interface NamespaceSpecificClientToServerEvents {
      foo: (arg: string) => void
    }

    interface NamespaceSpecificServerToClientEvents {
      bar: (arg: string) => void;
    }

    interface NamespaceSpecificInterServerEvents {
      // ...
    }

    interface NamespaceSpecificSocketData {
      // ...
    }

    const myNamespace: Namespace<
      NamespaceSpecificClientToServerEvents,
      NamespaceSpecificServerToClientEvents,
      NamespaceSpecificInterServerEvents,
      NamespaceSpecificSocketData
      > = io.of("/my-namespace");

    myNamespace.on("connection", (socket) => {
      socket.on("foo", () => {
        // ...
      });

      socket.emit("bar", "123");
    });

[][]

And on the client side:

    import { io, Socket } from "socket.io-client";

    const socket: Socket<
      NamespaceSpecificServerToClientEvents,
      NamespaceSpecificClientToServerEvents
      > = io("/my-namespace");

    socket.on("bar", (arg) => {
      console.log(arg); // "123"
    });

[][]

[]Edit this page

Last updated on Mar 28, 2025

Previous

Troubleshooting

Next

Memory usage

- Types for the server
- Types for the client
- Custom types for each namespace

=============

## doc_docs_v4_using-multiple-nodes_.txt

- []
- Server
- Using multiple nodes

Version: 4.x

On this page

Using multiple nodes

When deploying multiple Socket.IO servers, there are two things to take
care of:

- enabling sticky session, if HTTP long-polling is enabled (which is the
  default): see below
- using a compatible adapter, see here

Sticky load balancing​

If you plan to distribute the load of connections among different
processes or machines, you have to make sure that all requests
associated with a particular session ID reach the process that
originated them.

Why is sticky-session required​

This is because the HTTP long-polling transport sends multiple HTTP
requests during the lifetime of the Socket.IO session.

In fact, Socket.IO could technically work without sticky sessions, with
the following synchronization (in dashed lines):

[Using multiple nodes without sticky sessions][Using multiple nodes
without sticky sessions]

While obviously possible to implement, we think that this
synchronization process between the Socket.IO servers would result in a
big performance hit for your application.

Remarks:

- without enabling sticky-session, you will experience HTTP 400 errors
  due to "Session ID unknown"
- the WebSocket transport does not have this limitation, since it relies
  on a single TCP connection for the whole session. Which means that if
  you disable the HTTP long-polling transport (which is a perfectly
  valid choice in 2021), you won't need sticky sessions:

    const socket = io("https://io.yourhost.com", {
      // WARNING: in that case, there is no fallback to long-polling
      transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)
    });

[][]

Documentation: transports

Enabling sticky-session​

To achieve sticky-session, there are two main solutions:

- routing clients based on a cookie (recommended solution)
- routing clients based on their originating address

You will find below some examples with common load-balancing solutions:

- nginx (IP-based)
- nginx Ingress (Kubernetes) (IP-based)
- Apache HTTPD (cookie-based)
- HAProxy (cookie-based)
- Traefik (cookie-based)
- Node.js cluster module

For other platforms, please refer to the relevant documentation:

- Kubernetes:
  https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/
- AWS (Application Load Balancers):
  https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html
- GCP:
  https://cloud.google.com/load-balancing/docs/backend-service#session_affinity
- Heroku: https://devcenter.heroku.com/articles/session-affinity

Important note: if you are in a CORS situation (the front domain is
different from the server domain) and session affinity is achieved with
a cookie, you need to allow credentials:

Server

    const io = require("socket.io")(httpServer, {
      cors: {
        origin: "https://front-domain.com",
        methods: ["GET", "POST"],
        credentials: true
      }
    });

[][]

Client

    const io = require("socket.io-client");
    const socket = io("https://server-domain.com", {
      withCredentials: true
    });

[][]

Without it, the cookie will not be sent by the browser and you will
experience HTTP 400 "Session ID unknown" responses. More information
here.

nginx configuration​

Within the http { } section of your nginx.conf file, you can declare a
upstream section with a list of Socket.IO process you want to balance
load between:

    http {
      server {
        listen 3000;
        server_name io.yourhost.com;

        location / {
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $host;

          proxy_pass http://nodes;

          # enable WebSockets
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
        }
      }

      upstream nodes {
        # enable sticky session with either "hash" (uses the complete IP address)
        hash $remote_addr consistent;
        # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)
        # ip_hash;
        # or "sticky" (needs commercial subscription)
        # sticky cookie srv_id expires=1h domain=.example.com path=/;

        server app01:3000;
        server app02:3000;
        server app03:3000;
      }
    }

[][]

Notice the hash instruction that indicates the connections will be
sticky.

Make sure you also configure worker_processes in the topmost level to
indicate how many workers nginx should use. You might also want to look
into tweaking the worker_connections setting within the events { }
block.

Links:

- Example
- nginx Documentation

[]caution

The value of nginx's proxy_read_timeout (60 seconds by default) must be
bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by
default), else nginx will forcefully close the connection if no data is
sent after the given delay and the client will get a "transport close"
error.

nginx Ingress (Kubernetes)​

Within the annotations section of your Ingress configuration, you can
declare an upstream hashing based on the client's IP address, so that
the Ingress controller always assigns the requests from a given IP
address to the same pod:

    apiVersion: networking.k8s.io/v1
    kind: Ingress
    metadata:
      name: your-ingress
      namespace: your-namespace
      annotations:
        nginx.ingress.kubernetes.io/configuration-snippet: |
          set $forwarded_client_ip "";
          if ($http_x_forwarded_for ~ "^([^,]+)") {
            set $forwarded_client_ip $1;
          }
          set $client_ip $remote_addr;
          if ($forwarded_client_ip != "") {
            set $client_ip $forwarded_client_ip;
          }
        nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"
    spec:
      ingressClassName: nginx
      rules:
        - host: io.yourhost.com
          http:
            paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: your-service
                    port:
                      number: 80

[][]

Notes:

- nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"

This annotation instructs the NGINX Ingress Controller to use the
client's IP address for routing incoming traffic to a specific Pod in
your Kubernetes cluster. This is crucial for maintaining sticky
sessions.

- nginx.ingress.kubernetes.io/configuration-snippet

This custom NGINX configuration snippet serves a dual purpose:

1.  If the request passes through upstream reverse proxies or API
    gateways that append an X-Forwarded-For header, this snippet
    extracts the first IP address from that header and uses it to update
    the $client_ip.

2.  In the absence of such proxies or gateways, the snippet simply uses
    the remote_addr, which is the IP address of the client directly
    connected to the ingress.

This ensures that the correct client IP is used for the sticky session
logic, enabled by the
nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip" annotation.
The snippet is particularly important when your architecture includes
upstream network components like reverse proxies or API gateways.

Links:

- Ingress Nginx Documentation
- X-Forwarded-For Header

Apache HTTPD configuration​

    Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED

    <Proxy "balancer://nodes_polling">
        BalancerMember "http://app01:3000" route=app01
        BalancerMember "http://app02:3000" route=app02
        BalancerMember "http://app03:3000" route=app03
        ProxySet stickysession=SERVERID
    </Proxy>

    <Proxy "balancer://nodes_ws">
        BalancerMember "ws://app01:3000" route=app01
        BalancerMember "ws://app02:3000" route=app02
        BalancerMember "ws://app03:3000" route=app03
        ProxySet stickysession=SERVERID
    </Proxy>

    RewriteEngine On
    RewriteCond %{HTTP:Upgrade} =websocket [NC]
    RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]
    RewriteCond %{HTTP:Upgrade} !=websocket [NC]
    RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]

    # must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)
    ProxyTimeout 60

[][]

Links:

- Example
- Documentation

HAProxy configuration​

    # Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/

    listen chat
      bind *:80
      default_backend nodes

    backend nodes
      option httpchk HEAD /health
      http-check expect status 200
      cookie io prefix indirect nocache # using the `io` cookie set upon handshake
      server app01 app01:3000 check cookie app01
      server app02 app02:3000 check cookie app02
      server app03 app03:3000 check cookie app03

[][]

Links:

- Example
- Documentation

Traefik​

Using container labels:

    # docker-compose.yml
    services:
      traefik:
        image: traefik:2.4
        volumes:
          - /var/run/docker.sock:/var/run/docker.sock
        links:
          - server

      server:
        image: my-image:latest
        labels:
          - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"
          - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id
          - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true

[][]

With the File provider:

    ## Dynamic configuration
    http:
      services:
        my-service:
          rule: "PathPrefix(`/`)"
          loadBalancer:
            sticky:
              cookie:
                name: server_id
                httpOnly: true

[][]

Links:

- Example
- Documentation

Using Node.js Cluster​

Just like nginx, Node.js comes with built-in clustering support through
the cluster module.

There are several solutions, depending on your use case:

         NPM package        How it works
  ------------------------- --------------------------------------------------
      @socket.io/sticky     the routing is based on the sid query parameter
       sticky-session       the routing is based on connection.remoteAddress
   socketio-sticky-session  the routing based on the x-forwarded-for header)

Example with @socket.io/sticky:

    const cluster = require("cluster");
    const http = require("http");
    const { Server } = require("socket.io");
    const numCPUs = require("os").cpus().length;
    const { setupMaster, setupWorker } = require("@socket.io/sticky");
    const { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");

    if (cluster.isMaster) {
      console.log(`Master ${process.pid} is running`);

      const httpServer = http.createServer();

      // setup sticky sessions
      setupMaster(httpServer, {
        loadBalancingMethod: "least-connection",
      });

      // setup connections between the workers
      setupPrimary();

      // needed for packets containing buffers (you can ignore it if you only send plaintext objects)
      // Node.js < 16.0.0
      cluster.setupMaster({
        serialization: "advanced",
      });
      // Node.js > 16.0.0
      // cluster.setupPrimary({
      //   serialization: "advanced",
      // });

      httpServer.listen(3000);

      for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
      }

      cluster.on("exit", (worker) => {
        console.log(`Worker ${worker.process.pid} died`);
        cluster.fork();
      });
    } else {
      console.log(`Worker ${process.pid} started`);

      const httpServer = http.createServer();
      const io = new Server(httpServer);

      // use the cluster adapter
      io.adapter(createAdapter());

      // setup connection with the primary process
      setupWorker(io);

      io.on("connection", (socket) => {
        /* ... */
      });
    }

[][]

Passing events between nodes​

Now that you have multiple Socket.IO nodes accepting connections, if you
want to broadcast events to all clients (or to the clients in a certain
room) you’ll need some way of passing messages between processes or
computers.

The interface in charge of routing messages is what we call the Adapter.

[]Edit this page

Last updated on Mar 28, 2025

Previous

Behind a reverse proxy

Next

Handling CORS

- Sticky load balancing
  - Why is sticky-session required
  - Enabling sticky-session
  - nginx configuration
  - nginx Ingress (Kubernetes)
  - Apache HTTPD configuration
  - HAProxy configuration
  - Traefik
  - Using Node.js Cluster
- Passing events between nodes


